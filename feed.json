{
    "version": "https://jsonfeed.org/version/1",
    "title": "浅岛夏风",
    "subtitle": "生活就像海洋，只有意志将强的人才能到达彼岸",
    "icon": "https://gaoyuan.ink/images/favicon.ico",
    "description": "一枚微不足道的前端攻城狮",
    "home_page_url": "https://gaoyuan.ink",
    "items": [
        {
            "id": "https://gaoyuan.ink/2021/06/03/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAtab%E3%80%81tabs%E5%88%87%E6%8D%A2%E9%A1%B5%E7%AD%BE%E7%BB%84%E4%BB%B6/",
            "url": "https://gaoyuan.ink/2021/06/03/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAtab%E3%80%81tabs%E5%88%87%E6%8D%A2%E9%A1%B5%E7%AD%BE%E7%BB%84%E4%BB%B6/",
            "title": "实现一个tab、tabs切换页签组件",
            "date_published": "2021-06-03T06:14:12.000Z",
            "content_html": "<blockquote>\n<p>Tab 页签切换是常用组件，经常穿梭于各个业务场景中，这篇文章将代理大家实现一个 tabs 和 tab 组件</p>\n</blockquote>\n<p>我们先来看一下最终实现的效果图：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/ezgif-6-657d18cf7bba.gif\" alt=\"\"></p>\n<span id=\"more\"></span>\n<p>废话不多说，直接上代码，</p>\n<p>先来看 tabs.vue：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;tabs&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;tabs-bar&quot;&gt;</span><br><span class=\"line\">      &lt;div</span><br><span class=\"line\">        v-for=&quot;(item,index) in navList&quot;</span><br><span class=\"line\">        :key=&quot;item.name&quot;</span><br><span class=\"line\">        :class=&quot;tabCls(item)&quot;</span><br><span class=\"line\">        @click=&quot;handleChange(index)&quot;&gt;</span><br><span class=\"line\">        &#123;&#123; item.label &#125;&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;tabs-content&quot;&gt;</span><br><span class=\"line\">      &lt;slot /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;Tabs&#x27;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    value: &#123;</span><br><span class=\"line\">      type: [String, Number],</span><br><span class=\"line\">      default: null</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    required: &#123;</span><br><span class=\"line\">      type: Boolean,</span><br><span class=\"line\">      default: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      currentValue: this.value,</span><br><span class=\"line\">      navList: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    value: function (val) &#123;</span><br><span class=\"line\">      this.currentValue = val</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    currentValue () &#123;</span><br><span class=\"line\">      this.updateStatus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    tabCls (item) &#123;</span><br><span class=\"line\">      return [</span><br><span class=\"line\">        &#x27;tabs-tab&#x27;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &#x27;tabs-tab-active&#x27;: item.name === this.currentValue</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    getTabs () &#123;</span><br><span class=\"line\">      // 获取tab</span><br><span class=\"line\">      return this.$children.filter(function (item) &#123;</span><br><span class=\"line\">        // console.log(&#x27;===&gt;&#x27;, item.$options.name)</span><br><span class=\"line\">        return item.$options.name === &#x27;Tab&#x27;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    updateNav () &#123;</span><br><span class=\"line\">      // 获取标题，name,并放置到navList数组中</span><br><span class=\"line\">      // console.log(&#x27;获取标题，name,并放置到navList数组中&#x27;, this.$children, this.getTabs())</span><br><span class=\"line\">      this.navList = []</span><br><span class=\"line\">      let _this = this</span><br><span class=\"line\">      this.getTabs().forEach(function (tab, index) &#123;</span><br><span class=\"line\">        _this.navList.push(&#123;</span><br><span class=\"line\">          label: tab.label,</span><br><span class=\"line\">          name: tab.name || index</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        if (!tab.name) tab.name = index</span><br><span class=\"line\">        if (index === 0) &#123;</span><br><span class=\"line\">          if (!_this.currentValue) &#123;</span><br><span class=\"line\">            _this.currentValue = tab.name || index</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      this.updateStatus()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    updateStatus () &#123;</span><br><span class=\"line\">      let tabs = this.getTabs()</span><br><span class=\"line\">      let _this = this</span><br><span class=\"line\">      tabs.forEach(function (tab) &#123;</span><br><span class=\"line\">        let b = tab.name === _this.currentValue</span><br><span class=\"line\">        tab.show = b</span><br><span class=\"line\">        return tab.show</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleChange (index) &#123;</span><br><span class=\"line\">      let nav = this.navList[index]</span><br><span class=\"line\">      let name = nav.name</span><br><span class=\"line\">      this.currentValue = name</span><br><span class=\"line\">      this.$emit(&#x27;input&#x27;, name)</span><br><span class=\"line\">      this.$emit(&#x27;on-click&#x27;, name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">[v-cloak] &#123;</span><br><span class=\"line\">  display: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.tabs &#123;</span><br><span class=\"line\">  font-size: 14px;</span><br><span class=\"line\">  color: #657180;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.tabs-bar:after &#123;</span><br><span class=\"line\">  content: &quot;&quot;;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 1px;</span><br><span class=\"line\">  background: #d7dde4;</span><br><span class=\"line\">  margin-top: -1px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.tabs-tab &#123;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  padding: 4px 16px;</span><br><span class=\"line\">  margin-right: 6px;</span><br><span class=\"line\">  background: #fff;</span><br><span class=\"line\">  border: 1px solid #d7dde4;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.tabs-tab-active &#123;</span><br><span class=\"line\">  color: #3399ff;</span><br><span class=\"line\">  border-top: 1px solid #3399ff;</span><br><span class=\"line\">  border-bottom: 1px solid #3399ff;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.tabs-tab-active:before &#123;</span><br><span class=\"line\">  content: &quot;&quot;;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  height: 1px;</span><br><span class=\"line\">  background: #3399ff;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.tabs-content &#123;</span><br><span class=\"line\">  padding: 8px 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如下是 tab.vue：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div</span><br><span class=\"line\">    v-show=&quot;show&quot;</span><br><span class=\"line\">    class=&quot;tab&quot;&gt;</span><br><span class=\"line\">    &lt;slot /&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;Tab&#x27;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    name: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &#x27;&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    label: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &#x27;&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      show: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    active () &#123;</span><br><span class=\"line\">      return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    label () &#123;</span><br><span class=\"line\">      this.updateNav()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted () &#123;</span><br><span class=\"line\">    this.updateNav()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    updateNav () &#123;</span><br><span class=\"line\">      this.$parent.updateNav()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>最后我们来看一下如何使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;tabs v-model=&quot;value&quot;&gt;</span><br><span class=\"line\">      &lt;tab</span><br><span class=\"line\">        label=&quot;标签一&quot;</span><br><span class=\"line\">        name=&quot;1&quot;&gt;</span><br><span class=\"line\">        标签一内容</span><br><span class=\"line\">      &lt;/tab&gt;</span><br><span class=\"line\">      &lt;tab</span><br><span class=\"line\">        label=&quot;标签二&quot;</span><br><span class=\"line\">        name=&quot;2&quot;&gt;</span><br><span class=\"line\">        标签二内容</span><br><span class=\"line\">      &lt;/tab&gt;</span><br><span class=\"line\">      &lt;tab</span><br><span class=\"line\">        label=&quot;标签三&quot;</span><br><span class=\"line\">        name=&quot;3&quot;&gt;</span><br><span class=\"line\">        标签三内容</span><br><span class=\"line\">      &lt;/tab&gt;</span><br><span class=\"line\">    &lt;/tabs&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import tabs from &#x27;@/component/tabs&#x27;</span><br><span class=\"line\">import tab from &#x27;@/component/tab&#x27;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    tabs,</span><br><span class=\"line\">    tab</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      value: &#x27;&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Vue专题",
                "vue"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/05/12/Javascript%E4%B8%AD%E5%93%AA%E4%B8%80%E7%A7%8D%E5%BE%AA%E7%8E%AF%E6%9C%80%E5%BF%AB%E5%91%A2%EF%BC%9F/",
            "url": "https://gaoyuan.ink/2021/05/12/Javascript%E4%B8%AD%E5%93%AA%E4%B8%80%E7%A7%8D%E5%BE%AA%E7%8E%AF%E6%9C%80%E5%BF%AB%E5%91%A2%EF%BC%9F/",
            "title": "Javascript中哪一种循环最快呢？",
            "date_published": "2021-05-12T03:31:26.000Z",
            "content_html": "<blockquote>\n<p>了解哪一种  <code>for</code>  循环或迭代器适合我们的需求，防止我们犯下一些影响应用性能的低级错误。</p>\n</blockquote>\n<p>JavaScript 是 Web 开发领域的 “常青树”。无论是 JavaScript 框架（如 Node.js、React、Angular、Vue 等），还是原生 JavaScript，都拥有非常庞大的粉丝基础。我们来谈谈现代 JavaScript 吧。循环一直是大多数编程语言的重要组成部分，而现代 JavaScript 为我们提供了许多迭代或循环值的方法。</p>\n<p>但问题在于，我们是否真的知道哪种循环或迭代最适合我们的需求。 <code>for</code>  循环有很多变形，例如  <code>for</code> 、 <code>for</code> （倒序）、 <code>for…of</code> 、 <code>forEach</code> 、 <code>for…in</code> 、 <code>for…await</code> 。本文将围绕这些展开讨论。</p>\n<span id=\"more\"></span>\n<h2 id=\"究竟哪一种循环更快\"><a class=\"markdownIt-Anchor\" href=\"#究竟哪一种循环更快\">#</a> 究竟哪一种循环更快？</h2>\n<p><strong>答案其实是：</strong>  <code>for</code> （倒序）</p>\n<p>最让我感到惊讶的事情是，当我在本地计算机上进行测试之后，我不得不接受  <code>for</code> （倒序）是所有  <code>for</code>  循环中最快的这一事实。下面我会举个对一个包含超过一百万项元素的数组执行一次循环遍历的例子。</p>\n<p><strong>声明</strong>： <code>console.time()</code>  结果的准确度在很大程度上取决于我们运行测试的系统配置。你可以在 https://johnresig.com/blog/accuracy-of-javascript-time/ 对准确度作进一步了解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const million = 1000000; </span><br><span class=\"line\">const arr = Array(million);</span><br><span class=\"line\"></span><br><span class=\"line\">// 注：这是稀疏数组，应该为其指定内容，否则不同方式的循环对其的处理方式会不同：</span><br><span class=\"line\">// const arr = [...Array(million)]</span><br><span class=\"line\"></span><br><span class=\"line\">console.time(&#x27;⏳&#x27;);</span><br><span class=\"line\">for (let i = arr.length; i &gt; 0; i--) &#123;&#125; // for(倒序)  :- 1.5ms</span><br><span class=\"line\">for (let i = 0; i &lt; arr.length; i++) &#123;&#125; // for          :- 1.6ms</span><br><span class=\"line\">arr.forEach(v =&gt; v)                     // foreach      :- 2.1ms</span><br><span class=\"line\">for (const v of arr) &#123;&#125;                 // for...of     :- 11.7ms</span><br><span class=\"line\">console.timeEnd(&#x27;⏳&#x27;);</span><br></pre></td></tr></table></figure>\n<p>造成这样结果的原因很简单，在代码中，正序和倒序的  <code>for</code>  循环几乎花费一样的时间，仅仅相差了 0.1 毫秒。原因是， <code>for</code> （倒序）只需要计算一次起始变量  <code>let i = arr.length</code> ，而在正序的  <code>for</code>  循环中，它在每次变量增加后都会检查条件  <code>i&lt;arr.length</code> 。这个细微的差别不是很重要，你可以忽略它。（译者注：在数据量小或对时间不敏感的代码上，我们大可忽略它，但是根据译者的测试，当数据量扩大，例如十亿，千亿等的数量级，差距就显著提升，我们就需要考虑时间对应用程序性能的影响了。）同理，如果知道了差异，正序循环也可以做优化，将 arr.length 存下来， <code>for(let i=0,j=arr.length;i&lt;j;i++)&#123;&#125;</code></p>\n<p>而  <code>forEach</code>  是  <code>Array</code>  原型的一个方法，与普通的  <code>for</code>  循环相比， <code>forEach</code>  和  <code>for…of</code>  需要花费更多的时间进行数组迭代。（译者注：但值得注意的是， <code>for…of</code>  和  <code>forEach</code>  都从对象中获取了数据，而原型并没有，因此没有可比性。）</p>\n<h2 id=\"循环的类型以及我们应该在何处使用它们\"><a class=\"markdownIt-Anchor\" href=\"#循环的类型以及我们应该在何处使用它们\">#</a> 循环的类型，以及我们应该在何处使用它们</h2>\n<h3 id=\"1-for-循环正序和倒序\"><a class=\"markdownIt-Anchor\" href=\"#1-for-循环正序和倒序\">#</a> <strong>1. For 循环（正序和倒序）</strong></h3>\n<p>我想，也许大家都应该对这个基础循环非常熟悉了。我们可以在任何我们需要的地方使用  <code>for</code>  循环，按照核定的次数运行一段代码。最基础的  <code>for</code>  循环运行最迅速的，那我们每一次都应该使用它，对吗？并不然，性能不仅仅只是唯一尺度，代码可读性往往更加重要，就让我们选择适合我们应用程序的变形即可。</p>\n<h3 id=\"2-foreach\"><a class=\"markdownIt-Anchor\" href=\"#2-foreach\">#</a> <strong>2.  <code>forEach</code> </strong></h3>\n<p>这个方法需要接受一个回调函数作为输入参数，遍历数组的每一个元素，并执行我们的回调函数（以元素本身和它的索引（可选参数）作为参数赋予给回调函数）。 <code>forEach</code>  还允许在回调函数中使用一个可选参数  <code>this</code> 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const things = [&#x27;have&#x27;, &#x27;fun&#x27;, &#x27;coding&#x27;];</span><br><span class=\"line\">const callbackFun = (item, idex) =&gt; &#123;</span><br><span class=\"line\">    console.log(`$&#123;item&#125; - $&#123;index&#125;`);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">things.foreach(callbackFun); </span><br><span class=\"line\">/* 输出   have - 0</span><br><span class=\"line\">        fun - 1</span><br><span class=\"line\">        coding - 2 */</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，如果我们要使用  <code>forEach</code> ，我们不能使用 JavaScript 的短路运算符，即不能在每一次循环中跳过或结束循环。</p>\n<h3 id=\"3-forof\"><a class=\"markdownIt-Anchor\" href=\"#3-forof\">#</a> <strong>3.  <code>for…of</code> </strong></h3>\n<p><code>for…of</code>  是在 ES6（ECMAScript 6）中实现标准化的。它会对一个可迭代的对象（例如  <code>array</code> 、 <code>map</code> 、 <code>set</code> 、 <code>string</code>  等）创建一个循环，并且有一个突出的优点，即优秀的可读性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [3, 5, 7];</span><br><span class=\"line\">const str = &#x27;hello&#x27;;</span><br><span class=\"line\">for (let i of arr) &#123;</span><br><span class=\"line\">   console.log(i); // 输出 3, 5, 7</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for (let i of str) &#123;</span><br><span class=\"line\">   console.log(i); // 输出 &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，请不要在生成器中使用  <code>for……of</code> ，即便  <code>for……of</code>  循环提前终止。在退出循环后，生成器被关闭，并尝试再次迭代，不会产生任何进一步的结果。</p>\n<h3 id=\"4-for-in\"><a class=\"markdownIt-Anchor\" href=\"#4-for-in\">#</a> <strong>4.  <code>for</code>   <code>in</code> </strong></h3>\n<p><code>for…in</code>  会在对象的所有可枚举属性上迭代指定的变量。对于每个不同的属性， <code>for…in</code>  语句除返回数字索引外，还将返回用户定义的属性的名称。因此，在遍历数组时最好使用带有数字索引的传统  <code>for</code>  循环。因为  <code>for…in</code>  语句还会迭代除数组元素之外的用户定义属性，就算我们修改了数组对象（例如添加自定义属性或方法），依然如此。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const details = &#123;firstName: &#x27;john&#x27;, lastName: &#x27;Doe&#x27;&#125;;</span><br><span class=\"line\">let fullName = &#x27;&#x27;;</span><br><span class=\"line\">for (let i in details) &#123;</span><br><span class=\"line\">    fullName += details[i] + &#x27; &#x27;; // fullName: john doe</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"forof-和-forin\"><a class=\"markdownIt-Anchor\" href=\"#forof-和-forin\">#</a>  <code>for…of</code>  和  <code>for…in</code></h2>\n<p><code>for…of</code>  和  <code>for…in</code>  之间的主要区别是它们迭代的内容。 <code>for…in</code>  循环遍历对象的属性，而  <code>for…of</code>  循环遍历可迭代对象的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr= [4, 5, 6];</span><br><span class=\"line\">for (let i in arr) &#123;</span><br><span class=\"line\">   console.log(i); // &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for (let i of arr) &#123;</span><br><span class=\"line\">   console.log(i); // &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-遍历数组通常用for循环\"><a class=\"markdownIt-Anchor\" href=\"#1-遍历数组通常用for循环\">#</a> 1. 遍历数组通常用 for 循环</h3>\n<p>ES5 的话也可以使用 forEach，ES5 具有遍历数组功能的还有 map、filter、some、every、reduce、reduceRight 等，只不过他们的返回结果不一样。但是使用 foreach 遍历数组的话，使用 break 不能中断循环，使用 return 也不能返回到外层函数。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.method=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">myArray.name=<span class=\"string\">&quot;数组&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index <span class=\"keyword\">in</span> myArray) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(myArray[index]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-for-in遍历数组的毛病\"><a class=\"markdownIt-Anchor\" href=\"#2-for-in遍历数组的毛病\">#</a> 2. for in 遍历数组的毛病</h3>\n<p>1.index 索引为字符串型数字，不能直接进行几何运算<br>\n 2. 遍历顺序有可能不是按照实际数组的内部顺序<br>\n 3. 使用 for in 会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法 method 和 name 属性<br>\n所以 for in 更适合遍历对象，不要使用 for in 遍历数组。</p>\n<p>那么除了使用 for 循环，如何更简单的正确的遍历数组达到我们的期望呢（即不遍历 method 和 name），ES6 中的 for of 更胜一筹.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.method=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myArray=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">myArray.name=<span class=\"string\">&quot;数组&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> myArray) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>记住，for in 遍历的是数组的索引（即键名），而 for of 遍历的是数组元素值。</em></p>\n<p>for of 遍历的只是数组内的元素，而不包括数组的原型属性 method 和索引 name</p>\n<h3 id=\"3-遍历对象\"><a class=\"markdownIt-Anchor\" href=\"#3-遍历对象\">#</a> 3. 遍历对象</h3>\n<p>遍历对象 通常用 for in 来遍历对象的键名</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.method=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject=&#123;</span><br><span class=\"line\">　　<span class=\"attr\">a</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">　　<span class=\"attr\">b</span>:<span class=\"number\">2</span>,</span><br><span class=\"line\">　　<span class=\"attr\">c</span>:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> myObject) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>for in 可以遍历到 myObject 的原型方法 method, 如果不想遍历原型方法和属性的话，可以在循环内部判断一下，hasOwnPropery 方法可以判断某属性是否是该对象的实例属性</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> myObject) &#123;</span><br><span class=\"line\">　　<span class=\"keyword\">if</span>（myObject.hasOwnProperty(key))&#123;</span><br><span class=\"line\">　　　　<span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样可以通过 ES5 的 Object.keys (myObject) 获取对象的实例属性组成的数组，不包括原型方法和属性</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.method=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject=&#123;</span><br><span class=\"line\">　　<span class=\"attr\">a</span>:<span class=\"number\">1</span>,</span><br><span class=\"line\">　　<span class=\"attr\">b</span>:<span class=\"number\">2</span>,</span><br><span class=\"line\">　　<span class=\"attr\">c</span>:<span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<ul>\n<li>for…of 适用遍历数 / 数组对象 / 字符串 /map/set 等拥有迭代器对象的集合。但是不能遍历对象，因为没有迭代器对象。与 forEach () 不同的是，它可以正确响应 break、continue 和 return 语句</li>\n<li>for-of 循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用 for-in 循环（这也是它的本职工作）或内建的 Object.keys () 方法：</li>\n</ul>\n<h2 id=\"结论\"><a class=\"markdownIt-Anchor\" href=\"#结论\">#</a> 结论</h2>\n<ul>\n<li><code>for</code>  最快，但可读性比较差</li>\n<li><code>foreach</code>  比较快，能够控制内容</li>\n<li><code>for...of</code>  比较慢，但香</li>\n<li><code>for...in</code>  比较慢，没那么方便</li>\n</ul>\n<p>最后，给你一条明智的建议 —— 优先考虑可读性。尤其是当我们开发复杂的结构程序时，更需要这样做。当然，我们也应该专注于性能。尽量避免增添不必要的、多余的花哨代码，因为这有时可能对你的程序性能造成严重影响。祝你编码愉快。</p>\n",
            "tags": [
                "JavaScript专题",
                "JavaScript专题"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/04/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94%E2%80%94%E2%80%94%E6%89%8B%E6%B7%98flexible/",
            "url": "https://gaoyuan.ink/2021/04/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94%E2%80%94%E2%80%94%E6%89%8B%E6%B7%98flexible/",
            "title": "移动端自适应——手淘flexible",
            "date_published": "2021-04-25T03:21:51.000Z",
            "content_html": "<h2 id=\"移动端自适应手淘flexible\"><a class=\"markdownIt-Anchor\" href=\"#移动端自适应手淘flexible\">#</a> 移动端自适应 —— 手淘 flexible</h2>\n<p>熟悉移动端的自适应方案的朋友对 rem 适应方案，肯定不陌生，最出名的就是阿里的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2FtZmUvbGliLWZsZXhpYmxl\">lib-flexible</span> 方案。</p>\n<p>** 原理：**flexible 就是根据不同的屏幕算出 html 的 font-size，通过 js 来动态写 meta 标签。</p>\n<p>事实上他做了这几样事情：</p>\n<ul>\n<li>动态改写 <code>&lt;meta&gt;</code>  标签</li>\n<li>给 <code>&lt;html&gt;</code>  元素添加 <code>data-dpr</code>  属性，并且动态改写 <code>data-dpr</code>  的值</li>\n<li>给 <code>&lt;html&gt;</code>  元素添加 <code>font-size</code>  属性，并且动态改写 <code>font-size</code>  的值</li>\n</ul>\n<p>比如我们在做移动端的时候，经常拿到的设计稿是 640px 或者 750px。自己项目中就是 640px，以此为例，自己在项目中为了计算方便，所以给 html 根元素设置的字体大小是 100px，也就是在 640px 下面。这里注意，我们给 html 设置 100px，这个是字体哦，所以最好在 body 设置一下字体大小。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置html元素的字体大小为100px</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 所有的像素我们直接除以</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">640px  ——  6.4rem</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">64px —— 0.64rem</span><br></pre></td></tr></table></figure>\n<p>那么如果 64px，对应我们写 rem 就是 0.64rem，也不需要动用计算器去计算 rem，需要多强的大脑呀（虽然有很多插件帮我们）</p>\n<p>修改 flexible.js。640px 下面的 10 就变成 6.4</p>\n<p>![image-20210425112100315](/Users/gaoyuan/Library/Application Support/typora-user-images/image-20210425112100315.png)</p>\n<p>这样，我们页面直接把 px 换算成 rem，就可以实现自适应。（记住，自己这里以 640px 设计稿为基础，如果是 750px 就是除以 7.5）。</p>\n<p><strong>字号不使用 rem</strong></p>\n<p>我们都知道 chrome 的最小显示的字体是 12px，如果字体用 rem，计算出来小于 12px，那么就也会以 12px 显示，而且我们不希望出现 13px 或者 15px 这样的奇葩尺寸，所以字体最好是用 px 来表示，至于适应，我们可以写媒体查询。</p>\n<h2 id=\"vue中使用rem\"><a class=\"markdownIt-Anchor\" href=\"#vue中使用rem\">#</a> vue 中使用 rem</h2>\n<p>vue 现在正是火的势头上，作者说明年估计 3.0 要出来了。那么在 vue 我们如果做移动端自适应怎么弄呢？</p>\n<p><strong>安装 flexible</strong></p>\n<p><em>在命令行中运行如下安装：</em></p>\n<blockquote>\n<p>npm i lib-flexible --save-dev</p>\n</blockquote>\n<p><strong>引入 flexible</strong></p>\n<p><em>在项目入口文件 main.js 里 引入 lib-flexible</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;lib-flexible&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>对于我们的 index.html，最好是不要 meta 标签，flexible 会自动添加上的，因为有一个判断。当然了，懒惰果然是最大的生产力，有的人觉得换算 rem 太麻烦，就出现了插件<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcHgycmVtLWxvYWRlcg==\"> px2rem-loader</span>，把 px 自动转化为对应的 rem。但是呢，麻烦的就是如果引入外部的 css 文件，那么也会把 px 转化为 rem。自己在项目中就是手动计算 rem，用上面的方法，直接除以 100，这个应该很简单吧，都是程序员，数学这个还是可以吧…</p>\n",
            "tags": [
                "移动端",
                "移动端"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/04/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E6%B1%87/",
            "url": "https://gaoyuan.ink/2021/04/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E6%B1%87/",
            "title": "浏览器回流和重汇",
            "date_published": "2021-04-16T01:20:34.000Z",
            "content_html": "<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/640\" alt=\"\"></p>\n<span id=\"more\"></span>\n<h2 id=\"一-是什么\"><a class=\"markdownIt-Anchor\" href=\"#一-是什么\">#</a> 一、是什么</h2>\n<p>在 <code>HTML</code>  中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘：</p>\n<ul>\n<li>回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置</li>\n<li>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</li>\n</ul>\n<p>具体的浏览器解析渲染机制如下所示：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20210416102029.png\" alt=\"\"></p>\n<ul>\n<li>解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树</li>\n<li>将 DOM 树和 CSSOM 树结合，生成渲染树 (Render Tree)</li>\n<li>Layout (回流): 根据生成的渲染树，进行回流 (Layout)，得到节点的几何信息（位置，大小）</li>\n<li>Painting (重绘): 根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>\n<li>Display: 将像素发送给 GPU，展示在页面上</li>\n</ul>\n<p>在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变</p>\n<p>当我们对  <code>DOM</code>  的修改引发了  <code>DOM</code>  几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来</p>\n<p>当我们对  <code>DOM</code>  的修改导致了样式的变化（ <code>color</code>  或 <code>background-color</code> ），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘</p>\n<h2 id=\"二-如何触发\"><a class=\"markdownIt-Anchor\" href=\"#二-如何触发\">#</a> 二、如何触发</h2>\n<p>要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的</p>\n<h3 id=\"回流触发时机\"><a class=\"markdownIt-Anchor\" href=\"#回流触发时机\">#</a> 回流触发时机</h3>\n<p>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：</p>\n<ul>\n<li>添加或删除可见的 DOM 元素</li>\n<li>元素的位置发生变化</li>\n<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>\n<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li>\n<li>页面一开始渲染的时候（这避免不了）</li>\n<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>\n</ul>\n<p>还有一些容易被忽略的操作：获取一些特定属性的值</p>\n<blockquote>\n<p>❝</p>\n<p>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</p>\n<p>❞</p>\n</blockquote>\n<p>这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流</p>\n<p>除此还包括 <code>getComputedStyle</code>  方法，原理是一样的</p>\n<h3 id=\"重绘触发时机\"><a class=\"markdownIt-Anchor\" href=\"#重绘触发时机\">#</a> 重绘触发时机</h3>\n<p>触发回流一定会触发重绘</p>\n<p>可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）</p>\n<p>除此之外还有一些其他引起重绘行为：</p>\n<ul>\n<li>颜色的修改</li>\n<li>文本方向的修改</li>\n<li>阴影的修改</li>\n</ul>\n<h3 id=\"浏览器优化机制\"><a class=\"markdownIt-Anchor\" href=\"#浏览器优化机制\">#</a> 浏览器优化机制</h3>\n<p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列</p>\n<p>当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的 <code>offsetTop</code>  等方法都会返回最新的数据</p>\n<p>因此浏览器不得不清空队列，触发回流重绘来返回正确的值</p>\n<h2 id=\"三-如何减少\"><a class=\"markdownIt-Anchor\" href=\"#三-如何减少\">#</a> 三、如何减少</h2>\n<p>我们了解了如何触发回流和重绘的场景，下面给出避免回流的经验：</p>\n<ul>\n<li>如果想设定元素的样式，通过改变元素的  <code>class</code>  类名 (尽可能在 DOM 树的最里层)</li>\n<li>避免设置多项内联样式</li>\n<li>应用元素的动画，使用  <code>position</code>  属性的  <code>fixed</code>  值或  <code>absolute</code>  值 (如前文示例所提)</li>\n<li>避免使用  <code>table</code>  布局， <code>table</code>  中每个元素的大小以及内容的改动，都会导致整个  <code>table</code>  的重新计算</li>\n<li>对于那些复杂的动画，对其设置  <code>position: fixed/absolute</code> ，尽可能地使元素脱离文档流，从而减少对其他元素的影响</li>\n<li>使用 css3 硬件加速，可以让 <code>transform</code> 、 <code>opacity</code> 、 <code>filters</code>  这些动画不会引起回流重绘</li>\n<li>避免使用 CSS 的  <code>JavaScript</code>  表达式</li>\n</ul>\n<p>在使用  <code>JavaScript</code>  动态插入多个节点时，可以使用 <code>DocumentFragment</code> . 创建后一次插入。就能避免多次的渲染性能</p>\n<p>但有时候，我们会无可避免地进行回流或者重绘，我们可以更好使用它们</p>\n<p>例如，多次修改一个把元素布局的时候，我们很可能会如下操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const el = document.getElementById(&#x27;el&#x27;)</span><br><span class=\"line\">for(let i=0;i&lt;10;i++) &#123;</span><br><span class=\"line\">    el.style.top  = el.offsetTop  + 10 + &quot;px&quot;;</span><br><span class=\"line\">    el.style.left = el.offsetLeft + 10 + &quot;px&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次循环都需要获取多次 <code>offset</code>  属性，比较糟糕，可以使用变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 缓存offsetLeft与offsetTop的值</span><br><span class=\"line\">const el = document.getElementById(&#x27;el&#x27;)</span><br><span class=\"line\">let offLeft = el.offsetLeft, offTop = el.offsetTop</span><br><span class=\"line\"></span><br><span class=\"line\">// 在JS层面进行计算</span><br><span class=\"line\">for(let i=0;i&lt;10;i++) &#123;</span><br><span class=\"line\">  offLeft += 10</span><br><span class=\"line\">  offTop  += 10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 一次性将计算结果应用到DOM上</span><br><span class=\"line\">el.style.left = offLeft + &quot;px&quot;</span><br><span class=\"line\">el.style.top = offTop  + &quot;px&quot;</span><br></pre></td></tr></table></figure>\n<p>我们还可避免改变样式，使用类名去合并样式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const container = document.getElementById(&#x27;container&#x27;)</span><br><span class=\"line\">container.style.width = &#x27;100px&#x27;</span><br><span class=\"line\">container.style.height = &#x27;200px&#x27;</span><br><span class=\"line\">container.style.border = &#x27;10px solid red&#x27;</span><br><span class=\"line\">container.style.color = &#x27;red&#x27;</span><br></pre></td></tr></table></figure>\n<p>使用类名去合并样式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .basic_style &#123;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        border: 10px solid red;</span><br><span class=\"line\">        color: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    const container = document.getElementById(&#x27;container&#x27;)</span><br><span class=\"line\">    container.classList.add(&#x27;basic_style&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>前者每次单独操作，都去触发一次渲染树更改（新浏览器不会），</p>\n<p>都去触发一次渲染树更改，从而导致相应的回流与重绘过程</p>\n<p>合并之后，等于我们将所有的更改一次性发出</p>\n<p>我们还可以通过通过设置元素属性 <code>display: none</code> ，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const container = document.getElementById(&#x27;container&#x27;)</span><br><span class=\"line\">container.style.width = &#x27;100px&#x27;</span><br><span class=\"line\">container.style.height = &#x27;200px&#x27;</span><br><span class=\"line\">container.style.border = &#x27;10px solid red&#x27;</span><br><span class=\"line\">container.style.color = &#x27;red&#x27;</span><br></pre></td></tr></table></figure>\n<p>离线操作后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let container = document.getElementById(&#x27;container&#x27;)</span><br><span class=\"line\">container.style.display = &#x27;none&#x27;</span><br><span class=\"line\">container.style.width = &#x27;100px&#x27;</span><br><span class=\"line\">container.style.height = &#x27;200px&#x27;</span><br><span class=\"line\">container.style.border = &#x27;10px solid red&#x27;</span><br><span class=\"line\">container.style.color = &#x27;red&#x27;</span><br><span class=\"line\">...（省略了许多类似的后续操作）</span><br><span class=\"line\">container.style.display = &#x27;block&#x27;</span><br></pre></td></tr></table></figure>\n<h2 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h2>\n",
            "tags": [
                "个人笔记",
                "note"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/04/13/%E5%AE%9E%E7%8E%B0%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB%E2%80%94%E6%B8%90%E5%85%A5%E5%8A%A8%E7%94%BB/",
            "url": "https://gaoyuan.ink/2021/04/13/%E5%AE%9E%E7%8E%B0%E6%BB%9A%E5%8A%A8%E5%8A%A8%E7%94%BB%E2%80%94%E6%B8%90%E5%85%A5%E5%8A%A8%E7%94%BB/",
            "title": "实现滚动动画—渐入动画",
            "date_published": "2021-04-13T14:00:20.000Z",
            "content_html": "<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>Vue 和 React 版本其实区别不大，，，主要使用原生 js 就能实现，性能上就没考虑太多（可以在完成需求后，移除进入视区后的元素的类名，如：slide-item，lazy-img 等）</p>\n<h2 id=\"一-滚动动画vue-版本\"><a class=\"markdownIt-Anchor\" href=\"#一-滚动动画vue-版本\">#</a> 一、滚动动画：Vue 版本</h2>\n<h3 id=\"给-html-元素添加-class\"><a class=\"markdownIt-Anchor\" href=\"#给-html-元素添加-class\">#</a> 给 HTML 元素添加 class</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;slide-item&quot;&gt;需要根据滚动条位置显示的元素&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;slide-item slide-delay&quot; data-delay=&quot;200&quot;&gt;有延迟的元素&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h3 id=\"css-和动画\"><a class=\"markdownIt-Anchor\" href=\"#css-和动画\">#</a> css 和动画</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.slide-item &#123; opacity: 0; &#125;</span><br><span class=\"line\">.slide-up,</span><br><span class=\"line\">.slide-up-200,</span><br><span class=\"line\">.slide-up-400,</span><br><span class=\"line\">.slide-up-600,</span><br><span class=\"line\">.slide-up-800 &#123;</span><br><span class=\"line\">    animation: slide-up .5s forwards;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.slide-up-200 &#123; animation-delay: .2s; &#125;</span><br><span class=\"line\">.slide-up-400 &#123; animation-delay: .4s;&#125;</span><br><span class=\"line\">.slide-up-600 &#123; animation-delay: .6s;&#125;</span><br><span class=\"line\">.slide-up-800 &#123; animation-delay: .8s; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes slide-up &#123;</span><br><span class=\"line\">    from &#123; opacity: 0; transform: translateY(50%); &#125;</span><br><span class=\"line\">    to &#123; opacity: 1; transform: translateY(0); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"监听滚动\"><a class=\"markdownIt-Anchor\" href=\"#监听滚动\">#</a> 监听滚动</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">  window.addEventListener(&quot;scroll&quot;, this.onScroll);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeDestroy() &#123;</span><br><span class=\"line\">  window.removeEventListener(&quot;scroll&quot;, this.onScroll);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动方法\"><a class=\"markdownIt-Anchor\" href=\"#滚动方法\">#</a> 滚动方法</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 监听滚动</span><br><span class=\"line\">onScroll() &#123;</span><br><span class=\"line\">  const slideItems = document.querySelectorAll(&#x27;.slide-item&#x27;);</span><br><span class=\"line\">  // 上滑</span><br><span class=\"line\">  slideItems.forEach(item =&gt; &#123;</span><br><span class=\"line\">    let itemBCR = item.getBoundingClientRect();</span><br><span class=\"line\">    // 进入视区或在视区之上</span><br><span class=\"line\">    if (itemBCR.top &lt;= window.innerHeight + 10) &#123;</span><br><span class=\"line\">      if (Array.from(item.classList).includes(&#x27;slide-delay&#x27;)) &#123;</span><br><span class=\"line\">        item.classList.add(`slide-up-$&#123;item.dataset.delay&#125;`);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        item.classList.add(&#x27;slide-up&#x27;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 可以在这里 remove 掉 slide-item 这个类名，优化性能</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 这里主要用来多次显示效果的，上面 remove 掉 slide-item 后将不再起作用</span><br><span class=\"line\">      if (Array.from(item.classList).includes(&#x27;slide-delay&#x27;)) &#123;</span><br><span class=\"line\">        item.classList.remove(`slide-up-$&#123;item.dataset.delay&#125;`);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        item.classList.remove(&#x27;slide-up&#x27;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"二-滚动动画react-版本\"><a class=\"markdownIt-Anchor\" href=\"#二-滚动动画react-版本\">#</a> 二、滚动动画：React 版本</h2>\n<p>主要使用 hooks</p>\n<h3 id=\"给-html-元素添加-class-2\"><a class=\"markdownIt-Anchor\" href=\"#给-html-元素添加-class-2\">#</a> 给 HTML 元素添加 class</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span className=&#123;`slide-item`&#125;&gt;需要根据滚动条位置显示的元素&lt;/span&gt;</span><br><span class=\"line\">&lt;span className=&#123;`slide-item slide-delay`&#125; data-delay=&quot;200&quot;&gt;有延迟的元素&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"css-和动画-2\"><a class=\"markdownIt-Anchor\" href=\"#css-和动画-2\">#</a> css 和动画</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.slide-item &#123; opacity: 0; &#125;</span><br><span class=\"line\">.slide-up,</span><br><span class=\"line\">.slide-up-200,</span><br><span class=\"line\">.slide-up-400,</span><br><span class=\"line\">.slide-up-600,</span><br><span class=\"line\">.slide-up-800 &#123;</span><br><span class=\"line\">    animation: slide-up .5s forwards;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.slide-up-200 &#123; animation-delay: .2s; &#125;</span><br><span class=\"line\">.slide-up-400 &#123; animation-delay: .4s;&#125;</span><br><span class=\"line\">.slide-up-600 &#123; animation-delay: .6s;&#125;</span><br><span class=\"line\">.slide-up-800 &#123; animation-delay: .8s; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes slide-up &#123;</span><br><span class=\"line\">    from &#123; opacity: 0; transform: translateY(50%); &#125;</span><br><span class=\"line\">    to &#123; opacity: 1; transform: translateY(0); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"监听滚动-2\"><a class=\"markdownIt-Anchor\" href=\"#监听滚动-2\">#</a> 监听滚动</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  onScroll();</span><br><span class=\"line\">  window.addEventListener(&#x27;scroll&#x27;, onScroll);</span><br><span class=\"line\"></span><br><span class=\"line\">  return () =&gt; &#123;</span><br><span class=\"line\">    window.removeEventListener(&#x27;scroll&#x27;, onScroll);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, []);</span><br></pre></td></tr></table></figure>\n<h3 id=\"滚动方法-2\"><a class=\"markdownIt-Anchor\" href=\"#滚动方法-2\">#</a> 滚动方法</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 监听滚动</span><br><span class=\"line\">function onScroll(): void &#123;</span><br><span class=\"line\">  const slideItems = document.querySelectorAll(&#x27;.slide-item&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">  slideItems.forEach((item: any) =&gt; &#123;</span><br><span class=\"line\">    let slideBCR = item.getBoundingClientRect();</span><br><span class=\"line\">    // 进入视区或在视区之上</span><br><span class=\"line\">    if (slideBCR.top &lt;= window.innerHeight + 10) &#123;</span><br><span class=\"line\">      if (Array.from(item.classList).includes(&#x27;slide-delay&#x27;)) &#123; // 延迟</span><br><span class=\"line\">        item.classList.add(`slide-up-$&#123;item.dataset.delay&#125;`);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        item.classList.add(&#x27;slide-up&#x27;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 可以在这里 remove 掉 slide-item 这个类名，优化性能</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 这里主要用来多次显示效果的，上面 remove 掉 slide-item 后将不再起作用</span><br><span class=\"line\">      if (Array.from(item.classList).includes(&#x27;slide-delay&#x27;)) &#123; // 延迟</span><br><span class=\"line\">        item.classList.remove(`slide-up-$&#123;item.dataset.delay&#125;`);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        item.classList.remove(&#x27;slide-up&#x27;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "react",
                "vue",
                "react"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/03/31/JavaScript%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/",
            "url": "https://gaoyuan.ink/2021/03/31/JavaScript%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/",
            "title": "JavaScript专题（一）变量与函数提升",
            "date_published": "2021-03-31T03:13:22.000Z",
            "content_html": "<h2 id=\"一-有趣的现象\"><a class=\"markdownIt-Anchor\" href=\"#一-有趣的现象\">#</a> 一、有趣的现象</h2>\n<p>按照大家的常识，JavaScript 代码在执行是一定是自上而下的，你需要输出一个字符串，当然需要提前声明一个 <code>保存string类型的变量</code> 。如果深奥的道理我都能懂，于是我阅读了下面的代码。</p>\n<h3 id=\"11-我以为的开局\"><a class=\"markdownIt-Anchor\" href=\"#11-我以为的开局\">#</a> 1.1 我以为的开局</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;123&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n<p>我们调换一下代码的位置在再看：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p><strong>我好像找到规律了！！！</strong></p>\n<p>当我看完了前两段代码并且进行了 “深度思考” 后，我好像找到规律了，那就是：在当前代码块后函数中，在变量声明和初始化 <code>之前</code> 使用变量，会拿不到正确的值。</p>\n<h3 id=\"12-实际上是这样的\"><a class=\"markdownIt-Anchor\" href=\"#12-实际上是这样的\">#</a> 1.2 实际上是这样的</h3>\n<p>带着上面的 “结论” 我来到了这里</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> val = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val); <span class=\"comment\">// 高原</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>果然如此！，在<strong>变量声明和初始化之后</strong>耶稣也阻挡不了我拿到 val 的值，我说的！！！</p>\n<p>当我看到下面一段代码时，我已经产生了动摇，此事必要蹊跷。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> val = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> val = <span class=\"string\">&#x27;测试&#x27;</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这… 我怂了，是什么原因导致这样的现象发生的呢？Js 又是如果处理的呢？</p>\n<h2 id=\"二-js的预解析\"><a class=\"markdownIt-Anchor\" href=\"#二-js的预解析\">#</a> 二、Js 的预解析</h2>\n<p>在当前的作用域内，无论在哪里变量声明，在幕后，都会进行一次看不见的移动。</p>\n<p>注意：<strong>仅声明被 “移动”</strong>。即声明和赋值在某些时候被动分开了。而这次看不见的移动实际上就是 <code>Js在编译阶段的解析</code> 。</p>\n<p>来看一段《你知不知道的 Js》中经典的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = <span class=\"string\">&#x27;高原&#x27;</span>; <span class=\"comment\">// 未添加关键字（未声明），name为全局变量，，即window.name = &#x27;高原&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name; <span class=\"comment\">// 再次声明name，此时name未进行初始化，它的值是undefined吗？</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// ？</span></span><br></pre></td></tr></table></figure>\n<p>结果是成功打印 “高原”，这样<strong>看不见的移动</strong>就发生在 Js 预解析（编译）之中。</p>\n<h3 id=\"21-核心预解析\"><a class=\"markdownIt-Anchor\" href=\"#21-核心预解析\">#</a> 2.1 核心：预解析</h3>\n<p>为了搞明白这个核心问题，我们需要回顾一下，引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。</p>\n<p>因此，发生这样的事情，包括 <code>变量</code> 和 <code>函数</code> 在内的所有声明都会在任何代码被执行前首先被处理。当你看到 <code>var a = 2</code> ；时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明：var a；和 a = 2;。</p>\n<ul>\n<li>第一个定义声明是在编译阶段进行的。</li>\n<li>第二个赋值声明会被留在原地等待执行阶段。</li>\n</ul>\n<p>即代码是这样写的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们看到的代码：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>但 Js 会将它解析成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明(Declaration)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name; <span class=\"comment\">// 声明但未初始化，所以分配 undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化(Initialization)</span></span><br><span class=\"line\">name = <span class=\"string\">&#x27;高原&#x27;</span>; <span class=\"comment\">// 初始化（赋值）</span></span><br></pre></td></tr></table></figure>\n<p>所以本小结的一段代码应该这样分析：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name; <span class=\"comment\">// 声明name提到作用域顶部，并被分配了一个undefined</span></span><br><span class=\"line\">name = <span class=\"string\">&#x27;高原&#x27;</span>; <span class=\"comment\">// 进行初始化操作</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// &#x27;高原&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"22-注意只有声明被提升了\"><a class=\"markdownIt-Anchor\" href=\"#22-注意只有声明被提升了\">#</a> 2.2 注意：只有声明被提升了</h3>\n<p><strong>只有声明会被提升，而赋值和其他代码逻辑会在执行到代码的位置时才会生效</strong>。所以会有下面的问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数被提升了，自然可以正常执行，但变量仅仅是声明被提升了。</p>\n<h3 id=\"23-每个作用域都会进行提升操作\"><a class=\"markdownIt-Anchor\" href=\"#23-每个作用域都会进行提升操作\">#</a> 2.3 每个作用域都会进行提升操作</h3>\n<p>还是上面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际它在编译时是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name; <span class=\"comment\">// 声明</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;高原&#x27;</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 函数执行</span></span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200716134005198.jpg\" alt=\"img\"></p>\n<h2 id=\"三-提升之间的优先级\"><a class=\"markdownIt-Anchor\" href=\"#三-提升之间的优先级\">#</a> 三、提升之间的优先级</h2>\n<p>既然我们知道了 <code>变量</code> 和 <code>函数</code> 会被提升，他们之间又是如何判断优先级的呢？</p>\n<h3 id=\"31-函数会被首先提升然后才是变量\"><a class=\"markdownIt-Anchor\" href=\"#31-函数会被首先提升然后才是变量\">#</a> 3.1 函数会被首先提升，然后才是变量</h3>\n<p>我们分析下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;高原&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;小李&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本着函数优先提升的原则，他会被解析成这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;高原&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 高原</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;小李&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意， <code>var foo</code>  因为是一个重复声明，且优先级 <code>低于函数声明</code> 所以它被忽略掉了。</p>\n<h3 id=\"32-函数字面量不会进行函数提升\"><a class=\"markdownIt-Anchor\" href=\"#32-函数字面量不会进行函数提升\">#</a> 3.2 函数字面量不会进行函数提升</h3>\n<p>最直观的例子，就是在函数字面量前调用该函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// TypeError: foo is not a function</span></span><br></pre></td></tr></table></figure>\n<p>这段程序中：</p>\n<ol>\n<li>变量标识符 <code>foo()</code>  被提升并分配给所在作用域（在这里是全局作用域），因此 foo ()<strong> 不会导致 ReferenceError</strong>。</li>\n<li>然后就是执行 foo，foo 此时并没有赋值（注意变量被提升了）。由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。</li>\n</ol>\n<h2 id=\"四-es6和小结\"><a class=\"markdownIt-Anchor\" href=\"#四-es6和小结\">#</a> 四、ES6 和小结</h2>\n<p>ES6 新增了两个命令 <code>let</code>  和 <code>const</code> ，用来声明变量，有关它们完整的概念我会在《ES6 基础系列》中总结，提起它们，是因为<strong>变量提升在它们身上不会存在</strong>。</p>\n<h3 id=\"41-变量提升是可以规避的\"><a class=\"markdownIt-Anchor\" href=\"#41-变量提升是可以规避的\">#</a> 4.1 变量提升是可以规避的</h3>\n<p>let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，变量 foo 用 var 命令声明，会发生变量提升，即脚本开始运行时，变量 foo 已经存在了，但是没有值，所以会输出 undefined。变量 bar 用 let 命令声明，不会发生变量提升。这表示在声明它之前，变量 bar 是不存在的，这时如果用到它，就会抛出一个错误。</p>\n<p>在变量提升上，const 和 let 一样，只在声明所在的块级作用域内有效，也不会变量提升</p>\n<h3 id=\"42-小结\"><a class=\"markdownIt-Anchor\" href=\"#42-小结\">#</a> 4.2 小结</h3>\n<ol>\n<li>变量提升：函数声明和变量声明总是会被解释器悄悄地被 &quot;提升&quot; 到方法体的最顶部，但变量的初始化不会提升；</li>\n<li>函数提升：函数声明可以被看作是函数的整体被提升到了代码的顶部，但函数字面量表达式并不会引发函数提升；</li>\n<li>函数提升优先与变量提升；</li>\n<li>let 和 const 可以有效的规避变量提升</li>\n</ol>\n<p>最后提炼一下《你不知道的 JS》中的一段话：<strong>JavaScript 引擎并不总是按照代码的顺序来进行解析。在编译阶段，无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理，这个过程被称为提升。声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</strong></p>\n",
            "tags": [
                "JavaScript专题",
                "javascript"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/03/29/vue%E9%87%8C%E5%B0%81%E8%A3%85axios%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8promise%E6%97%A0%E7%97%9B%E5%88%B7%E6%96%B0token/",
            "url": "https://gaoyuan.ink/2021/03/29/vue%E9%87%8C%E5%B0%81%E8%A3%85axios%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8promise%E6%97%A0%E7%97%9B%E5%88%B7%E6%96%B0token/",
            "title": "vue里封装axios——利用promise无痛刷新token",
            "date_published": "2021-03-29T12:09:53.000Z",
            "content_html": "<h2 id=\"需求\"><a class=\"markdownIt-Anchor\" href=\"#需求\">#</a> 需求</h2>\n<p>最近遇到个需求：前端登录后，后端返回 <code>token</code>  和 <code>token有效时间</code> ，当 token 过期时要求用旧 token 去获取新的 token，前端需要做到无痛刷新 <code>token</code> ，即请求刷新 token 时要做到用户无感知。</p>\n<h2 id=\"需求解析\"><a class=\"markdownIt-Anchor\" href=\"#需求解析\">#</a> 需求解析</h2>\n<p>当用户发起一个请求时，判断 token 是否已过期，若已过期则先调 <code>refreshToken</code>  接口，拿到新的 token 后再继续执行之前的请求。</p>\n<p>这个问题的难点在于：当同时发起多个请求，而刷新 token 的接口还没返回，此时其他请求该如何处理？接下来会循序渐进地分享一下整个过程。</p>\n<span id=\"more\"></span>\n<h2 id=\"实现思路\"><a class=\"markdownIt-Anchor\" href=\"#实现思路\">#</a> 实现思路</h2>\n<p>由于后端返回了 token 的有效时间，可以有两种方法：</p>\n<h3 id=\"方法一\"><a class=\"markdownIt-Anchor\" href=\"#方法一\">#</a> 方法一：</h3>\n<p>在请求发起前拦截每个请求，判断 token 的有效时间是否已经过期，若已过期，则将请求挂起，先刷新 token 后再继续请求。</p>\n<h3 id=\"方法二\"><a class=\"markdownIt-Anchor\" href=\"#方法二\">#</a> 方法二：</h3>\n<p>不在请求前拦截，而是拦截返回后的数据。先发起请求，接口返回过期后，先刷新 token，再进行一次重试。</p>\n<h3 id=\"两种方法对比\"><a class=\"markdownIt-Anchor\" href=\"#两种方法对比\">#</a> 两种方法对比</h3>\n<p>方法一</p>\n<ul>\n<li>优点： 在请求前拦截，能节省请求，省流量。</li>\n<li>缺点： 需要后端额外提供一个 token 过期时间的字段；使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败。</li>\n</ul>\n<blockquote>\n<p>PS：token 有效时间建议是时间段，类似缓存的 MaxAge，而不要是绝对时间。当服务器和本地时间不一致时，绝对时间会有问题。</p>\n</blockquote>\n<p>方法二</p>\n<ul>\n<li>优点：不需额外的 token 过期字段，不需判断时间。</li>\n<li>缺点： 会消耗多一次请求，耗流量。</li>\n</ul>\n<p>综上，方法一和二优缺点是互补的，方法一有校验失败的风险（本地时间被篡改时，当然一般没有用户闲的蛋疼去改本地时间的啦），方法二更简单粗暴，等知道服务器已经过期了再重试一次，只是会耗多一个请求。</p>\n<p>在这里博主选择了 <em>方法二</em>。</p>\n<h2 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\">#</a> 实现</h2>\n<p>这里会使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9z\"> axios</span> 来实现，方法一是请求前拦截，所以会使用 <code>axios.interceptors.request.use()</code>  这个方法；</p>\n<p>而方法二是请求后拦截，所以会使用 <code>axios.interceptors.response.use()</code>  方法。</p>\n<h3 id=\"封装axios基本骨架\"><a class=\"markdownIt-Anchor\" href=\"#封装axios基本骨架\">#</a> 封装 axios 基本骨架</h3>\n<p>首先说明一下，项目中的 token 是存在 <code>localStorage</code>  中的。 <code>request.js</code>  基本骨架:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &#x27;axios&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 从localStorage中获取token</span><br><span class=\"line\">function getLocalToken () &#123;</span><br><span class=\"line\">    const token = window.localStorage.getItem(&#x27;token&#x27;)</span><br><span class=\"line\">    return token</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</span><br><span class=\"line\">instance.setToken = (token) =&gt; &#123;</span><br><span class=\"line\">  instance.defaults.headers[&#x27;X-Token&#x27;] = token</span><br><span class=\"line\">  window.localStorage.setItem(&#x27;token&#x27;, token)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建一个axios实例</span><br><span class=\"line\">const instance = axios.create(&#123;</span><br><span class=\"line\">  baseURL: &#x27;/api&#x27;,</span><br><span class=\"line\">  timeout: 300000,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class=\"line\">    &#x27;X-Token&#x27;: getLocalToken() // headers塞token</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 拦截返回的数据</span><br><span class=\"line\">instance.interceptors.response.use(response =&gt; &#123;</span><br><span class=\"line\">  // 接下来会在这里进行token过期的逻辑处理</span><br><span class=\"line\">  return response</span><br><span class=\"line\">&#125;, error =&gt; &#123;</span><br><span class=\"line\">  return Promise.reject(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">export default instance</span><br></pre></td></tr></table></figure>\n<p>这个是项目中一般的 axios 实例的封装，创建实例时，将本地已有的 token 放进 header，然后 export 出去供调用。接下来就是如何拦截返回的数据啦。</p>\n<h3 id=\"instanceinterceptorsresponseuse拦截实现\"><a class=\"markdownIt-Anchor\" href=\"#instanceinterceptorsresponseuse拦截实现\">#</a> instance.interceptors.response.use 拦截实现</h3>\n<p>后端接口一般会有一个约定好的数据结构，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;code: 1234, message: &#x27;token过期&#x27;, data: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>如我这里，后端约定当 <code>code === 1234</code>  时表示 token 过期了，此时就要求刷新 token。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance.interceptors.response.use(response =&gt; &#123;</span><br><span class=\"line\">  const &#123; code &#125; = response.data</span><br><span class=\"line\">  if (code === 1234) &#123;</span><br><span class=\"line\">    // 说明token过期了,刷新token</span><br><span class=\"line\">    return refreshToken().then(res =&gt; &#123;</span><br><span class=\"line\">      // 刷新token成功，将最新的token更新到header中，同时保存在localStorage中</span><br><span class=\"line\">      const &#123; token &#125; = res.data</span><br><span class=\"line\">      instance.setToken(token)</span><br><span class=\"line\">      // 获取当前失败的请求</span><br><span class=\"line\">      const config = response.config</span><br><span class=\"line\">      // 重置一下配置</span><br><span class=\"line\">      config.headers[&#x27;X-Token&#x27;] = token</span><br><span class=\"line\">      config.baseURL = &#x27;&#x27; // url已经带上了/api，避免出现/api/api的情况</span><br><span class=\"line\">      // 重试当前请求并返回promise</span><br><span class=\"line\">      return instance(config)</span><br><span class=\"line\">    &#125;).catch(res =&gt; &#123;</span><br><span class=\"line\">      console.error(&#x27;refreshtoken error =&gt;&#x27;, res)</span><br><span class=\"line\">      //刷新token失败，神仙也救不了了，跳转到首页重新登录吧</span><br><span class=\"line\">      window.location.href = &#x27;/&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return response</span><br><span class=\"line\">&#125;, error =&gt; &#123;</span><br><span class=\"line\">  return Promise.reject(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">function refreshToken () &#123;</span><br><span class=\"line\">    // instance是当前request.js中已创建的axios实例</span><br><span class=\"line\">    return instance.post(&#x27;/refreshtoken&#x27;).then(res =&gt; res.data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要额外注意的是， <code>response.config</code>  就是原请求的配置，但这个是已经处理过了的， <code>config.url</code>  已经带上了 <code>baseUrl</code> ，因此重试时需要去掉，同时 token 也是旧的，需要刷新下。</p>\n<p>以上就基本做到了无痛刷新 token，当 token 正常时，正常返回，当 token 已过期，则 axios 内部进行一次刷新 token 和重试。对调用者来说，axios 内部的刷新 token 是一个黑盒，是无感知的，因此需求已经做到了。</p>\n<h2 id=\"问题和优化\"><a class=\"markdownIt-Anchor\" href=\"#问题和优化\">#</a> 问题和优化</h2>\n<p>上面的代码还是存在一些问题的，没有考虑到多次请求的问题，因此需要进一步优化。</p>\n<h3 id=\"如何防止多次刷新token\"><a class=\"markdownIt-Anchor\" href=\"#如何防止多次刷新token\">#</a> 如何防止多次刷新 token</h3>\n<p>如果 refreshToken 接口还没返回，此时再有一个过期的请求进来，上面的代码就会再一次执行 refreshToken，这就会导致多次执行刷新 token 的接口，因此需要防止这个问题。我们可以在 <code>request.js</code>  中用一个 <code>flag</code>  来标记当前是否正在刷新 token 的状态，如果正在刷新则不再调用刷新 token 的接口。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 是否正在刷新的标记</span><br><span class=\"line\">let isRefreshing = false</span><br><span class=\"line\">instance.interceptors.response.use(response =&gt; &#123;</span><br><span class=\"line\">  const &#123; code &#125; = response.data</span><br><span class=\"line\">  if (code === 1234) &#123;</span><br><span class=\"line\">    if (!isRefreshing) &#123;</span><br><span class=\"line\">      isRefreshing = true</span><br><span class=\"line\">      return refreshToken().then(res =&gt; &#123;</span><br><span class=\"line\">        const &#123; token &#125; = res.data</span><br><span class=\"line\">        instance.setToken(token)</span><br><span class=\"line\">        const config = response.config</span><br><span class=\"line\">        config.headers[&#x27;X-Token&#x27;] = token</span><br><span class=\"line\">        config.baseURL = &#x27;&#x27;</span><br><span class=\"line\">        return instance(config)</span><br><span class=\"line\">      &#125;).catch(res =&gt; &#123;</span><br><span class=\"line\">        console.error(&#x27;refreshtoken error =&gt;&#x27;, res)</span><br><span class=\"line\">        window.location.href = &#x27;/&#x27;</span><br><span class=\"line\">      &#125;).finally(() =&gt; &#123;</span><br><span class=\"line\">        isRefreshing = false</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return response</span><br><span class=\"line\">&#125;, error =&gt; &#123;</span><br><span class=\"line\">  return Promise.reject(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样子就可以避免在刷新 token 时再进入方法了。但是这种做法是相当于把其他失败的接口给舍弃了，假如同时发起两个请求，且几乎同时返回，第一个请求肯定是进入了 refreshToken 后再重试，而第二个请求则被丢弃了，仍是返回失败，所以接下来还得解决其他接口的重试问题。</p>\n<h3 id=\"同时发起两个或以上的请求时其他接口如何重试\"><a class=\"markdownIt-Anchor\" href=\"#同时发起两个或以上的请求时其他接口如何重试\">#</a> 同时发起两个或以上的请求时，其他接口如何重试</h3>\n<p>两个接口几乎同时发起和返回，第一个接口会进入刷新 token 后重试的流程，而第二个接口需要先存起来，然后等刷新 token 后再重试。同样，如果同时发起三个请求，此时需要缓存后两个接口，等刷新 token 后再重试。由于接口都是异步的，处理起来会有点麻烦。</p>\n<p>当第二个过期的请求进来，token 正在刷新，我们先将这个请求存到一个数组队列中，想办法让这个请求处于等待中，一直等到刷新 token 后再逐个重试清空请求队列。<br>\n那么如何做到让这个请求处于等待中呢？为了解决这个问题，我们得借助 <code>Promise</code> 。将请求存进队列中后，同时返回一个 <code>Promise</code> ，让这个 <code>Promise</code>  一直处于 <code>Pending</code>  状态（即不调用 resolve），此时这个请求就会一直等啊等，只要我们不执行 resolve，这个请求就会一直在等待。当刷新请求的接口返回来后，我们再调用 resolve，逐个重试。最终代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 是否正在刷新的标记</span><br><span class=\"line\">let isRefreshing = false</span><br><span class=\"line\">// 重试队列，每一项将是一个待执行的函数形式</span><br><span class=\"line\">let requests = []</span><br><span class=\"line\"></span><br><span class=\"line\">instance.interceptors.response.use(response =&gt; &#123;</span><br><span class=\"line\">  const &#123; code &#125; = response.data</span><br><span class=\"line\">  if (code === 1234) &#123;</span><br><span class=\"line\">    const config = response.config</span><br><span class=\"line\">    if (!isRefreshing) &#123;</span><br><span class=\"line\">      isRefreshing = true</span><br><span class=\"line\">      return refreshToken().then(res =&gt; &#123;</span><br><span class=\"line\">        const &#123; token &#125; = res.data</span><br><span class=\"line\">        instance.setToken(token)</span><br><span class=\"line\">        config.headers[&#x27;X-Token&#x27;] = token</span><br><span class=\"line\">        config.baseURL = &#x27;&#x27;</span><br><span class=\"line\">        // 已经刷新了token，将所有队列中的请求进行重试</span><br><span class=\"line\">        requests.forEach(cb =&gt; cb(token))</span><br><span class=\"line\">        // 重试完了别忘了清空这个队列（掘金评论区同学指点）</span><br><span class=\"line\">        requests = []</span><br><span class=\"line\">        return instance(config)</span><br><span class=\"line\">      &#125;).catch(res =&gt; &#123;</span><br><span class=\"line\">        console.error(&#x27;refreshtoken error =&gt;&#x27;, res)</span><br><span class=\"line\">        window.location.href = &#x27;/&#x27;</span><br><span class=\"line\">      &#125;).finally(() =&gt; &#123;</span><br><span class=\"line\">        isRefreshing = false</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 正在刷新token，返回一个未执行resolve的promise</span><br><span class=\"line\">      return new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">        // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span><br><span class=\"line\">        requests.push((token) =&gt; &#123;</span><br><span class=\"line\">          config.baseURL = &#x27;&#x27;</span><br><span class=\"line\">          config.headers[&#x27;X-Token&#x27;] = token</span><br><span class=\"line\">          resolve(instance(config))</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return response</span><br><span class=\"line\">&#125;, error =&gt; &#123;</span><br><span class=\"line\">  return Promise.reject(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这里可能比较难理解的是 <code>requests</code>  这个队列中保存的是一个函数，这是为了让 resolve 不执行，先存起来，等刷新 token 后更方便调用这个函数使得 resolve 执行。至此，问题应该都解决了。</p>\n<h2 id=\"最后完整代码\"><a class=\"markdownIt-Anchor\" href=\"#最后完整代码\">#</a> 最后完整代码</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &#x27;axios&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 从localStorage中获取token</span><br><span class=\"line\">function getLocalToken () &#123;</span><br><span class=\"line\">    const token = window.localStorage.getItem(&#x27;token&#x27;)</span><br><span class=\"line\">    return token</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</span><br><span class=\"line\">instance.setToken = (token) =&gt; &#123;</span><br><span class=\"line\">  instance.defaults.headers[&#x27;X-Token&#x27;] = token</span><br><span class=\"line\">  window.localStorage.setItem(&#x27;token&#x27;, token)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function refreshToken () &#123;</span><br><span class=\"line\">    // instance是当前request.js中已创建的axios实例</span><br><span class=\"line\">    return instance.post(&#x27;/refreshtoken&#x27;).then(res =&gt; res.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建一个axios实例</span><br><span class=\"line\">const instance = axios.create(&#123;</span><br><span class=\"line\">  baseURL: &#x27;/api&#x27;,</span><br><span class=\"line\">  timeout: 300000,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class=\"line\">    &#x27;X-Token&#x27;: getLocalToken() // headers塞token</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 是否正在刷新的标记</span><br><span class=\"line\">let isRefreshing = false</span><br><span class=\"line\">// 重试队列，每一项将是一个待执行的函数形式</span><br><span class=\"line\">let requests = []</span><br><span class=\"line\"></span><br><span class=\"line\">instance.interceptors.response.use(response =&gt; &#123;</span><br><span class=\"line\">  const &#123; code &#125; = response.data</span><br><span class=\"line\">  if (code === 1234) &#123;</span><br><span class=\"line\">    const config = response.config</span><br><span class=\"line\">    if (!isRefreshing) &#123;</span><br><span class=\"line\">      isRefreshing = true</span><br><span class=\"line\">      return refreshToken().then(res =&gt; &#123;</span><br><span class=\"line\">        const &#123; token &#125; = res.data</span><br><span class=\"line\">        instance.setToken(token)</span><br><span class=\"line\">        config.headers[&#x27;X-Token&#x27;] = token</span><br><span class=\"line\">        config.baseURL = &#x27;&#x27;</span><br><span class=\"line\">        // 已经刷新了token，将所有队列中的请求进行重试</span><br><span class=\"line\">        requests.forEach(cb =&gt; cb(token))</span><br><span class=\"line\">        requests = []</span><br><span class=\"line\">        return instance(config)</span><br><span class=\"line\">      &#125;).catch(res =&gt; &#123;</span><br><span class=\"line\">        console.error(&#x27;refreshtoken error =&gt;&#x27;, res)</span><br><span class=\"line\">        window.location.href = &#x27;/&#x27;</span><br><span class=\"line\">      &#125;).finally(() =&gt; &#123;</span><br><span class=\"line\">        isRefreshing = false</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 正在刷新token，将返回一个未执行resolve的promise</span><br><span class=\"line\">      return new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">        // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span><br><span class=\"line\">        requests.push((token) =&gt; &#123;</span><br><span class=\"line\">          config.baseURL = &#x27;&#x27;</span><br><span class=\"line\">          config.headers[&#x27;X-Token&#x27;] = token</span><br><span class=\"line\">          resolve(instance(config))</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return response</span><br><span class=\"line\">&#125;, error =&gt; &#123;</span><br><span class=\"line\">  return Promise.reject(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">export default instance</span><br></pre></td></tr></table></figure>\n<p>希望对大家有帮助。感谢看到最后<sup>_</sup>。</p>\n",
            "tags": [
                "Vue专题",
                "vue",
                "axios"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/03/26/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
            "url": "https://gaoyuan.ink/2021/03/26/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
            "title": "JavaScript基础（六）基本数据类型",
            "date_published": "2021-03-26T03:20:16.000Z",
            "content_html": "<h2 id=\"一-类型\"><a class=\"markdownIt-Anchor\" href=\"#一-类型\">#</a> 一、类型</h2>\n<p>可能许多习惯了 C++、C# 这类静态语言（强类型）语言的小伙伴们在编写 Js 代码时，会很不习惯，因为相对于静态语言来说，Js 甚至没有类型的” 概念 “。</p>\n<p>而且 Js 中吐槽较多的恰恰就包含类型转换，在我们日常写代码时总是遇到或显示或隐示的类型转换，比如：</p>\n<p>你要获取数字 <code>123</code>  的个位十位百位，你会怎么做？</p>\n<ul>\n<li>toSrting () 后通过下标获取？</li>\n<li>取整取余？</li>\n</ul>\n<p>使用类型转换形式多样。有些方式简明易懂，也很安全，然而稍不留神，就会出现意想不到的结果。</p>\n<p>为了学习和掌握类型转换，现在先让我们来深入了解一下值和类型。</p>\n<span id=\"more\"></span>\n<h3 id=\"内置类型\"><a class=\"markdownIt-Anchor\" href=\"#内置类型\">#</a> 内置类型</h3>\n<p>JavaScript 拥有<strong>动态类型</strong>，这意味着相同的变量可用作不同的类型：类型是值的内部特征，它定义了值的行为，以使其区别于其他值。</p>\n<p><strong>JavaScript 中的内置类型:</strong></p>\n<ul>\n<li>null</li>\n<li>undefined</li>\n<li>布尔值（boolean）</li>\n<li>数字（number）</li>\n<li>字符串（string）</li>\n<li>对象（Object）</li>\n<li>symbol（ES6 新增）</li>\n</ul>\n<p>对于 null 和 undefined 大家一定不陌生，我们会在第三节简单的分析他们之前的区别。</p>\n<h2 id=\"二-数据类型分类\"><a class=\"markdownIt-Anchor\" href=\"#二-数据类型分类\">#</a> 二、数据类型分类</h2>\n<p>除了<strong>对象</strong>，其他几个都是<strong>基本类型</strong>，这是因为声明变量时不同的内存分配而决定的：</p>\n<h3 id=\"21-基本类型\"><a class=\"markdownIt-Anchor\" href=\"#21-基本类型\">#</a> 2.1 基本类型</h3>\n<p>JavaScript 中共有 6 种基本数据类型： <code>Undefined</code> 、 <code>Null</code> 、 <code>Boolean</code> 、 <code>Number</code> 、 <code>String</code> 、 <code>Symbol</code> 。</p>\n<p><code>基本类型</code> 存储在 <code>栈（stack）中</code> ，也就是说：</p>\n<ul>\n<li>它们的值<strong>直接存储在变量访问的位置</strong>。</li>\n<li>这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 –  <code>栈</code> 中。</li>\n<li>这样存储便于迅速查寻变量的值。</li>\n<li>基本类型的值是按值访问的，且基本类型的值是不可变的。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;123hello321&quot;</span>;</span><br><span class=\"line\">str.toUpperCase();     <span class=\"comment\">// 123HELLO321</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str);      <span class=\"comment\">// 123hello321</span></span><br></pre></td></tr></table></figure>\n<p><strong>基本类型的比较是它们的值的比较：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a == b);    <span class=\"comment\">// == 只进行值的比较</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b);   <span class=\"comment\">// === 不仅进行值得比较，还要进行数据类型的比较</span></span><br></pre></td></tr></table></figure>\n<p>有关符号运算，优先级的问题，我觉得应该将它放在 Js 专题系列，单独讨论它们才能比较透彻，这里就不过多解释了。</p>\n<p>来看下面的代码，我们用图示来分析它</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a,b</span><br><span class=\"line\">a = <span class=\"number\">100</span>;</span><br><span class=\"line\">b = a;</span><br><span class=\"line\">a = <span class=\"string\">&#x27;字符串&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200707105321216.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"22-引用类型\"><a class=\"markdownIt-Anchor\" href=\"#22-引用类型\">#</a> 2.2 引用类型</h3>\n<p><code>引用类型</code> 存储在 <code>堆（heap）</code> 中的对象，也就是说:</p>\n<ul>\n<li>存储在变量处的值是一个指针（point），指向存储对象的内存地址。</li>\n<li>引用类型的值是按引用访问的，且引用类型的值是 <code>可变</code> 的。</li>\n<li>变量存储的是可以打开保存数据的房间的 <code>钥匙</code></li>\n<li><code>存储钥匙地址</code> 的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</li>\n</ul>\n<p>除过上面的 6 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，有：</p>\n<ul>\n<li>Object</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Function</li>\n<li>…</li>\n</ul>\n<p><strong>引用类型的比较是引用的比较：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;    <span class=\"comment\">// 新建一个空对象 obj1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;&#125;;    <span class=\"comment\">// 新建一个空对象 obj2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 == obj2);    <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 === obj2);   <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>因为 obj1 和 obj2 分别引用的是存放在堆内存中的 2 个不同的对象，故变量 obj1 和 obj2 的值（引用地址）也是不一样的！</p>\n<p>来看下面的代码，我们用图示来分析它</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;高原&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b;</span><br><span class=\"line\">b = a;</span><br><span class=\"line\">a.name = <span class=\"string\">&quot;gaoyuan&quot;</span>;</span><br><span class=\"line\">b.age = <span class=\"number\">23</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;高原&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">23</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200707114641540.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"23-小结\"><a class=\"markdownIt-Anchor\" href=\"#23-小结\">#</a> 2.3 小结</h3>\n<p><strong>基本类型</strong></p>\n<ul>\n<li>栈内存中包括了变量的标识符和变量的值</li>\n</ul>\n<p><strong>引用类型</strong></p>\n<ul>\n<li>栈内存中保存了变量标识符和指向堆内存中该对象的指针</li>\n<li>堆内存中保存了对象的内容</li>\n<li></li>\n</ul>\n<h2 id=\"三-常见问题\"><a class=\"markdownIt-Anchor\" href=\"#三-常见问题\">#</a> 三、常见问题</h2>\n<h3 id=\"31-javascript中的变量是没有类型的\"><a class=\"markdownIt-Anchor\" href=\"#31-javascript中的变量是没有类型的\">#</a> 3.1 JavaScript 中的变量是没有类型的</h3>\n<p>来看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>; <span class=\"comment\">// 严格地说 变量a没有类型，它所保存的 100是数字类型的</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a === <span class=\"string\">&#x27;number&#x27;</span>; <span class=\"comment\">// 其实检测是=&gt;typeof 100</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a === <span class=\"string\">&#x27;string&#x27;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>变量a</code>  可以随时持有任何类型的 <code>值</code> 。换个角度来理解就是，JavaScript 不做 “类型强制”；也就是说，语言引擎不要求变量总是持有与其初始值同类型的值。</p>\n<h3 id=\"32-typeof检测不总是对的\"><a class=\"markdownIt-Anchor\" href=\"#32-typeof检测不总是对的\">#</a> 3.2 typeof 检测不总是对的</h3>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200706185843137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>需要注意的点：</p>\n<p><strong>number</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本数学API和属性</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Math</span>.LN2 === <span class=\"string\">&#x27;number&#x27;</span>; <span class=\"comment\">// true  Math的属性</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">Infinity</span> === <span class=\"string\">&#x27;number&#x27;</span>; <span class=\"comment\">// true 无穷</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">NaN</span> === <span class=\"string\">&#x27;number&#x27;</span>; <span class=\"comment\">// true 特殊的数字类型，not a number</span></span><br><span class=\"line\"><span class=\"comment\">// 被强转称数字的其他数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Number</span>(<span class=\"string\">&#x27;str&#x27;</span>) === <span class=\"string\">&#x27;number&#x27;</span>; <span class=\"comment\">// Number(&#x27;str&#x27;) =&gt; NaN =&gt; number</span></span><br></pre></td></tr></table></figure>\n<p><strong>string</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> (<span class=\"keyword\">typeof</span> <span class=\"number\">1</span>) === <span class=\"string\">&#x27;string&#x27;</span>; <span class=\"comment\">// typeof always returns a string</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">String</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;string&#x27;</span>; <span class=\"comment\">// 强转成字符串</span></span><br></pre></td></tr></table></figure>\n<p><strong>布尔值</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;boolean&#x27;</span>; <span class=\"comment\">// 强制类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> !!(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;boolean&#x27;</span>; <span class=\"comment\">// two calls of the ! (logical NOT) operator are equivalent to Boolean()</span></span><br></pre></td></tr></table></figure>\n<p><strong>Symble</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span>() === <span class=\"string\">&#x27;symbol&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>) === <span class=\"string\">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><strong>undefined</strong></p>\n<p>一个没有被赋值的变量的数据类型是 <code>undefined</code>  (如果方法或者是语句中操作的变量没有被赋值，则会返回 undefined) —— MDN</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> === <span class=\"string\">&#x27;undefined&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>object</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;高原&#x27;</span> &#125; === <span class=\"string\">&#x27;object&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>null</strong></p>\n<p>值得我们注意恰恰是这个 <code>null</code> ,typeof 对它的处理返回的是 <code>object</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> === <span class=\"string\">&#x27;object&#x27;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>function</strong></p>\n<p>typeof 检测函数返回的也是 object，这是因为从规范上看 <code>function</code>  实际上是 <code>object</code>  的一个子类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Functions</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125; === <span class=\"string\">&#x27;function&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;&#125; === <span class=\"string\">&#x27;function&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>那么你还知道其他检测数据类型的方式吗？</p>\n<h3 id=\"33-null和undefined\"><a class=\"markdownIt-Anchor\" href=\"#33-null和undefined\">#</a> 3.3 null 和 undefined</h3>\n<ul>\n<li>\n<p>null：特指对象的值未设置。它是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 基本类型</span><br></pre></td></tr></table></figure>\n<p>之一。</p>\n<ul>\n<li>它不是全局对象的一个属性；</li>\n<li>在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。</li>\n</ul>\n</li>\n<li>\n<p>undefined：表示声明但未被赋值的变量类型</p>\n<ul>\n<li>你可以使用 <code>undefined</code>  和严格相等或不相等操作符来决定一个变量是否拥有值。</li>\n</ul>\n</li>\n</ul>\n<p><strong>他们的区别：</strong></p>\n<p>当检测 null 或 undefined 时，注意相等  <code>==</code>  与 <code>===</code>  两个操作符的区别 ，前者会执行类型转换：</p>\n<ul>\n<li>typeof 检测时两者的返回值不同</li>\n<li>代表的含义不同</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>        <span class=\"comment\">// &quot;object&quot; (因为一些以前的原因而不是&#x27;null&#x27;)</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>   <span class=\"comment\">// &quot;undefined&quot;</span></span><br><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span>  == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">!<span class=\"literal\">null</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"number\">1</span> + <span class=\"literal\">null</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"number\">1</span> + <span class=\"literal\">undefined</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>",
            "tags": [
                "JavaScript专题",
                "javascript"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/03/25/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E9%97%AD%E5%8C%85/",
            "url": "https://gaoyuan.ink/2021/03/25/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E9%97%AD%E5%8C%85/",
            "title": "JavaScript基础（五）闭包",
            "date_published": "2021-03-25T02:54:14.000Z",
            "content_html": "<h2 id=\"一-什么是闭包\"><a class=\"markdownIt-Anchor\" href=\"#一-什么是闭包\">#</a> 一、什么是闭包</h2>\n<p>顾名思义，遇见问题先问为什么是我们一贯的思维方式，我们尝试回答一下：</p>\n<ol>\n<li>闭包就是函数内部的子函数 ——  <code>等于没说</code></li>\n<li>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。—— <code>靠谱</code></li>\n<li>闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁 —— <code>靠谱</code></li>\n<li>函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）—— <code>很靠谱</code></li>\n</ol>\n<p>我们试着用代码来描述一下上面的回答，看看你最<strong>中意</strong>哪一个～</p>\n<span id=\"more\"></span>\n<h3 id=\"11-闭包是函数内部的子函数\"><a class=\"markdownIt-Anchor\" href=\"#11-闭包是函数内部的子函数\">#</a> 1.1 闭包是函数内部的子函数</h3>\n<p>先看这段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>基于词法作用域的查找规则， <code>bar函数</code> 可以成功的打印 <code>a</code>  变量，并且它也是 <code>foo</code>  的子函数，但严格来说它并没有清晰的表达出闭包这一概念，说它表达的是<strong>嵌套函数可以访问声明于大外部作用域的变量</strong>更准确一些。</p>\n<h3 id=\"12-闭包就是能够读取其他函数内部变量的函数在本质上是函数内部和函数外部链接的桥梁\"><a class=\"markdownIt-Anchor\" href=\"#12-闭包就是能够读取其他函数内部变量的函数在本质上是函数内部和函数外部链接的桥梁\">#</a> 1.2 闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁</h3>\n<p>再来看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = foo();</span><br><span class=\"line\">res(); <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>结果一致，这是因为此时 <code>res</code>  是执行 <code>foo</code>  函数时返回的 <code>bar</code>  引用，bar 函数得以保存了它饿词法环境。</p>\n<h3 id=\"13-函数和对其周围状态词法环境的引用捆绑在一起构成闭包closure\"><a class=\"markdownIt-Anchor\" href=\"#13-函数和对其周围状态词法环境的引用捆绑在一起构成闭包closure\">#</a> 1.3 函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）</h3>\n<p>我们来看下面代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// gaoyuan</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">//gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>foo 的上下文被静态的保存了下来，而且是在该函数创建的时候就保存了。下面我们来验证一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// gaoyuan</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;老王&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    func()</span><br><span class=\"line\">&#125;)(foo); <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>这里我们就可以理解 —— 函数被创建后就形成了闭包，他们保存了上层上下文的作用域链，并且保存在 <code>[[scope]]</code>  中，如果你对 <code>[[scope]]</code>  的概念已经模糊了，不妨花几分钟看看《JavaScript 中的执行上下文》这篇文章。</p>\n<h3 id=\"14-总结\"><a class=\"markdownIt-Anchor\" href=\"#14-总结\">#</a> 1.4 总结</h3>\n<p><strong>注意：闭包是函数内部的返回的子函数这句话本身没错</strong>，但要看从什么角度出发：</p>\n<p>ECMAScript 中，闭包指的是：</p>\n<ol>\n<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>\n<li>从实践角度：以下函数才算是闭包：\n<ul>\n<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>\n<li>在代码中引用了自由变量</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结：</strong></p>\n<ul>\n<li>闭包代码块创建该代码块的上下文中数据的结合</li>\n<li>闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁</li>\n<li>不同的角度对闭包的解释不同的</li>\n</ul>\n<p>注意：这些并不是闭包的全部，就好像当你被问到 —— 闭包是什么的时候，你的上述回答并不能结束这个话题，往往会引申出更多的话题。</p>\n<h2 id=\"二-尝试分析闭包\"><a class=\"markdownIt-Anchor\" href=\"#二-尝试分析闭包\">#</a> 二、尝试分析闭包</h2>\n<p>还是那段经典代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;global scope&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;local scope&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = checkscope();</span><br><span class=\"line\">foo(); <span class=\"comment\">// local scope</span></span><br></pre></td></tr></table></figure>\n<p>首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p>\n<ol>\n<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li>\n<li>全局执行上下文初始化</li>\n<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li>\n<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this 等</li>\n<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>\n<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li>\n<li>f 执行上下文初始化，创建变量对象、作用域链、this 等</li>\n<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>\n</ol>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200628152924827.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>当  <code>f</code>  函数执行的时候， <code>checkscope</code>  函数上下文已经被销毁了啊 (即从执行上下文栈中被弹出)，怎么还会读取到  <code>checkscope</code>  作用域下的  <code>scope</code>  值呢？</p>\n<p>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：</p>\n<p>因为这个作用域链：</p>\n<ul>\n<li><code>f 函数</code> 依然可以读取到  <code>checkscopeContext.AO</code>  的值；</li>\n<li>当  <code>f 函数</code> 引用了  <code>checkscopeContext.AO</code>  中的值的时候，即使  <code>checkscopeContext</code>  被销毁了，JavaScript 依然会让  <code>checkscopeContext.AO</code>  活在内存中；</li>\n<li><code>f 函数</code> 依然可以通过  <code>f 函数</code> 的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</li>\n</ul>\n<p>多么浪漫的思想 —— 只要你需要我，那我我本应该被销毁，你也能找到我～</p>\n<h2 id=\"三-经典问题\"><a class=\"markdownIt-Anchor\" href=\"#三-经典问题\">#</a> 三、经典问题</h2>\n<h3 id=\"31-多个对象引用同一个scope你遇到过吗\"><a class=\"markdownIt-Anchor\" href=\"#31-多个对象引用同一个scope你遇到过吗\">#</a> 3.1 多个对象引用同一个 [[Scope]]，你遇到过吗？</h3>\n<p>直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> child1;</span><br><span class=\"line\"><span class=\"keyword\">var</span> child2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    child1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(++x)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    child2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(--x)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">parent();</span><br><span class=\"line\">child1(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">child1(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">child2(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>大家可能不理解， <code>child1</code>  和 <code>child</code>  他们两个函数在创建后都保存了上层上下文，万万没想到，<strong>同一个上下文创建的闭包是共用一个 <code>[[scope]]</code>  属性的</strong>，某个闭包对其中 [[Scope]] 的变量做修改会影响到其他闭包对其变量的读取。</p>\n<h3 id=\"32-闭包轻松解决的经典问题\"><a class=\"markdownIt-Anchor\" href=\"#32-闭包轻松解决的经典问题\">#</a> 3.2 闭包轻松解决的经典问题</h3>\n<p>大家一定对下面这段代码很眼熟：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">    arr[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr[<span class=\"number\">0</span>](); <span class=\"comment\">// 10</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>](); <span class=\"comment\">// 10</span></span><br><span class=\"line\">arr[<span class=\"number\">2</span>](); <span class=\"comment\">// 10</span></span><br><span class=\"line\">arr[<span class=\"number\">3</span>](); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<p>我们这么解释它：<strong>同一个上下文中创建的闭包是共用一个 [[Scope]] 属性的</strong>。</p>\n<p>因此上层上下文中的变量 <code>i</code>  是可以很容易就被改变的。</p>\n<p>arr [0],arr [1]…arr [9] 他们共用一个 [[scope]]，最终执行的时候结果当然一样。</p>\n<p><strong>如何利用闭包来解决这个问题呢？</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">    arr[i] = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr[<span class=\"number\">0</span>](); <span class=\"comment\">// 0</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>](); <span class=\"comment\">// 1</span></span><br><span class=\"line\">arr[<span class=\"number\">2</span>](); <span class=\"comment\">// 2</span></span><br><span class=\"line\">arr[<span class=\"number\">3</span>](); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>我们通过立即执行匿名函数的方式隔离了作用域，当执行 arr [0] 函数的时候，arr [0] 函数的作用域链发生了改变：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr[<span class=\"number\">0</span>]Context = &#123;</span><br><span class=\"line\">    <span class=\"attr\">Scope</span>: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>匿名函数执行上下文的 AO 为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">匿名函数Context = &#123;</span><br><span class=\"line\">    <span class=\"attr\">AO</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">arguments</span>: &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"attr\">length</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">i</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到，这时函数的 <code>[[Scope]]</code>  属性就有了真正想要的值了，为了达到这样的目的，我们不得不在 <code>[[Scope]]</code>  中创建额外的变量对象。要注意的是，在返回的函数中，如果要获取 <code>i</code>  的值，那么该值还是会是 10。</p>\n<h3 id=\"33-总结\"><a class=\"markdownIt-Anchor\" href=\"#33-总结\">#</a> 3.3 总结</h3>\n<ul>\n<li>函数内的所有内部函数都共享一个父作用域，因此创建的闭包是共用的。</li>\n<li>利用闭包隔离作用域的特性可以解决共享作用域的问题</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=1200653736,2067630829&amp;fm=26&amp;gp=0.jpeg\" alt=\"\"></p>\n",
            "tags": [
                "JavaScript专题",
                "javascript"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/03/24/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/",
            "url": "https://gaoyuan.ink/2021/03/24/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/",
            "title": "JavaScript基础（四）立即调用函数",
            "date_published": "2021-03-24T01:37:26.000Z",
            "content_html": "<blockquote>\n<p>本篇文章，主要讲解的立即执行函数或自执行匿名函数的含义、用法、以及使用它的主要场景。系列的前面几篇文章主要讲解了作用域、原型，本篇文章一样起到了承上启下的作用，如果您感兴趣，不妨去看看哦～</p>\n</blockquote>\n<h2 id=\"一-了解立即调用函数表达式\"><a class=\"markdownIt-Anchor\" href=\"#一-了解立即调用函数表达式\">#</a> 一、了解立即调用函数表达式</h2>\n<h3 id=\"11-思维导图\"><a class=\"markdownIt-Anchor\" href=\"#11-思维导图\">#</a> 1.1 思维导图</h3>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200622113604893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<span id=\"more\"></span>\n<h3 id=\"12-什么是立即调用\"><a class=\"markdownIt-Anchor\" href=\"#12-什么是立即调用\">#</a> 1.2 什么是立即调用？</h3>\n<p>在详细了解这个之前，我们来谈了解一下 “自执行” 这个叫法，本文对这个功能的叫法也不一定完全对，每个人对他的理解都不一样，我们在这里用 <code>立即调用</code> ～</p>\n<p>立即调用：</p>\n<ul>\n<li>顾名思义，该表达式一被 <code>创建就立即执行</code> 。</li>\n<li>是一个在定义时就会立即执行的  <code>JavaScript 函数</code> 。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;x + x = &#x27;</span>, x + x);</span><br><span class=\"line\">&#125;)(<span class=\"number\">5</span>) <span class=\"comment\">// x + x = 10</span></span><br></pre></td></tr></table></figure>\n<p>这是一个被称为  <code>自执行匿名函数</code>  的设计模式，主要包含两部分:</p>\n<ol>\n<li>第一部分是包围在 圆括号运算符  <code>()</code>  里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</li>\n<li>第二部分再一次使用  <code>()</code>  创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</li>\n</ol>\n<h3 id=\"13-核心问题\"><a class=\"markdownIt-Anchor\" href=\"#13-核心问题\">#</a> 1.3 核心问题</h3>\n<p><strong>当你声明一个函数的时候，通过在后面加括号就可以实现立即执行吗？</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;(); <span class=\"comment\">// gaoyuan 成功了！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...是不是意味着后面加个括弧都可以自动执行？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;&#x27;</span>gaoyuan);</span><br><span class=\"line\">&#125;(); <span class=\"comment\">// Uncaught SyntaxError: Function statements require a function name</span></span><br><span class=\"line\"><span class=\"comment\">// 什么？还需要一个函数名？不是叫 自执行匿名函数吗？</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我加上了函数名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;(); <span class=\"comment\">// Uncaught SyntaxError: Unexpected token &#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>很显然，例子中的第二条和第三条确实报错了，而且报错内容不一样，那么问题出现在哪呢？</p>\n<h2 id=\"二-立即调用函数表达式报错了\"><a class=\"markdownIt-Anchor\" href=\"#二-立即调用函数表达式报错了\">#</a> 二、立即调用函数表达式报错了？</h2>\n<p>有时，我们定义函数之后，立即调用该函数，这时不能在函数的定义后面直接加圆括号，这会产生语法错误。产生语法错误的原因是， <code>function</code>  这个关键字，既可以当做语句，也可以当做表达式，比如下边：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语句</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了避免解析上的歧义，JS 引擎规定，如果 function 出现在行首，一律解析成语句。因此 JS 引擎看到行首是 function 关键字以后，认为这一段都是函数定义，不应该以 <code>括号结尾</code> ，在它看来 <code>括号</code> 只是分组操作符。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面这个function在语法上是没问题的，但是依然只是一个语句</span></span><br><span class=\"line\"><span class=\"comment\">// 加上括号()以后依然会报错，因为分组操作符需要包含表达式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">/* code */</span> &#125;(); <span class=\"comment\">// SyntaxError: Unexpected token )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是如果你在括弧()里传入一个表达式，将不会有异常抛出</span></span><br><span class=\"line\"><span class=\"comment\">// 但是foo函数依然不会执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">/* code */</span> &#125;( <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">/* code */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">( <span class=\"number\">1</span> );</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-使用立即调用函数的正确姿势\"><a class=\"markdownIt-Anchor\" href=\"#三-使用立即调用函数的正确姿势\">#</a> 三、使用立即调用函数的正确姿势</h2>\n<p>要解决上述问题，非常简单。</p>\n<p>我们只需要用 <code>大括弧</code> 将代码的代码全部括住就行了，因为 JavaScript 里 <code>括弧()</code>  里面不能包含语句，所以在这一点上，解析器在解析 function 关键字的时候，会将相应的代码解析成 function 表达式，而不是 function 声明。</p>\n<h3 id=\"31-常见使用姿势\"><a class=\"markdownIt-Anchor\" href=\"#31-常见使用姿势\">#</a> 3.1 常见使用姿势</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面2个括弧()都会立即执行</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* code */</span> &#125; ()); <span class=\"comment\">// 推荐使用这个</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* code */</span> &#125;)(); <span class=\"comment\">// 但是这个也是可以用的</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"32-不常见的使用姿势一\"><a class=\"markdownIt-Anchor\" href=\"#32-不常见的使用姿势一\">#</a> 3.2 不常见的使用姿势（一）</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的</span></span><br><span class=\"line\"><span class=\"comment\">// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>)</span><br><span class=\"line\">&#125;(); <span class=\"comment\">// gaoyuan</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>)</span><br><span class=\"line\">&#125;(); <span class=\"comment\">// gaoyuan</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>) &#125;(); <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"33-不常见的使用姿势二\"><a class=\"markdownIt-Anchor\" href=\"#33-不常见的使用姿势二\">#</a> 3.3 不常见的使用姿势（二）</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果你不在意返回值，或者不怕难以阅读</span></span><br><span class=\"line\"><span class=\"comment\">// 你甚至可以在function前面加一元操作符号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//转bool</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res1 = !<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;res1:&#x27;</span>, res1); <span class=\"comment\">// gaoyuan true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转数字</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res2 = +<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;res2:&#x27;</span>, res2); <span class=\"comment\">// gaoyuan NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按位非</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res3 = ～<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;res3:&#x27;</span>, res3); <span class=\"comment\">// gaoyuan NaN</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"34-不常见的使用姿势三\"><a class=\"markdownIt-Anchor\" href=\"#34-不常见的使用姿势三\">#</a> 3.4 不常见的使用姿势（三）</h3>\n<p>还有一个情况，使用 new 和 void 关键字，不过不太常见罢了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;();</span><br></pre></td></tr></table></figure>\n<h2 id=\"四-常见使用场景\"><a class=\"markdownIt-Anchor\" href=\"#四-常见使用场景\">#</a> 四、常见使用场景</h2>\n<h3 id=\"41-隔离作用域\"><a class=\"markdownIt-Anchor\" href=\"#41-隔离作用域\">#</a> 4.1 隔离作用域</h3>\n<p>IIFE 最常见的功能，就是隔离作用域，在 ES6 之前 JS 原生也没有块级作用域的概念，所以需要函数作用域来模拟。</p>\n<p>举例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currentTime = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> year  = time.getFullYear()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> month = time.getMonth()+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> date  = time.getDate();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hour  = time.getHours();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> min   = time.getMinutes();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> year + <span class=\"string\">&#x27;-&#x27;</span> + month + <span class=\"string\">&#x27;-&#x27;</span> + date + <span class=\"string\">&#x27; &#x27;</span> + hour + <span class=\"string\">&#x27;:&#x27;</span> + min;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>你仍然可以在其他地方声明同名变量～</p>\n<h3 id=\"42-惰性函数\"><a class=\"markdownIt-Anchor\" href=\"#42-惰性函数\">#</a> 4.2 惰性函数</h3>\n<p>DOM 事件添加中，为了兼容现代浏览器和 IE 浏览器，我们需要对浏览器环境进行一次判断：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addEvent = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.addEventListener) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, el, fn</span>) </span>&#123;</span><br><span class=\"line\">            el.addEventListener(type, fn, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.attachEvent) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, el, fn</span>) </span>&#123;</span><br><span class=\"line\">            el.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + type, fn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"43-用闭包保存状态\"><a class=\"markdownIt-Anchor\" href=\"#43-用闭包保存状态\">#</a> 4.3 用闭包保存状态</h3>\n<p>这里我仅举个例子，为我的下一篇文章 ——《JavaScript 中的闭包》卖个关子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elems = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; elems.length; i++) &#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">lockedInIndex</span>) </span>&#123;</span><br><span class=\"line\">        elems[i].addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            e.preventDefault();</span><br><span class=\"line\">            alert(<span class=\"string\">&#x27;I am link #&#x27;</span> + lockedInIndex);</span><br><span class=\"line\">        &#125;, <span class=\"string\">&#x27;false&#x27;</span>);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h3>\n<p>当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Barry&quot;</span>;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// 无法从外部访问变量 name</span></span><br><span class=\"line\">name <span class=\"comment\">// 抛出错误：&quot;Uncaught ReferenceError: name is not defined&quot;</span></span><br></pre></td></tr></table></figure>\n<p>将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Barry&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// IIFE 执行后返回的结果：</span></span><br><span class=\"line\">result; <span class=\"comment\">// &quot;Barry&quot;</span></span><br></pre></td></tr></table></figure>",
            "tags": [
                "JavaScript专题",
                "javascript"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/03/23/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F/",
            "url": "https://gaoyuan.ink/2021/03/23/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F/",
            "title": "JavaScript基础（三）作用域",
            "date_published": "2021-03-23T03:00:57.000Z",
            "content_html": "<blockquote>\n<p>作用域的篇幅不会太长，作为自己对 Js 总结的第三篇文章，主要是承上启下。 之后会涉及到执行上下文，闭包等相关专题，为了避免内容过多，作用域这一部分单独总结。</p>\n</blockquote>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/%E4%B8%8B%E8%BD%BD.jpeg\" style=\"zoom:67%;\" />\n<span id=\"more\"></span>\n<h2 id=\"一-作用域的定义\"><a class=\"markdownIt-Anchor\" href=\"#一-作用域的定义\">#</a> 一、作用域的定义</h2>\n<p><strong>一张导图概括本节内容</strong> <img data-src=\"https://img-blog.csdnimg.cn/20200609102448438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"> <strong>1.1 常见的解释</strong></p>\n<ol>\n<li>一段程序代码中所用到的<strong>名字</strong>并不总是有效，而限定它的可用性的范围就是这个名字的作用域；</li>\n<li>作用域规定了<strong>如何查找变量</strong>，也就是确定当前执行代码对变量的访问权限；</li>\n<li>通俗的讲作用域就是<strong>一套规则</strong>，用于确定在何处以及如何查找<strong>某个变量</strong>的规则</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// a is not defined a变量并不是任何地方都可以被找到的</span></span><br></pre></td></tr></table></figure>\n<p><strong>1.2 JavaScript 中作用域工作模型</strong></p>\n<p>JavaScript 采用是词法作用域 (lexical scoping)，也就是静态作用域：</p>\n<ul>\n<li>函数的作用域在函数定义的时候就决定了</li>\n</ul>\n<p>与之对应的还有一个动态作用域：</p>\n<ul>\n<li>函数的作用域是在函数调用的时候才决定的；</li>\n</ul>\n<p><strong>1.3 全局变量和局部变量</strong></p>\n<p>根据定义变量的方式又可以分为：</p>\n<p>局部变量：只能在函数中访问，该函数外不可访问；</p>\n<ul>\n<li>定义在函数中的变量</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// ？</span></span><br><span class=\"line\">fn(); <span class=\"comment\">// ？</span></span><br></pre></td></tr></table></figure>\n<p>全局：任何地方都能访问到的对象拥有全局作用域。</p>\n<ul>\n<li>函数外定义的变量</li>\n<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a1-&#x27;</span>,a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\ta = <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a2-&#x27;</span>,a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a3-&#x27;</span>,a);</span><br><span class=\"line\">fn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a4-&#x27;</span>,a);</span><br></pre></td></tr></table></figure>\n<p>注意：在 ES6 之后又提出了块级作用域，它们之间的区别我们之后再来讨论。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=2659298556,3987226078&amp;fm=26&amp;gp=0.jpeg\" alt=\"\"></p>\n<h2 id=\"二-理解作用域\"><a class=\"markdownIt-Anchor\" href=\"#二-理解作用域\">#</a> 二、理解作用域</h2>\n<p>根据第一节的描述，我们一一验证一下</p>\n<p><strong>2.1 理解词法作用域</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n<p>我们结合定义去分析：</p>\n<ul>\n<li>执行 <code>bar</code>  函数，函数内部形成了局部作用域；</li>\n<li>声明 value 变量，并赋值 2</li>\n<li>执行 <code>foo</code>  函数，函数 foo 的作用域内没有 <code>value</code>  这个变量，它会向外查找</li>\n<li>根据词法作用域的规则，函数定义时， <code>foo</code>  的外部作用域为全局作用域</li>\n<li>打印<strong>结果是 1</strong></li>\n</ul>\n<p>如果是动态作用域的话：结果<strong>就是 2</strong>，不知道你是否想明白了？</p>\n<p><strong>2.2 全局变量</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;全局变量&#x27;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(str+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">childFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(str+<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(str+<span class=\"number\">3</span>);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tfn();</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tchildFn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func();</span><br><span class=\"line\"><span class=\"comment\">// 全局变量1</span></span><br><span class=\"line\"><span class=\"comment\">// 全局变量2</span></span><br><span class=\"line\"><span class=\"comment\">// 全局变量3</span></span><br></pre></td></tr></table></figure>\n<p>再来分析下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\ta = <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a1-&#x27;</span>,a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a2-&#x27;</span>,a);</span><br><span class=\"line\">fn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a3-&#x27;</span>,a);</span><br><span class=\"line\"><span class=\"comment\">// a2- 100 // 在当前作用域下查找变量a =&gt; 100</span></span><br><span class=\"line\"><span class=\"comment\">// a1- 1000 // 函数执行时，全局变量a已经被重新赋值</span></span><br><span class=\"line\"><span class=\"comment\">// a3- 1000 // 全局变量a =&gt; 1000</span></span><br></pre></td></tr></table></figure>\n<p><strong>2.3 局部作用域</strong></p>\n<p>局部作用域一般只在固定的代码片段内可访问到，最常见的就是以函数为单位的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name=<span class=\"string\">&quot;高原&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">childFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    childFn(); <span class=\"comment\">// 高原</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// name is not defined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"三-作用域链\"><a class=\"markdownIt-Anchor\" href=\"#三-作用域链\">#</a> 三、作用域链</h2>\n<p><strong>3.1 当查找变量的时候都发生了什么？</strong></p>\n<ul>\n<li>会先从当前<strong>上下文的变量对象</strong>中查找；</li>\n<li>如果没有找到，就会从父级 (词法层面上的父级)<strong> 执行上下文</strong>的变量对象中查找；</li>\n<li>一直找到全局上下文的变量对象，也就是全局对象；</li>\n<li>作用域链的顶端就是全局对象；</li>\n</ul>\n<p>这样<strong>由多个执行上下文的变量对象构成的链表就叫做作用域链</strong>，从某种意义上很类似原型和原型链。</p>\n<p><strong>3.2 作用域链和原型继承查找时的区别：</strong></p>\n<ul>\n<li>查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回 <code>undefined</code></li>\n<li>查找的属性在作用域链中不存在的话就会抛出 <code>ReferenceError</code> 。</li>\n</ul>\n<p><strong>3.3 作用域嵌套</strong></p>\n<p>既然每一个函数就可以形成一个作用域（ <code>词法作用域</code>  ||  <code>块级作用域</code> ），那么当然也会存在多个作用域嵌套的情况，他们遵循这样的查询规则：</p>\n<ul>\n<li>内部作用域有权访问外部作用域；</li>\n<li>外部作用域无法访问内部作用域；（真是是这样吗？）</li>\n<li>兄弟作用域不可互相访问；</li>\n</ul>\n<p>在《你不知道的 Js》中，希望读者可以将作用域的嵌套和作用域链想象成这样：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2020060915193493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"四-思考与总结\"><a class=\"markdownIt-Anchor\" href=\"#四-思考与总结\">#</a> 四、思考与总结</h2>\n<p><strong>4.1 总结</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200609160809565.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><strong>4.2 思考</strong></p>\n<p>最后，让我们看一个《JavaScript 权威指南》中的两段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;global scope&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;local scope&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(); <span class=\"comment\">// 注意</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope1();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;global scope&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;local scope&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope2()();</span><br></pre></td></tr></table></figure>\n<p>两段代码的结果都是 &quot;local scope&quot;，书中的回答是：JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f () 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f ()，这种绑定在执行 f () 时依然有效。</p>\n<p>但是它们内部经历的事情是一样的吗？</p>\n",
            "tags": [
                "JavaScript专题",
                "javascript"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/03/21/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/",
            "url": "https://gaoyuan.ink/2021/03/21/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/",
            "title": "JavaScript基础（二）从原型到原型链",
            "date_published": "2021-03-21T02:09:04.000Z",
            "content_html": "<blockquote>\n<p>本文主要从构造函数 -&gt; 原型（隐式原型 + 显示原型）-&gt; 原型链的顺序，渐进式讲解，希望对你有所做帮助，共勉～</p>\n</blockquote>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>又到了回忆过去的时候了，知识就是这样，原型和原型链在我之前的实习生涯中用到的很少 —— 几乎没有（噗！我菜我摊牌了），但是它和 this 指向问题一样，是初级、中级前端开发在面试时永远绕不开的话题。是不是大家每次看面经的时候都会去搜索原型相关的知识点？</p>\n<p>你看这知识，总是在考的时候，才能知道它的重要，就好像曾经有一段贼拉真挚的面试题摆在我面前… 话题拉回来，今天我们就收了这个<strong>孽障</strong>！</p>\n<img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/src=http___img.wxcha.com_file_201711_22_e1655873d2.jpg&refer=http___img.wxcha.jpeg\" style=\"zoom:50%;\" />\n<span id=\"more\"></span>\n<h2 id=\"一-构造函数\"><a class=\"markdownIt-Anchor\" href=\"#一-构造函数\">#</a> 一、构造函数</h2>\n<h3 id=\"11-什么是构造函数\"><a class=\"markdownIt-Anchor\" href=\"#11-什么是构造函数\">#</a> 1.1 什么是构造函数？</h3>\n<p>构造函数本身就是一个函数，与普通函数没有任何区别，不过<strong>为了规范一般将其首字母大写</strong>。构造函数和普通函数的区别在于，使用<strong> new</strong> 生成实例的函数就是构造函数，直接调用的就是普通函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name) <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，Person 就是一个构造函数。</p>\n<h3 id=\"12-constructor\"><a class=\"markdownIt-Anchor\" href=\"#12-constructor\">#</a> 1.2 constructor？</h3>\n<p><code>constructor</code>  返回创建实例对象时构造函数的引用。此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200604185358168.png\" alt=\"被构造出来的person的\"> 可以看到实例对象的 constructor 指向了它的构造函数，而它和原型的关系我们在之后会链接到一起。</p>\n<h3 id=\"13-都有哪些数据类型或者函数拥有constructor呢\"><a class=\"markdownIt-Anchor\" href=\"#13-都有哪些数据类型或者函数拥有constructor呢\">#</a> 1.3 都有哪些数据类型或者函数拥有 <code>constructor</code>  呢？</h3>\n<p>在 JavaScript 中，每个具有<strong>原型</strong>的对象都会自动获得 constructor 属性。除了： <code>arguments</code> 、 <code>Enumerator</code> 、 <code>Error</code> 、 <code>Global</code> 、 <code>Math</code> 、 <code>RegExp</code>  等一些特殊对象之外，其他所有的 JavaScript 内置对象都具备 constructor 属性。例如： <code>Array</code> 、 <code>Boolean</code> 、 <code>Date</code> 、 <code>Function</code> 、 <code>Number</code> 、 <code>Object</code> 、 <code>String</code>  等。所有主流浏览器均支持该属性。打开控制台我们可以验证一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;str&#x27;</span>.constructor) <span class=\"comment\">// ƒ String() &#123; [native code] &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;str&#x27;</span>.constructor === <span class=\"built_in\">String</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].constructor) <span class=\"comment\">// ƒ Array() &#123; [native code] &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].constructor === <span class=\"built_in\">Array</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数字</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.constructor) <span class=\"comment\">// ƒ Number() &#123; [native code] &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.constructor === <span class=\"built_in\">Number</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Date</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().constructor) <span class=\"comment\">// ƒ Date() &#123; [native code] &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 注意！！！不要混淆哦</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime().constructor) <span class=\"comment\">// ƒ Number() &#123; [native code] &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Boolean</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>.constructor) <span class=\"comment\">// ƒ Boolean() &#123; [native code] &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>.constructor === <span class=\"built_in\">Boolean</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(show.constructor) <span class=\"comment\">// ƒ Function() &#123; [native code] &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义构造函数，无返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.constructor) <span class=\"comment\">// ƒ Person()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;gaoyuan&#x27;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = Person()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1.constructor) <span class=\"comment\">// ƒ Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"14-模拟实现一个new\"><a class=\"markdownIt-Anchor\" href=\"#14-模拟实现一个new\">#</a> 1.4 模拟实现一个 new</h3>\n<p>既然构造函数与普通函数的区别仅仅在于调用方式上，我们就应该了解 new。</p>\n<ul>\n<li>当调用 <code>new</code>  运算符时，该函数总会返回一个对象；</li>\n<li>通常情况下，构造器里的 this 就指向返回的这个对象；</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通常情况下</span><br><span class=\"line\"><span class=\"keyword\">var</span> MyClass = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\">obj.name; <span class=\"comment\">// gaoyuan</span></span><br><span class=\"line\"></span><br><span class=\"line\">特殊情况</span><br><span class=\"line\"><span class=\"keyword\">var</span> MyClass = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;老王&#x27;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\">obj.name <span class=\"comment\">// 老王</span></span><br></pre></td></tr></table></figure>\n<p>我们利用  <code>__proto__</code> （隐式原型，下文会提到）属性来模拟一下 new 调用构造函数的过程：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objectNew = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从object.prototype上克隆一个空的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 取得外部传入的构造器，这里是Person</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> Constructor = [].shift.call( <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">    <span class=\"comment\">// 更新，指向正确的原型</span></span><br><span class=\"line\">    obj.__proto__ = Constructor.prototype; <span class=\"comment\">//知识点，要考、要考、要考</span></span><br><span class=\"line\">    <span class=\"comment\">// 借用外部传入的构造器给obj设置属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = Constructor.apply(obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 确保构造器总是返回一个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> ref === <span class=\"string\">&#x27;object&#x27;</span> ? ret : obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=1200653736,2067630829&fm=26&gp=0.jpeg\" style=\"zoom: 67%;\" />\n<h2 id=\"二-原型\"><a class=\"markdownIt-Anchor\" href=\"#二-原型\">#</a> 二、原型</h2>\n<h3 id=\"21-prototype显式原型\"><a class=\"markdownIt-Anchor\" href=\"#21-prototype显式原型\">#</a> 2.1 prototype (显式原型)</h3>\n<p>JavaScript 是一种基于原型的语言 (prototype-based language)，在设计的时候模仿了 Java 的两套类型机制： <code>基本类型</code>  和  <code>对象类型</code> 。可见原型很重要！</p>\n<p>每个对象都拥有一个原型对象，类是以函数的形式来定义的。prototype 表示该函数的原型，也表示一个类的成员的集合。看下图： <img data-src=\"https://img-blog.csdnimg.cn/20200605140618427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"> 可以发现 Person 函数自己的原型都有什么：</p>\n<ul>\n<li><code>constructor</code>  (Person.prototype.constructor =&gt; Person)</li>\n<li><code>__proto__</code>  （我们称它为隐式原型）</li>\n</ul>\n<p>此时我们得到了第一张表示构造函数和实例原型之间的关系图：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTEucG5n?x-oss-process=image/format,png\" alt=\"构造函数和实例原型的关系图\"></p>\n<p>那么我们该怎么表示实例与构造函数原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p>\n<h3 id=\"22-proto隐式原型\"><a class=\"markdownIt-Anchor\" href=\"#22-proto隐式原型\">#</a> 2.2 <strong>proto</strong> (隐式原型)</h3>\n<p>这是每一个 JavaScript 对象 (除了 null) 都具有的一个属性，叫 <code>__proto__</code> ，这是一个访问器属性（即 getter 函数和 setter 函数），通过它可以访问到对象的内部 <code>[[Prototype]]</code>  (一个对象或 null)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.__proto__ === Person.prototype); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>于是我们更新下关系图：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTIucG5n?x-oss-process=image/format,png\" alt=\"实例与实例原型的关系图\"></p>\n<p><strong>小结：</strong> 每个引用类型的隐式原型都指向它的构造函数的显式原型</p>\n<h3 id=\"23-constructor\"><a class=\"markdownIt-Anchor\" href=\"#23-constructor\">#</a> 2.3 constructor</h3>\n<p>前文提到了 <code>constructor</code> ，它与原型的关系也可以添加到这张图里，更新下关系图：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTMucG5n?x-oss-process=image/format,png\" alt=\"实例原型与构造函数的关系图\"> 根据上图的关系，下面这段的结果，大家就一目了然了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.__proto__ == Person.prototype) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor == Person) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(person) === Person.prototype) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>接下来我们要继续思考实例和原型的关系：</p>\n<h2 id=\"三-实例与原型\"><a class=\"markdownIt-Anchor\" href=\"#三-实例与原型\">#</a> 三、实例与原型</h2>\n<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。这样一个查找过程</p>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">&#x27;老王&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person.name = <span class=\"string\">&#x27;余光&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name) <span class=\"comment\">// 余光</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> person.name;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name) <span class=\"comment\">// 老王</span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 <span class=\"exturl\" data-url=\"aHR0cDovL3BlcnNvbi5uYW1l\">person.name</span> 的时候，结果自然为 余光（is me）。</p>\n<p><strong>描述：</strong></p>\n<p>但是当我们删除了 person 的 name 属性后，再次读取 <span class=\"exturl\" data-url=\"aHR0cDovL3BlcnNvbi5uYW1l\">person.name</span>，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 老王（这…）</p>\n<p><strong>总结：</strong></p>\n<ul>\n<li>尝试遍历 <code>实例a</code>  中的所有属性，但没有找到目标属性；</li>\n<li>查找 <code>name</code>  属性的这个请求被委托给该 <code>实例a</code>  的构造器 ( <code>A</code> ) 的原型，它被 <code>a.__proto__</code>  记录着并且指向 A.prototype；</li>\n<li>A.prototype 存在目标属性，返回他的值；</li>\n</ul>\n<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>\n<h2 id=\"四-原型的原型\"><a class=\"markdownIt-Anchor\" href=\"#四-原型的原型\">#</a> 四、原型的原型</h2>\n<p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">obj.name = <span class=\"string\">&#x27;余光&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.name) <span class=\"comment\">// 余光</span></span><br></pre></td></tr></table></figure>\n<p>其实原型对象就是通过 <code>Object</code>  构造函数生成的，结合之前所讲，实例的  <code>__proto__</code>  指向构造函数的  <code>prototype</code>  ，可以理解成， <code>Object.prototype()</code>  是所有对象的根对象，所以我们再次更新下关系图：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTQucG5n?x-oss-process=image/format,png\" alt=\"原型的原型关系图\"></p>\n<h2 id=\"五-原型链\"><a class=\"markdownIt-Anchor\" href=\"#五-原型链\">#</a> 五、原型链</h2>\n<p>每个对象拥有一个原型对象，通过  <code>__proto__</code>  指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向  <code>null</code> 。<strong>这种关系被称为原型链</strong> (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。</p>\n<p>这个链条存在着终点，是因为：Object.prototype 的原型是 ——null，引用阮一峰老师的 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTQvMDMvdW5kZWZpbmVkLXZzLW51bGwuaHRtbA==\">《undefined 与 null 的区别》 (opens new window)</span> 就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null 表示“没有对象”，即该处不应该有值。这句话也意味着 Object.prototype 没有原型</span><br></pre></td></tr></table></figure>\n<p>我们最后更新一次关系图，蓝色线条就可以表示原型链这种关系。</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTUucG5n?x-oss-process=image/format,png\" alt=\"原型链示意图\"></p>\n<h3 id=\"补充易错点\"><a class=\"markdownIt-Anchor\" href=\"#补充易错点\">#</a> 补充，易错点</h3>\n<p><strong>1.constructor</strong> 首先是 constructor 属性，我们看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.constructor === Person); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性，当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>\n<p><strong>2. <code>__proto__</code> </strong></p>\n<p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf (obj)。</p>\n<p><strong>3. 真的是继承吗？</strong></p>\n<p>最后是关于继承，前面我们讲到 “每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是：</p>\n<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，<strong>委托</strong>的说法反而更准确些。</p>\n<h2 id=\"六-总结\"><a class=\"markdownIt-Anchor\" href=\"#六-总结\">#</a> 六、总结</h2>\n<ul>\n<li>使用<strong> new</strong> 生成实例的函数就是构造函数，直接调用的就是普通函数；</li>\n<li>每个对象都拥有一个原型对象；</li>\n<li>每个引用类型的隐式原型都指向它的构造函数的显式原型；</li>\n<li>Object.prototype 是所有对象的根对象；</li>\n<li>原型链存在终点，不会无限查找下去；</li>\n</ul>\n",
            "tags": [
                "c",
                "javascript"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/03/20/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89this/",
            "url": "https://gaoyuan.ink/2021/03/20/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89this/",
            "title": "JavaScript基础（一）this",
            "date_published": "2021-03-20T01:55:37.000Z",
            "content_html": "<h3 id=\"一-this的指向\"><a class=\"markdownIt-Anchor\" href=\"#一-this的指向\">#</a> 一、this 的指向</h3>\n<p>百度、谷歌上输入 “this 的指向” 关键字，大几千条文章肯定是有的，总不至于为了全方面、无死角的掌握它就要将所有的文章都看一遍吧？所以不如梳理出一个稳固的框架，我们一起来填充它。</p>\n<h4 id=\"思维导图\"><a class=\"markdownIt-Anchor\" href=\"#思维导图\">#</a> 思维导图</h4>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200602110330766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<span id=\"more\"></span>\n<ul>\n<li>this 总是（非严格模式下）指向一个对象，而具体指向哪个对象是在运行时基于函数的 <code>执行环境</code> 动态绑定的，而非函数被声明时的环境；</li>\n<li>除了不常用的 with 和 eval 的情况，具体到实际应用中，this 指向大概可以分为四种：\n<ul>\n<li>作为对象的方法调用；</li>\n<li>作为普通函数调用；</li>\n<li>构造器调用；</li>\n<li>call 或 apply 调用；</li>\n<li>箭头函数中，this 指向函数上层作用域的 this；</li>\n</ul>\n</li>\n<li><strong>构造器</strong>和<strong>普通函数</strong>的区别在于 <code>被调用的方式</code> ；</li>\n<li>A,call (B) =&gt; 可以理解成在 B 的作用域内调用了 A 方法；</li>\n</ul>\n<h4 id=\"11-作为对象的方法调用\"><a class=\"markdownIt-Anchor\" href=\"#11-作为对象的方法调用\">#</a> 1.1 作为对象的方法调用</h4>\n<p>当函数作为对象的方法被调用时， <code>this指向该对象</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;gaoyuan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> === obj);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getName(); <span class=\"comment\">// true gaoyuan</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"12-作为普通函数调用\"><a class=\"markdownIt-Anchor\" href=\"#12-作为普通函数调用\">#</a> 1.2 作为普通函数调用</h4>\n<p>当函数不作为对象的属性被调用，而是以普通函数的方式，this 总是指向全局对象（在浏览器中，通常是 Window 对象）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getName(); <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>或者下面这段迷惑性的代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.name = <span class=\"string\">&#x27;老王&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;gaoyuan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getNew = obj.getName;</span><br><span class=\"line\">getNew(); <span class=\"comment\">// 老王</span></span><br></pre></td></tr></table></figure>\n<p>而在 ES5 的严格模式下，this 被规定为不会指向全局对象，而是 <code>undefined</code></p>\n<h4 id=\"13-构造器调用\"><a class=\"markdownIt-Anchor\" href=\"#13-构造器调用\">#</a> 1.3 构造器调用</h4>\n<p>除了一些内置函数，大部分 Js 中的函数都可以成为构造器，它们与普通函数没什么不同</p>\n<p><strong>构造器</strong>和<strong>普通函数</strong>的区别在于 <code>被调用的方式</code> ： 当 new 运算符调用函数时，总是返回一个对象，this 通常也指向这个对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyClass = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> MyClass()</span><br><span class=\"line\">obj.name; <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>但是，如果显式的返回了一个 object 对象，那么此次运算结果最终会返回这个对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyClass = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myClass = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;myClass.name:&#x27;</span>, myClass.name); <span class=\"comment\">// &#123; name: 2&#125;</span></span><br></pre></td></tr></table></figure>\n<p>只要构造器不显示的返回任何数据，或者返回非对象类型的数据，就不会造成上述问题。</p>\n<h4 id=\"14-call或apply调用\"><a class=\"markdownIt-Anchor\" href=\"#14-call或apply调用\">#</a> 1.4 call 或 apply 调用</h4>\n<p>跟普通的函数调用相比，用 call 和 apply 可以动态的改变函数的 this</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num = <span class=\"string\">&#x27;&#x27;</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name + num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 可以理解成在 obj2的作用域下调用了 obj1.getName()函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.getName()); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.getName.call(obj2, <span class=\"number\">2</span>)); <span class=\"comment\">// 2 + 2 = 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.getName.apply(obj2, [<span class=\"number\">2</span>])); <span class=\"comment\">// 2 + 2 = 4</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"15-箭头函数\"><a class=\"markdownIt-Anchor\" href=\"#15-箭头函数\">#</a> 1.5 箭头函数</h4>\n<p>箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this。因此，在下面的代码中，传递给 setInterval 的函数内的 this 与封闭函数中的 this 值相同：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.name = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getName()</span><br></pre></td></tr></table></figure>\n<h4 id=\"16-常见的坑\"><a class=\"markdownIt-Anchor\" href=\"#16-常见的坑\">#</a> 1.6 常见的坑</h4>\n<p>就像标题一样，有的时候 <code>this</code>  会指向 undefined</p>\n<p><strong>情况一</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.getName();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName2 = obj.getName;</span><br><span class=\"line\">getName2()</span><br></pre></td></tr></table></figure>\n<p>这个时候，getName2 () 作为普通函数被调用时，this 指向全局对象 ——window。</p>\n<p><strong>情况二</strong></p>\n<p>当我们希望自己封装 Dom 方法，来精简代码时：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getDomById = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">getDomById(<span class=\"string\">&#x27;div1&#x27;</span>) <span class=\"comment\">//dom节点</span></span><br></pre></td></tr></table></figure>\n<p>那么我们看看这么写行不行？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getDomById = <span class=\"built_in\">document</span>.getElementById</span><br><span class=\"line\">getDomById(<span class=\"string\">&#x27;div1&#x27;</span>) <span class=\"comment\">// Uncaught TypeError: Illegal invocation(非法调用)</span></span><br></pre></td></tr></table></figure>\n<p>这是因为:</p>\n<ul>\n<li>当我们去调用 <code>document</code>  对象的方法时，方法内的 this 指向 <code>document</code> 。</li>\n<li>当我们用 getId 应用 document 内的方法，再以普通函数的方式调用，函数内容的 this 就指向了全局对象。</li>\n</ul>\n<p><strong>利用 call 和 apply 修正情况二</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">document</span>, ...arguments)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">document</span>.getElementById)</span><br><span class=\"line\"><span class=\"comment\">// 利用立即执行函数将document保存在作用域中</span></span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=2299180848,518697654&amp;fm=26&amp;gp=0.jpeg\" alt=\"\"></p>\n<h3 id=\"二-call和apply\"><a class=\"markdownIt-Anchor\" href=\"#二-call和apply\">#</a> 二、call 和 apply</h3>\n<p>不要因为它的 “强大” 而对它产生抗拒，了解并熟悉它是我们必须要做的，共勉！</p>\n<h4 id=\"思维导图-2\"><a class=\"markdownIt-Anchor\" href=\"#思维导图-2\">#</a> 思维导图</h4>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200602153648211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"1call和apply区别\"><a class=\"markdownIt-Anchor\" href=\"#1call和apply区别\">#</a> 1.call 和 apply 区别</h4>\n<p>先来看区别，是因为它们<strong>几乎</strong>没有区别，下文代码实例 call 和 apply 都可以轻易的切换。</p>\n<p>当它们被设计出来时要做到的事情一摸一样，唯一的区别就在于 <code>传参的格式不一样</code></p>\n<ul>\n<li>apply 接受两个参数\n<ul>\n<li>第一个参数指定了函数体内 this 对象的指向</li>\n<li>第二个参数为一个带下标的参数集合（可以是数组或者类数组）</li>\n</ul>\n</li>\n<li>call 接受的参数不固定\n<ul>\n<li>第一个参数指定了函数体内 this 对象的指向</li>\n<li>第二个参数及以后为函数调用的参数</li>\n</ul>\n</li>\n</ul>\n<p>因为在所有（非箭头）函数中都可以通过 <code>arguments</code>  对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，它本身就是一个类数组，我们 apply 在实际使用中更常见一些。</p>\n<p>call 是包装在 apply 上面的语法糖，如果我们明确的知道参数数量，并且希望展示它们，可以使用 call。</p>\n<p>当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会默认指向宿主对象，在浏览器中则是 <code>window</code> 。</p>\n<p><strong>借用其他对象的方法</strong></p>\n<p>我们可以直接传 null 来代替任意对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])</span><br></pre></td></tr></table></figure>\n<h4 id=\"2call和apply能做什么\"><a class=\"markdownIt-Anchor\" href=\"#2call和apply能做什么\">#</a> 2.call 和 apply 能做什么？</h4>\n<p>使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数 —— 来时<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbA==\"> MDN (opens new window)</span></p>\n<ul>\n<li>调用构造函数来 <code>实现继承</code> ；</li>\n<li>调用函数并且指定上下文的  <code>this</code> ;</li>\n<li>调用函数并且不指定第一个参数；</li>\n</ul>\n<p><strong>1. 调用构造函数来实现继承</strong></p>\n<p>通过 “借用” 的方式来达到继承的效果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Product</span>(<span class=\"params\">name, price</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.price = price;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span>(<span class=\"params\">name, price</span>) </span>&#123;</span><br><span class=\"line\">\tProduct.call(<span class=\"built_in\">this</span>, name, price); <span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.category = food;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hotDog = <span class=\"keyword\">new</span> Food(<span class=\"string\">&#x27;hotDog&#x27;</span>, <span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>2. 调用函数并且指定上下文的  <code>this</code> </strong></p>\n<p>此时 this 被指向了 obj</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.id + <span class=\"string\">&#x27;:&#x27;</span> + <span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;gaoyuan&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">showName.call(obj)</span><br></pre></td></tr></table></figure>\n<p><strong>3. 使用 call 单纯的调用某个函数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=826503588,4160798134&amp;fm=15&amp;gp=0.jpeg\" alt=\"\"></p>\n<h3 id=\"三-模拟实现一个call\"><a class=\"markdownIt-Anchor\" href=\"#三-模拟实现一个call\">#</a> 三、模拟实现一个 call</h3>\n<p>先来看一下 call 帮我们需要做什么？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">value</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">show.call(foo); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>就像解方程，要在已知条件中寻找突破哦口：</p>\n<ul>\n<li><code>call</code>  使得 this 的指向变了，指向了 foo;</li>\n<li><code>show</code>  函数被执行了；</li>\n<li>传入的参数应为  <code>this</code>  + 参数列表；</li>\n</ul>\n<p><strong>第一版代码</strong></p>\n<p>上面提到的 3 点，仅仅完成了一点，且传入的参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.setCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>); <span class=\"comment\">// 此时this指向show</span></span><br><span class=\"line\">    obj.func = <span class=\"built_in\">this</span>; <span class=\"comment\">// 将函数变成对象的内部属性</span></span><br><span class=\"line\">    obj.func(obj.value) <span class=\"comment\">// 指定函数</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> obj.func <span class=\"comment\">// 删除函数，当做什么都没发生～</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">show.setCall(foo)</span><br></pre></td></tr></table></figure>\n<p><strong>第二版代码</strong></p>\n<p>为了解决参数的问题，我们要能获取到参数，并且正确的传入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a + b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.setCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    obj.fn = <span class=\"built_in\">this</span>; <span class=\"comment\">// 将函数变成对象的内部属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++)&#123;</span><br><span class=\"line\">        args.push(<span class=\"string\">&#x27;arguments[&#x27;</span> + i + <span class=\"string\">&#x27;]&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">eval</span>(<span class=\"string\">&#x27;obj.fn(&#x27;</span> + args + <span class=\"string\">&#x27;)&#x27;</span>); <span class=\"comment\">// 传入参数</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> obj.fn; <span class=\"comment\">// 删除函数，当做什么都没发生～</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">show.setCall(foo, <span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 1 3</span></span><br></pre></td></tr></table></figure>\n<p>此时，我们就可以做到，传入多个参数的情况下使用 call 了，但是如果你仅想用某个方法呢？</p>\n<p><strong>第三版代码</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.setCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = obj || <span class=\"built_in\">window</span>;</span><br><span class=\"line\">  obj.fn = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>, len = <span class=\"built_in\">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">    args.push(<span class=\"string\">&#x27;arguments[&#x27;</span> + i + <span class=\"string\">&#x27;]&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"built_in\">eval</span>(<span class=\"string\">&#x27;obj.fn(&#x27;</span> + args +<span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> obj.fn;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 测试一下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">value</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"built_in\">this</span>.value,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: name,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: age</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar.setCall(<span class=\"literal\">null</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar.setCall(obj, <span class=\"string\">&#x27;kevin&#x27;</span>, <span class=\"number\">18</span>));</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-bind\"><a class=\"markdownIt-Anchor\" href=\"#四-bind\">#</a> 四、bind</h3>\n<p>提到了<strong> call</strong> 和<strong> apply</strong>，就绕不开<strong> bind ()</strong>，来看一下 MDN 上对 **bind ()** 的解释：</p>\n<p>bind () 方法创建一个新的函数，在 bind () 被调用时，这个新函数的 this 被指定为 bind () 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>\n<p>我们用 Js 来模拟一个 bind 方法，以便加深我们的认识</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"built_in\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _this.apply(func, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func.bind(obj)</span><br></pre></td></tr></table></figure>\n<p>这样看上去，bind 总会帮我们返回同样的 <code>this</code>  值，还是挺坚挺的哦～</p>\n",
            "tags": [
                "JavaScript专题",
                "javascript"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/",
            "url": "https://gaoyuan.ink/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/",
            "title": "函数防抖与节流",
            "date_published": "2021-03-19T01:43:56.000Z",
            "content_html": "<h2 id=\"函数防抖\"><a class=\"markdownIt-Anchor\" href=\"#函数防抖\">#</a> 函数防抖</h2>\n<h3 id=\"一-为什么需要防抖\"><a class=\"markdownIt-Anchor\" href=\"#一-为什么需要防抖\">#</a> 一、为什么需要防抖</h3>\n<ul>\n<li>高频的函数操作可能产生不好的影响</li>\n<li>如：resize、scroll、mousedown、mousemove、keyup、keydown……</li>\n</ul>\n<p>为此，我们举个示例代码来了解事件如何频繁的触发：</p>\n<p>我们写一个 index.html 文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">    &lt;title&gt;debounce&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        #wrapper &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 200px;</span><br><span class=\"line\">            line-height: 200px;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">            color: #fff;</span><br><span class=\"line\">            background-color: #444;</span><br><span class=\"line\">            font-size: 30px;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        var count = 1;</span><br><span class=\"line\">        var oDiv = document.getElementById(&quot;wrapper&quot;);</span><br><span class=\"line\">        function getUserAction() &#123;</span><br><span class=\"line\">            oDiv.innerHTML = count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        oDiv.onmousemove = getUserAction;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>从左边滑到右边就触发了近 100 次 <code>getUserAction</code>  函数！看如下 Gif：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408456-269506ee-a343-41c8-86b8-e80da9304d8e.gif\" alt=\"\"></p>\n<p>因为这个例子很简单，所以浏览器完全反应的过来，但假设：</p>\n<ul>\n<li>它的触发频次极高，1 分钟 2000 次，且涉及到大量的位置计算、DOM 操作等工作，</li>\n<li>存在接口请求，单个函数执行时间较长，但每个函数触发的间隔很近。</li>\n</ul>\n<p>这种在一瞬间（短时间内）对浏览器或服务器造成了过多压力的交互就需要进行优化了，为了解决这个问题，一般有两种解决方案：</p>\n<ul>\n<li>debounce 防抖</li>\n<li>throttle 节流</li>\n</ul>\n<p>他们的目的都是：<strong>降低一个函数的触发频率，以提高性能或避免资源浪费。</strong></p>\n<h3 id=\"二-防抖的原理\"><a class=\"markdownIt-Anchor\" href=\"#二-防抖的原理\">#</a> 二、防抖的原理</h3>\n<p>今天重点讲讲防抖的实现。</p>\n<p>防抖的原理就是：你尽管触发事件，但是我一定在事件触发 <code>n秒无操作后</code> 才执行。举个例子：</p>\n<p>我们规定 <code>3s</code>  为防抖的标准，那么:</p>\n<ol>\n<li>第一次要求执行事件 - 此时倒计时 3s</li>\n<li>倒计时 2s</li>\n<li>倒计时 1s</li>\n<li>0.5s 时事件再次被触发 - 此时倒计时 3s</li>\n<li>…3s 内无事发生</li>\n<li>执行事件，共用了 5.5s</li>\n</ol>\n<h3 id=\"三-自己实现一个防抖\"><a class=\"markdownIt-Anchor\" href=\"#三-自己实现一个防抖\">#</a> 三、自己实现一个防抖</h3>\n<h4 id=\"31-第一版\"><a class=\"markdownIt-Anchor\" href=\"#31-第一版\">#</a> 3.1 第一版</h4>\n<p>我们根据上一节提到的核心思想，实现第一版代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">        timer = setTimeout(func, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们要使用它，第一节的例子为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oDiv.onmousemove = debounce(getUserAction, 2000);</span><br></pre></td></tr></table></figure>\n<p>此时大家可以再次测试一下，事件持续发生时，只有在完全停止 2s 后，才会触发事件：</p>\n<p>写到这里，作为针对部分高频事件的需求来说，已经结束了。我们来看看他的效果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408554-b0245fd8-1c4d-4085-80da-f91d8be8da6f.gif\" alt=\"\"></p>\n<h4 id=\"32-第二版\"><a class=\"markdownIt-Anchor\" href=\"#32-第二版\">#</a> 3.2 第二版</h4>\n<p>大家都知道，dom 节点在触发事件的时候，this 指向它本身，本例中则指向 <code>oDiv</code> ，但是在本例中：我们看一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var count = 1;</span><br><span class=\"line\">var oDiv = document.getElementById(&quot;oDiv&quot;);</span><br><span class=\"line\">function getUserAction() &#123;</span><br><span class=\"line\">    oDiv.innerHTML = count++;</span><br><span class=\"line\">    console.log(&#x27;this&#x27;, this); // 此时输出 Window...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">oDiv.onmousemove = debounce(getUserAction, 2000);</span><br><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">        timer = setTimeout(func, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>毕竟经过了一层匿名函数的包裹，this 已经指向了 window，为了减少影响，我们尝试修正它</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        var _this = this; // 记录当前this</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">        timer = setTimeout(function()&#123;</span><br><span class=\"line\">            func.apply(_this); //将 func的this改为_this</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"33-第三版\"><a class=\"markdownIt-Anchor\" href=\"#33-第三版\">#</a> 3.3 第三版</h4>\n<p>解决的 this 指向问题，我们的函数仍然不够 “完美”，JavaScript 中，事件处理函数会提供 <code>event</code>  对象，我们简称为 e。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用了 debouce 函数</span><br><span class=\"line\">function getUserAction(e) &#123;</span><br><span class=\"line\">    console.log(e); // undefined</span><br><span class=\"line\">    oDiv.innerHTML = count++;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了保证它的原汁原味，我们再改第三版：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var count = 1;</span><br><span class=\"line\">var oDiv = document.getElementById(&quot;oDiv&quot;);</span><br><span class=\"line\">function getUserAction(e) &#123;</span><br><span class=\"line\">    oDiv.innerHTML = count++;</span><br><span class=\"line\">    console.log(&#x27;e&#x27;, e); // MouseEvent</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">oDiv.onmousemove = debounce(getUserAction, 2000);</span><br><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        var _this = this; // 记录当前this</span><br><span class=\"line\">        var arg = arguments; // 记录参数</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">        timer = setTimeout(function () &#123;</span><br><span class=\"line\">            func.apply(_this, arg); //将 func的this改为_this</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，我们在尽可能保留 Dom 事件原有能力的情况下，给函数加上了防抖效果，它可以解决大部分我们日常开发的防抖问题，但我们需要更 “完美”</p>\n<h3 id=\"四-防抖进阶\"><a class=\"markdownIt-Anchor\" href=\"#四-防抖进阶\">#</a> 四、防抖进阶</h3>\n<h4 id=\"41-立即执行\"><a class=\"markdownIt-Anchor\" href=\"#41-立即执行\">#</a> 4.1 立即执行</h4>\n<p>这个需求就是：</p>\n<ul>\n<li>立即执行</li>\n<li>保持 <code>n</code>  秒空白期</li>\n<li>将 <code>n</code>  秒空白期置后</li>\n</ul>\n<p>想想这个需求也是很有道理的嘛，那我们加个 <code>immediate</code>  参数判断是否是立刻执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, immediate) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        var _this = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        if (timer) clearTimeout(timer); // 常规流程，间隔内触发时清掉重置定时</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 如果已经执行过，不再执行</span><br><span class=\"line\">            var callNow = !timer; // 1. callNow 初始值是 true, 同步立即执行；随后 timer 才开始执行</span><br><span class=\"line\">            timer = setTimeout(function()&#123;</span><br><span class=\"line\">                timer = null; // wait 期间，timer 是一个 ID 数字，所以 callNow 为 false，func 在此期间永远不会执行</span><br><span class=\"line\">            &#125;, wait) // wait 之后，timer 赋值 null，callNow 为 true，func 又开始立即执行。</span><br><span class=\"line\">            if (callNow) func.apply(_this, args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            timer = setTimeout(function()&#123;</span><br><span class=\"line\">                func.apply(_this, args)</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看下此时他是什么效果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408487-78c69123-24ec-4893-b442-366d3117eda2.gif\" alt=\"\"></p>\n<h4 id=\"42-添加简单验证\"><a class=\"markdownIt-Anchor\" href=\"#42-添加简单验证\">#</a> 4.2 添加简单验证</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, immediate) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    // 检查函数</span><br><span class=\"line\">    if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class=\"line\">        throw new TypeError(&#x27;Expected a function&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 保证wait存在</span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\">    const debounced = function () &#123;</span><br><span class=\"line\">        var _this = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        if (timer) clearTimeout(timer); // 常规流程，间隔内触发时清掉重置定时</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 如果已经执行过，不再执行</span><br><span class=\"line\">            var callNow = !timer; // 如果不存在定时器，则callNow为true</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                timer = null; // 为了保证之后的时效性，手动添加timer</span><br><span class=\"line\">            &#125;, wait)</span><br><span class=\"line\">            // 因为不存在timer，证明是首次执行，所以直接调用</span><br><span class=\"line\">            if (callNow) func.apply(_this, args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(_this, args)</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return debounced</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"43-添加取消事件方法\"><a class=\"markdownIt-Anchor\" href=\"#43-添加取消事件方法\">#</a> 4.3 添加取消事件方法</h4>\n<p>如果你希望能取消被防抖的事件，我们可以这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, immediate) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    // 检查函数</span><br><span class=\"line\">    if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class=\"line\">        throw new TypeError(&#x27;Expected a function&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 保证wait存在</span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\">    const debounced = function () &#123;</span><br><span class=\"line\">        var _this = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        if (timer) clearTimeout(timer); // 常规流程，间隔内触发时清掉重置定时</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 如果已经执行过，不再执行</span><br><span class=\"line\">            var callNow = !timer; // 如果不存在定时器，则callNow为true</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                timer = null; // 为了保证之后的时效性，手动添加timer</span><br><span class=\"line\">            &#125;, wait)</span><br><span class=\"line\">            // 因为不存在timer，证明是首次执行，所以直接调用</span><br><span class=\"line\">            if (callNow) func.apply(_this, args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(_this, args)</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const cancel = function()&#123;</span><br><span class=\"line\">        clearTimeout(timer);</span><br><span class=\"line\">        timer = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const pending = function()&#123;</span><br><span class=\"line\">        return timer !== undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    debounced.pending = pending;</span><br><span class=\"line\">    return debounced</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再来看看效果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408427-b468ccd4-99ff-4eee-821a-290d95e04071.gif\" alt=\"\"></p>\n<h2 id=\"函数节流\"><a class=\"markdownIt-Anchor\" href=\"#函数节流\">#</a> 函数节流</h2>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>我们还是以移动事件举例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        #wrapper &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 140px;</span><br><span class=\"line\">            background: rgba(0, 0, 0, 0.8);</span><br><span class=\"line\">            color: #fff;</span><br><span class=\"line\">            font-size: 30px;</span><br><span class=\"line\">            font-weight: bold;</span><br><span class=\"line\">            line-height: 140px;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        var count = 1;</span><br><span class=\"line\">        function moveAction () &#123;</span><br><span class=\"line\">            oWrapper.innerHTML = count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var oWrapper = document.querySelector(&#x27;#wrapper&#x27;);</span><br><span class=\"line\">        oWrapper.onmousemove = moveAction;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>它的效果是这样：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551747-de70166f-f851-412c-ba2a-5a116a194f3d.gif\" alt=\"\"></p>\n<h3 id=\"一-核心和基本实现\"><a class=\"markdownIt-Anchor\" href=\"#一-核心和基本实现\">#</a> 一、核心和基本实现</h3>\n<p>节流的原理很简单：<strong>如果你持续触发某个事件，特定的时间间隔内，只执行一次。</strong></p>\n<p><strong>关于节流的实现，有两种主流的实现方式：</strong></p>\n<ol>\n<li>时间戳思路</li>\n<li>定时器思路</li>\n</ol>\n<h4 id=\"11-时间戳思路\"><a class=\"markdownIt-Anchor\" href=\"#11-时间戳思路\">#</a> 1.1 时间戳思路</h4>\n<p>顾名思义，通过两个时间戳来控制时间间隔，当触发事件的时候：</p>\n<ol>\n<li>我们取出当前的时间戳  <code>now</code> ；</li>\n<li>然后减去之前<strong>执行时</strong>的时间戳 (首次值为 0)  <code>prev</code> ；</li>\n<li>如果大 <code>now - prev &gt; wait</code> ，证明时间区间维护结束，执行指定事件，更新 <code>prev</code> ；</li>\n</ol>\n<p>根据这一思路，我们就可以实现第一版代码了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oWrapper.onmousemove = throttle(moveAction, 1000);</span><br><span class=\"line\">function throttle(func, wait) &#123;</span><br><span class=\"line\">    var _this, arg;</span><br><span class=\"line\">    var prev = 0; // 上一次触发的时间，第一次默认为0</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        var now = Date.now(); // 触发时的时间</span><br><span class=\"line\">        _this = this;</span><br><span class=\"line\">        if (now - prev &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(_this, arg); // 允许传入参数，并修正this</span><br><span class=\"line\">            prev = now; // 更新上一次触发的时间</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来看看借助它，效果是什么样的：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740552204-2bb5f2b1-3807-4d26-b3eb-d34e798ab60a.gif\" alt=\"\"></p>\n<p>我们可以看到：</p>\n<ol>\n<li>当鼠标移入的时候，<strong>事件立刻执行</strong></li>\n<li>每过 1s 会执行一次，且移动 2.5s 会执行 2 次，意味着动作<strong>停止后不会再执行</strong>。</li>\n</ol>\n<h4 id=\"12-定时器思路\"><a class=\"markdownIt-Anchor\" href=\"#12-定时器思路\">#</a> 1.2 定时器思路</h4>\n<p>利用定时器来保证间隔时间内事件的触发次数</p>\n<ol>\n<li>创建定时器 <code>timer</code> ，记录当前是否在<strong>周期</strong>内；</li>\n<li>判断定时器是否存在，若存在则直接结束，否则执行事件；</li>\n<li><code>wait</code>  时间之后再次执行，并清掉定时器；</li>\n</ol>\n<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait) &#123;</span><br><span class=\"line\">    var _this, arg;</span><br><span class=\"line\">    var timer; // 初始化</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        _this = this; // 记录this</span><br><span class=\"line\">        arg = arguments; // 记录参数数组</span><br><span class=\"line\">        if (timer) return; // 时候未到</span><br><span class=\"line\">        timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            func.apply(_this, arg); // 允许传入参数，并修正this</span><br><span class=\"line\">            timer = null;</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来看看借助它，效果是什么样的：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551861-12bc2cce-f80a-45ff-9913-7798160b3438.gif\" alt=\"\"></p>\n<p>但是，我们可以看到：</p>\n<ol>\n<li>当鼠标移入的时候，事件不会立刻执行；</li>\n<li>鼠标定制后 <code>wait</code>  间隔后会执行一次</li>\n</ol>\n<h4 id=\"13-两种思路的区别\"><a class=\"markdownIt-Anchor\" href=\"#13-两种思路的区别\">#</a> 1.3 两种思路的区别</h4>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>时间戳</th>\n<th>定时器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>“起点”</td>\n<td>立即执行</td>\n<td>n 秒后执行</td>\n</tr>\n<tr>\n<td>“终点”</td>\n<td>停止后不会执行</td>\n<td>停止会再执行一次</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"二-节流进阶\"><a class=\"markdownIt-Anchor\" href=\"#二-节流进阶\">#</a> 二、节流进阶</h3>\n<p>结合两种思想完成一个可以立即执行，且停止触发后再执行一次的节流方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第三版</span><br><span class=\"line\">function throttle(func, wait) &#123;</span><br><span class=\"line\">    var timeout, context, args, result;</span><br><span class=\"line\">    var previous = 0;</span><br><span class=\"line\">    var later = function() &#123;</span><br><span class=\"line\">        previous = +new Date();</span><br><span class=\"line\">        timeout = null;</span><br><span class=\"line\">        func.apply(context, args)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    var throttled = function() &#123;</span><br><span class=\"line\">        var now = +new Date();</span><br><span class=\"line\">        //下次触发 func 剩余的时间</span><br><span class=\"line\">        var remaining = wait - (now - previous);</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        args = arguments;</span><br><span class=\"line\">         // 如果没有剩余的时间了或者你改了系统时间</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            timeout = setTimeout(later, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果演示如下：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551783-4d2e4584-8e32-4ca2-a1de-c2ab865a882c.gif\" alt=\"\"></p>\n<p>我在看代码的时候，我是反复打印数据才理解为什么会这样做，一起加油～</p>\n",
            "tags": [
                "JavaScript专题",
                "javascript"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/03/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%8E%9F%E7%90%86/",
            "url": "https://gaoyuan.ink/2021/03/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%8E%9F%E7%90%86/",
            "title": "三次握手四次挥手的原理",
            "date_published": "2021-03-01T14:32:01.000Z",
            "content_html": "<h2 id=\"三次握手\"><a class=\"markdownIt-Anchor\" href=\"#三次握手\">#</a> 三次握手</h2>\n<p>握手的过程：</p>\n<p>1、第一次握手：客户端给服务器发送一个 SYN 报文。</p>\n<p>2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。</p>\n<p>3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。</p>\n<p>4、服务器收到 ACK 报文之后，三次握手建立完成。</p>\n<p>作用是为了确认双方的接收与发送能力是否正常。</p>\n   <span id=\"more\"></span>\n<p><strong>这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：</strong></p>\n<blockquote>\n<p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>\n第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>\n第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>\n</blockquote>\n<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>\n<p>这样回答其实也是可以的，但我觉得，这个过程的我们应该要描述的更<strong>详细一点</strong>，因为三次握手的过程中，双方是<strong>由很多状态的改变的</strong>，而这些状态，也是面试官可能会问的点。所以我觉得在回答三次握手的时候，我们应该要描述的详细一点，而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：</p>\n<p><strong>刚开始客户端处于 closed 的状态，服务端处于 listen 状态</strong>。然后<br>\n 1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 <strong>ISN（c）</strong>。此时客户端处于 <strong>SYN_Send</strong> 状态。</p>\n<p>2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN (s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p>\n<p>3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p>\n<p>4、服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了链接。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/2019060815530363.png\" alt=\"\"></p>\n<h3 id=\"1-三次握手的作用\"><a class=\"markdownIt-Anchor\" href=\"#1-三次握手的作用\">#</a> 1、三次握手的作用</h3>\n<p>三次握手的作用也是有好多的，多记住几个，保证不亏。例如：<br>\n1、确认双方的接受能力、发送能力是否正常。<br>\n2、指定自己的初始化序列号，为后面的可靠传送做准备。<br>\n3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>\n<h3 id=\"2-isn是固定的吗\"><a class=\"markdownIt-Anchor\" href=\"#2-isn是固定的吗\">#</a> 2、（ISN）是固定的吗？</h3>\n<p>三次握手的一个重要功能是客户端和服务端交换 ISN (Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>\n<p><strong>如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</strong></p>\n<h3 id=\"3-什么是半连接队列\"><a class=\"markdownIt-Anchor\" href=\"#3-什么是半连接队列\">#</a> 3、什么是半连接队列</h3>\n<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>\n<blockquote>\n<p>这里在补充一点关于 SYN-ACK 重传次数的问题：　服务器发送完 SYN－ACK 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, …</p>\n</blockquote>\n<h3 id=\"4-三次握手过程中可以携带数据吗\"><a class=\"markdownIt-Anchor\" href=\"#4-三次握手过程中可以携带数据吗\">#</a> 4、三次握手过程中可以携带数据吗</h3>\n<p>很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>\n<p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。<br>\n而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p>\n<h2 id=\"四次挥手\"><a class=\"markdownIt-Anchor\" href=\"#四次挥手\">#</a> 四次挥手</h2>\n<p><strong>四次挥手也一样，千万不要对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。然后结束，最好是说的详细一点，例如想下面这样就差不多了，要把每个阶段的状态记好。</strong></p>\n<p>刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：</p>\n<p>1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong> FIN_WAIT1</strong> 状态。</p>\n<p>2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong> 状态。</p>\n<p>3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</p>\n<p>4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p>\n<p>5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190608160051238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtaXNwb3NzaWJsZQ==,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<p>这里特别需要主要的就是 TIME_WAIT 这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p>\n<p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>\n<p><strong>这里我给出每个状态所包含的含义，有兴趣的可以看看。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LISTEN - 侦听来自远方TCP端口的连接请求； </span><br><span class=\"line\">SYN-SENT -在发送连接请求后等待匹配的连接请求； </span><br><span class=\"line\">SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； </span><br><span class=\"line\">ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； </span><br><span class=\"line\">FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</span><br><span class=\"line\">FIN-WAIT-2 - 从远程TCP等待连接中断请求；</span><br><span class=\"line\">CLOSE-WAIT - 等待从本地用户发来的连接中断请求； </span><br><span class=\"line\">CLOSING -等待远程TCP对连接中断的确认； </span><br><span class=\"line\">LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； </span><br><span class=\"line\">TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； </span><br><span class=\"line\">CLOSED - 没有任何连接状态；</span><br></pre></td></tr></table></figure>\n<p><strong>最后，在放张三次握手与四次挥手的图</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190608160404569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtaXNwb3NzaWJsZQ==,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n",
            "tags": [
                "HTTP",
                "HTTP"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/02/20/VUE%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%846%E7%A7%8D%E6%96%B9%E5%BC%8F/",
            "url": "https://gaoyuan.ink/2021/02/20/VUE%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%846%E7%A7%8D%E6%96%B9%E5%BC%8F/",
            "title": "VUE组件之间通信的6种方式",
            "date_published": "2021-02-20T02:01:48.000Z",
            "content_html": "<h3 id=\"1方法一props和emit\"><a class=\"markdownIt-Anchor\" href=\"#1方法一props和emit\">#</a> 1. 方法一：<strong>props</strong> 和 **$emit**</h3>\n<p>父组件通过 props 向下传递数据给子组件，子组件通过 event 给父组件发送消息，实际上就是子组件把自己的数据发送给父组件。</p>\n<h3 id=\"2方法二attrs和listeners\"><a class=\"markdownIt-Anchor\" href=\"#2方法二attrs和listeners\">#</a> 2. 方法二：<strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>r</mi><mi>s</mi><mo>∗</mo><mo>∗</mo><mtext>和</mtext><mo>∗</mo><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">attrs**和**</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">∗</span><span class=\"mord cjk_fallback\">和</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord\">∗</span></span></span></span>listeners</strong></h3>\n<p>​\t第一种方式处理父子组件之间的数据传输有一个问题：如果父组件 A 下面有子组件 B，组件 B 下面有组件 C, 这时如果组件 A 想传递数据给组件 C 怎么办呢？ 如果采用第一种方法，我们必须让组件 A 通过 prop 传递消息给组件 B，组件 B 在通过 prop 传递消息给组件 C；要是组件 A 和组件 C 之间有更多的组件，那采用这种方式就很复杂了。Vue 2.4 开始提供了<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>r</mi><mi>s</mi><mtext>和</mtext></mrow><annotation encoding=\"application/x-tex\">attrs和</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">s</span><span class=\"mord cjk_fallback\">和</span></span></span></span> listeners 来解决这个问题，能够让组件 A 之间传递消息给组件 C。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--组件C--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; v-model=&quot;$attrs.messagec&quot; @input=&quot;passCData($attrs.messagec)&quot;&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">    name: &#x27;C&#x27;,</span><br><span class=\"line\">    data () &#123;</span><br><span class=\"line\">      return &#123;&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods:&#123;</span><br><span class=\"line\">      passCData(val)&#123;</span><br><span class=\"line\">        //触发父组件A中的事件,把从A得到的数据hello C还给A组件</span><br><span class=\"line\">        this.$emit(&#x27;getCData&#x27;,val)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--组件B--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt;</span><br><span class=\"line\">    &lt;!-- C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 --&gt;</span><br><span class=\"line\">    &lt;!-- 通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） --&gt;</span><br><span class=\"line\">    &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">    name: &#x27;B&#x27;,</span><br><span class=\"line\">    props:[</span><br><span class=\"line\">      message:&#123;</span><br><span class=\"line\">        type: String,</span><br><span class=\"line\">        default: null</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],//得到父组件A传递过来的数据,hello B</span><br><span class=\"line\">    methods:&#123;</span><br><span class=\"line\">      passData(val)&#123;</span><br><span class=\"line\">        //触发父组件中的事件,把message给组件A</span><br><span class=\"line\">        this.$emit(&#x27;getChildData&#x27;,val)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--组件A--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">    &lt;p&gt;this is parent compoent!&lt;/p&gt;</span><br><span class=\"line\">    &lt;B </span><br><span class=\"line\">     :messagec=&quot;messagec&quot; </span><br><span class=\"line\">     :message=&quot;message&quot; </span><br><span class=\"line\">     :getCData=&quot;getCData&quot;</span><br><span class=\"line\">     :getChildData=&quot;getChildData&quot;&gt;&lt;/B&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">    name: &#x27;A&#x27;,</span><br><span class=\"line\">    data()&#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        message:&#x27;hello B&#x27;,</span><br><span class=\"line\">        messagec:&#x27;hello C&#x27; //传递给c组件的数据</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods:&#123;</span><br><span class=\"line\">      getChildData(val)&#123;</span><br><span class=\"line\">        console.log(&#x27;这是来自B组件的数据&#x27;,val) //打印hello B</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      //执行C子组件触发的事件</span><br><span class=\"line\">      getCData(val)&#123;</span><br><span class=\"line\">        console.log(&quot;这是来自C组件的数据：&quot;, val) //打印hello C</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3方法3provide和-inject\"><a class=\"markdownIt-Anchor\" href=\"#3方法3provide和-inject\">#</a> 3. 方法 3：<strong>provide</strong> 和 <strong>inject</strong></h3>\n<p>在 Vue.js 的  <code>2.2.0+</code>  版本中添加加了 provide 和 inject 选项。他们成对出现，用于父级组件向下传递数据。</p>\n<p>父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。不论子组件有多深，只要调用了 inject 那么就可以注入 provide 中的数据。而不是局限于只能从当前父组件的 prop 属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--父组件--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;p&gt;this is parent compoent!&lt;/p&gt;</span><br><span class=\"line\">    &lt;child&gt;&lt;/child&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">    name: &#x27;parent&#x27;,</span><br><span class=\"line\">    provide: &#123;</span><br><span class=\"line\">      forChidrenData:&#x27;这是要个子组件的数据&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    data()&#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        message:&#x27;hello&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--子组件--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot;&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">    name: &#x27;child&#x27;,</span><br><span class=\"line\">    inject:[&#x27;forChidrenData&#x27;], //得到父组件传递过来的数据</span><br><span class=\"line\">    provide: &#123;</span><br><span class=\"line\">      forChidrenData:&#x27;这是要个子组件的数据&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    data()&#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        mymessage:this.forChidrenData</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4方法四vuex处理组件之间的数据交互\"><a class=\"markdownIt-Anchor\" href=\"#4方法四vuex处理组件之间的数据交互\">#</a> 4. 方法四：<strong>vuex 处理组件之间的数据交互</strong></h3>\n<p>​\t如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex 的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>\n<h3 id=\"5方法五中央事件总线\"><a class=\"markdownIt-Anchor\" href=\"#5方法五中央事件总线\">#</a> 5. 方法五：<strong>中央事件总线</strong></h3>\n<p>​\t如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个 Vue 事件 bus 对象，然后通过 bus.<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mtext>触发事件，</mtext><mi>b</mi><mi>u</mi><mi>s</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">emit触发事件，bus.</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mord cjk_fallback\">触</span><span class=\"mord cjk_fallback\">发</span><span class=\"mord cjk_fallback\">事</span><span class=\"mord cjk_fallback\">件</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">s</span><span class=\"mord\">.</span></span></span></span>on 监听触发的事件。</p>\n<blockquote>\n<p>公共事件总线 eventBus 的实质就是创建一个 vue 实例，通过一个空的 vue 实例作为桥梁实现 vue 组件间的通信。它是实现非父子组件通信的一种解决方案。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--兄弟组件A--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;p&gt;this is brother1 compoent!&lt;/p&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">    name: &#x27;brother1&#x27;,</span><br><span class=\"line\">    data()&#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        mymessage:&#x27;hello brother1&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods:&#123;</span><br><span class=\"line\">      passData(val)&#123;</span><br><span class=\"line\">        //触发全局事件globalEvent</span><br><span class=\"line\">        bus.$emit(&#x27;globalEvent&#x27;, val)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--兄弟组件B--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;p&gt;this is brother2 compoent!&lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">    name: &#x27;brother2&#x27;,</span><br><span class=\"line\">    data()&#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">        brothermessage:&#x27;&#x27;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    mounted()&#123;</span><br><span class=\"line\">      //绑定全局事件globalEvent</span><br><span class=\"line\">      bus.$on(&#x27;globalEvent&#x27;,(val)=&gt;&#123;</span><br><span class=\"line\">        this.brothermessage = val;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//中央事件总线</span><br><span class=\"line\">var bus=new Vue();</span><br><span class=\"line\">var app=new Vue(&#123;</span><br><span class=\"line\">  el:&#x27;#app&#x27;,</span><br><span class=\"line\">  template:`</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;brother1&gt;&lt;/brother1&gt;</span><br><span class=\"line\">      &lt;brother2&gt;&lt;/brother2&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `,</span><br><span class=\"line\">   beforeDestroy()&#123;</span><br><span class=\"line\">sd     bus.$off(&#x27;globalEvent&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"6方法六parent和children\"><a class=\"markdownIt-Anchor\" href=\"#6方法六parent和children\">#</a> 6. 方法六：<strong><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>∗</mo><mo>∗</mo><mtext>和</mtext><mo>∗</mo><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">parent**和**</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">∗</span><span class=\"mord cjk_fallback\">和</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord\">∗</span></span></span></span>children</strong></h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;child&#x27;,&#123;</span><br><span class=\"line\">  props:&#123;</span><br><span class=\"line\">    value:String, //v-model会自动传递一个字段为value的prop属性</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data()&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      mymessage:this.value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    changeValue()&#123;</span><br><span class=\"line\">      this.$parent.message = this.mymessage;//通过如此调用可以改变父组件的值</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template:`</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @change=&quot;changeValue&quot;&gt;</span><br><span class=\"line\">    &lt;/div&gt;`</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">Vue.component(&#x27;parent&#x27;,&#123;</span><br><span class=\"line\">  template:`</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;this is parent compoent!&lt;/p&gt;</span><br><span class=\"line\">      &lt;button @click=&quot;changeChildValue&quot;&gt;test&lt;/button &gt;</span><br><span class=\"line\">      &lt;child&gt;&lt;/child&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">    changeChildValue()&#123;</span><br><span class=\"line\">      this.$children[0].mymessage = &#x27;hello&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data()&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      message:&#x27;hello&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">var app=new Vue(&#123;</span><br><span class=\"line\">  el:&#x27;#app&#x27;,</span><br><span class=\"line\">  template:`</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;parent&gt;&lt;/parent&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Vue专题",
                "vue"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2021/02/11/JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/",
            "url": "https://gaoyuan.ink/2021/02/11/JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/",
            "title": "JS实现图片压缩",
            "date_published": "2021-02-11T01:19:04.000Z",
            "content_html": "<blockquote>\n<p>说起图片压缩，大家想到的或者平时用到的很多工具都可以实现，例如，客户端类的有图片压缩工具 PPDuck3， JS 实现类的有插件 compression.js ，亦或是在线处理类的 OSS 上传，文件上传后，在访问文件时中也有图片的压缩配置选项，那能不能使用 JS 实现的图片压缩代码呢？当然可以，那我们先来理一下思路。</p>\n</blockquote>\n<h2 id=\"压缩思路\"><a class=\"markdownIt-Anchor\" href=\"#压缩思路\">#</a> 压缩思路</h2>\n<p>涉及到 JS 的图片压缩，我的想法是需要用到 Canvas 的绘图能力，通过调整图片的分辨率或者绘图质量来达到图片压缩的效果，实现思路如下：</p>\n<ul>\n<li>获取上传 Input 中的图片对象 File</li>\n<li>将图片转换成 base64 格式</li>\n<li>base64 编码的图片通过 Canvas 转换压缩，这里会用到的 Canvas 的 drawImage 以及 toDataURL 这两个 Api，一个调节图片的分辨率的，一个是调节图片压缩质量并且输出的，后续会有详细介绍</li>\n<li>转换后的图片生成对应的新图片，然后输出</li>\n<li></li>\n</ul>\n<h2 id=\"优缺点介绍\"><a class=\"markdownIt-Anchor\" href=\"#优缺点介绍\">#</a> 优缺点介绍</h2>\n<p>不过 Canvas 压缩的方式也有着自己的优缺点：</p>\n<ul>\n<li>优点：实现简单，参数可以配置化，自定义图片的尺寸，指定区域裁剪等等。</li>\n<li>缺点：只有 jpeg 、webp 支持原图尺寸下图片质量的调整来达到压缩图片的效果，其他图片格式，仅能通过调节尺寸来实现</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;file&quot; id=&quot;input-img&quot; @change=&quot;compress&quot; /&gt;</span><br><span class=\"line\">    &lt;a :download=&quot;fileName&quot; :href=&quot;compressImg&quot; &gt;普通下载&lt;/a&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;downloadImg&quot;&gt;兼容 IE 下载&lt;/button&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;img :src=&quot;compressImg&quot; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;export default &#123;</span><br><span class=\"line\">  name: &#x27;compress&#x27;,</span><br><span class=\"line\">  data: function() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      compressImg: null,</span><br><span class=\"line\">      fileName: null,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;&#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    compress() &#123;</span><br><span class=\"line\">      // 获取文件对象</span><br><span class=\"line\">      const fileObj = document.querySelector(&#x27;#input-img&#x27;).files[0];</span><br><span class=\"line\">      // 获取文件名称，后续下载重命名</span><br><span class=\"line\">      this.fileName = `$&#123;new Date().getTime()&#125;-$&#123;fileObj.name&#125;`;</span><br><span class=\"line\">      // 获取文件后缀名</span><br><span class=\"line\">      const fileNames = fileObj.name.split(&#x27;.&#x27;);</span><br><span class=\"line\">      const type = fileNames[fileNames.length-1];</span><br><span class=\"line\">      // 压缩图片</span><br><span class=\"line\">      this.handleCompressImage(fileObj, type);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleCompressImage(img, type) &#123;</span><br><span class=\"line\">      const vm = this;</span><br><span class=\"line\">      let reader = new FileReader();</span><br><span class=\"line\">      // 读取文件</span><br><span class=\"line\">      reader.readAsDataURL(img);</span><br><span class=\"line\">      reader.onload = function(e) &#123;</span><br><span class=\"line\">        let image = new Image(); //新建一个img标签</span><br><span class=\"line\">        image.src = e.target.result;</span><br><span class=\"line\">        image.onload = function() &#123;</span><br><span class=\"line\">          let canvas = document.createElement(&#x27;canvas&#x27;);</span><br><span class=\"line\">          let context = canvas.getContext(&#x27;2d&#x27;);</span><br><span class=\"line\">          // 定义 canvas 大小，也就是压缩后下载的图片大小</span><br><span class=\"line\">          let imageWidth = image.width; //压缩后图片的大小</span><br><span class=\"line\">          let imageHeight = image.height;</span><br><span class=\"line\">          canvas.width = imageWidth;</span><br><span class=\"line\">          canvas.height = imageHeight;</span><br><span class=\"line\">          </span><br><span class=\"line\">          // 图片不压缩，全部加载展示</span><br><span class=\"line\">          context.drawImage(image, 0, 0);</span><br><span class=\"line\">          // 图片按压缩尺寸载入</span><br><span class=\"line\">          // let imageWidth = 500; //压缩后图片的大小</span><br><span class=\"line\">          // let imageHeight = 200;</span><br><span class=\"line\">          // context.drawImage(image, 0, 0, 500, 200);</span><br><span class=\"line\">          // 图片去截取指定位置载入</span><br><span class=\"line\">          // context.drawImage(image,100, 100, 100, 100, 0, 0, imageWidth, imageHeight);</span><br><span class=\"line\">          vm.compressImg = canvas.toDataURL(`image/$&#123;type&#125;`);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // base64 图片转 blob 后下载</span><br><span class=\"line\">    downloadImg() &#123;</span><br><span class=\"line\">      let parts = this.compressImg.split(&#x27;;base64,&#x27;);</span><br><span class=\"line\">      let contentType = parts[0].split(&#x27;:&#x27;)[1];</span><br><span class=\"line\">      let raw = window.atob(parts[1]);</span><br><span class=\"line\">      let rawLength = raw.length;</span><br><span class=\"line\">      let uInt8Array = new Uint8Array(rawLength);</span><br><span class=\"line\">      for(let i = 0; i &lt; rawLength; ++i) &#123;</span><br><span class=\"line\">        uInt8Array[i] = raw.charCodeAt(i);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      const blob = new Blob([uInt8Array], &#123;type: contentType&#125;);</span><br><span class=\"line\">      this.compressImg = URL.createObjectURL(blob);</span><br><span class=\"line\">      if (window.navigator.msSaveOrOpenBlob) &#123;</span><br><span class=\"line\">        // 兼容 ie 的下载方式</span><br><span class=\"line\">        window.navigator.msSaveOrOpenBlob(blob, this.fileName);</span><br><span class=\"line\">      &#125;else&#123;</span><br><span class=\"line\">        const a = document.createElement(&#x27;a&#x27;);</span><br><span class=\"line\">        a.href = this.compressImg;</span><br><span class=\"line\">        a.setAttribute(&#x27;download&#x27;, this.fileName);</span><br><span class=\"line\">        a.click();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现步骤\"><a class=\"markdownIt-Anchor\" href=\"#实现步骤\">#</a> 实现步骤</h2>\n<blockquote>\n<p>上面的代码是可以直接拿来看效果的，不喜欢用 Vue 的也可以把代码稍微调整一下，下面开始具体分解一下代码的实现思路</p>\n</blockquote>\n<h3 id=\"步骤一input-上传-file-处理\"><a class=\"markdownIt-Anchor\" href=\"#步骤一input-上传-file-处理\">#</a> 步骤一：Input 上传 File 处理</h3>\n<p>将 File 对象通过  <code>FileReader</code>  的  <code>readAsDataURL</code>  方法转换为 URL 格式的字符串（base64 编码）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fileObj = document.querySelector(&#x27;#input-img&#x27;).files[0];</span><br><span class=\"line\">let reader = new FileReader();</span><br><span class=\"line\">// 读取文件</span><br><span class=\"line\">reader.readAsDataURL(fileObj);</span><br></pre></td></tr></table></figure>\n<h2 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h2>\n<h3 id=\"步骤二canvas-处理-file-对象\"><a class=\"markdownIt-Anchor\" href=\"#步骤二canvas-处理-file-对象\">#</a> 步骤二：Canvas 处理 File 对象</h3>\n<p>建立一个  <code>Image</code>  对象，一个  <code>canvas</code>  画布，设定自己想要下载的图片尺寸，调用  <code>drawImage</code>  方法在 canvas 中绘制上传的图片</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let image = new Image(); //新建一个img标签</span><br><span class=\"line\">image.src = e.target.result;</span><br><span class=\"line\">let canvas = document.createElement(&#x27;canvas&#x27;);</span><br><span class=\"line\">let context = canvas.getContext(&#x27;2d&#x27;);</span><br><span class=\"line\">context.drawImage(image, 0, 0);</span><br></pre></td></tr></table></figure>\n<h3 id=\"步骤三api-解析drawimage\"><a class=\"markdownIt-Anchor\" href=\"#步骤三api-解析drawimage\">#</a> 步骤三：Api 解析：drawImage</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure>\n<p>**img:** 就是图片对象，可以是页面上获取的 DOM 对象，也可以是虚拟 DOM 中的图片对象。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1598786576273-20cc4996-634f-4a19-8fb8-68262d4313b0.webp\" alt=\"\"></p>\n<p><strong>（1）dx、dy、dWidth、dHeight：</strong></p>\n<p>表示在  <code>canvas</code>  画布上规划出一片区域用来放置图片， <code>dx, dy</code>  为绘图位置在 Canvas 元素的 X 轴、Y 轴坐标， <code>dWidth, dHeight</code>  指在 Canvas 元素上绘制图像的宽度和高度（如果不说明， 在绘制时图片的宽度和高度不会缩放）。</p>\n<p><strong>（2）sx、sy、swidth、sheight:</strong></p>\n<p>这 4 个参数是用来裁剪源图片的，表示图片在  <code>canvas</code>  画布上显示的大小和位置。 <code>sx, sy</code>  表示在源图片上裁剪位置的 X 轴、Y 轴坐标，然后以  <code>swidth, sheight</code>  尺寸来选择一个区域范围，裁剪出来的图片作为最终在 Canvas 上显示的图片内容（  <code>swidth, sheight</code>  不说明的情况下，整个矩形（裁剪）从坐标的  <code>sx</code>  和  <code>sy</code>  开始，到图片的右下角结束）。</p>\n<p>以下为图片绘制的实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.drawImage(image, 0, 0, 100, 100);</span><br><span class=\"line\">context.drawImage(image, 300, 300, 200, 200);</span><br><span class=\"line\">context.drawImage(image, 0, 100, 150, 150, 300, 0, 150, 150);</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1598786576278-66f315b0-3c36-45b3-825d-c8f3171672e1.webp\" alt=\"\"></p>\n<p>Api 中奇怪之处在于，sx、sy、swidth、sheight 为选填参数，但位置在 dx、dy、dWidth、dHeight 之前。</p>\n<h3 id=\"步骤四canvas-输出图片\"><a class=\"markdownIt-Anchor\" href=\"#步骤四canvas-输出图片\">#</a> 步骤四：Canvas 输出图片</h3>\n<p>调用  <code>canvas</code>  的  <code>toDataURL</code>  方法可以输出 base64 格式的图片。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.toDataURL(`image/$&#123;type&#125;`);</span><br></pre></td></tr></table></figure>\n<h3 id=\"步骤五api-解析todataurl\"><a class=\"markdownIt-Anchor\" href=\"#步骤五api-解析todataurl\">#</a> 步骤五：Api 解析：toDataURL</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.toDataURL(type, encoderOptions);</span><br></pre></td></tr></table></figure>\n<p>**type （可选）：** 图片格式，默认为 image/png。</p>\n<p>**encoderOptions （可选）：** 在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。</p>\n<p><strong>a 标签的下载</strong>：调用  <code>&lt;a&gt;</code>  标签的  <code>download</code>  属性，即可完成图片的下载。</p>\n<h3 id=\"步骤六api-解析download\"><a class=\"markdownIt-Anchor\" href=\"#步骤六api-解析download\">#</a> 步骤六：Api 解析：download</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// href 下载必填</span><br><span class=\"line\">&lt;a download=&quot;filename&quot; href=&quot;href&quot;&gt; 下载 &lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>**filename：** 选填，规定作为文件名来使用的文本。</p>\n<p>**href：** 文件的下载地址。</p>\n<h3 id=\"步骤七非主流浏览器下载处理\"><a class=\"markdownIt-Anchor\" href=\"#步骤七非主流浏览器下载处理\">#</a> 步骤七：非主流浏览器下载处理</h3>\n<p>这一步可以解决 Chroma 、 Firefox 和 Safari（自测支持） 浏览器的下载功能，因为 IE 等浏览器不支持  <code>download</code>  属性，所以需要进行其他方式的下载，也就有了代码中的后续内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// base64 图片转 blob 后下载</span><br><span class=\"line\">downloadImg() &#123;</span><br><span class=\"line\">  let parts = this.compressImg.split(&#x27;;base64,&#x27;);</span><br><span class=\"line\">  let contentType = parts[0].split(&#x27;:&#x27;)[1];</span><br><span class=\"line\">  let raw = window.atob(parts[1]);</span><br><span class=\"line\">  let rawLength = raw.length;</span><br><span class=\"line\">  let uInt8Array = new Uint8Array(rawLength);</span><br><span class=\"line\">  for(let i = 0; i &lt; rawLength; ++i) &#123;</span><br><span class=\"line\">    uInt8Array[i] = raw.charCodeAt(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const blob = new Blob([uInt8Array], &#123;type: contentType&#125;);</span><br><span class=\"line\">  this.compressImg = URL.createObjectURL(blob);</span><br><span class=\"line\">  if (window.navigator.msSaveOrOpenBlob) &#123;</span><br><span class=\"line\">    // 兼容 ie 的下载方式</span><br><span class=\"line\">    window.navigator.msSaveOrOpenBlob(blob, this.fileName);</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    const a = document.createElement(&#x27;a&#x27;);</span><br><span class=\"line\">    a.href = this.compressImg;</span><br><span class=\"line\">    a.setAttribute(&#x27;download&#x27;, this.fileName);</span><br><span class=\"line\">    a.click();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>将之前  <code>canvas</code>  生成的 base64 数据拆分后，通过  <code>atob</code>  方法解码</li>\n<li>将解码后的数据转换成 Uint8Array 格式的无符号整形数组</li>\n<li>转换后的数组来生成一个 Blob 数据对象，通过  <code>URL.createObjectURL(blob)</code>  来生成一个临时的 DOM 对象</li>\n<li>之后 IE 类浏览器可以调用  <code>window.navigator.msSaveOrOpenBlob</code>  方法来执行下载，其他浏览器也可以继续通过  <code>&lt;a&gt;</code>  标签的  <code>download</code>  属性来进行下载</li>\n</ul>\n<h3 id=\"步骤八api-解析atob\"><a class=\"markdownIt-Anchor\" href=\"#步骤八api-解析atob\">#</a> 步骤八：Api 解析：atob</h3>\n<p>base-64 解码使用方法是 atob ()。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.atob(encodedStr)</span><br></pre></td></tr></table></figure>\n<p>**encodedStr：** 必需，是一个通过 btoa () 方法编码的字符串，btoa () 是 base64 编码的使用方法。</p>\n<h3 id=\"步骤九api-解析uint8array\"><a class=\"markdownIt-Anchor\" href=\"#步骤九api-解析uint8array\">#</a> 步骤九：Api 解析：Uint8Array</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Uint8Array(length)</span><br></pre></td></tr></table></figure>\n<p>**length：** 创建初始化为 0 的，包含 length 个元素的无符号整型数组。</p>\n<h3 id=\"步骤十api-解析blob\"><a class=\"markdownIt-Anchor\" href=\"#步骤十api-解析blob\">#</a> 步骤十：Api 解析：Blob</h3>\n<p><code>Blob</code>  对象表示一个不可变、原始数据的类文件对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 构造函数允许通过其它对象创建 Blob 对象</span><br><span class=\"line\">new Blob([obj],&#123;type:createType&#125;)</span><br></pre></td></tr></table></figure>\n<p>**obj：** 字符串内容</p>\n<p>**createType：** 要构造的类型，兼容性 IE 10 以上</p>\n<h3 id=\"步骤十一api-解析createobjecturl\"><a class=\"markdownIt-Anchor\" href=\"#步骤十一api-解析createobjecturl\">#</a> 步骤十一：Api 解析：createObjectURL</h3>\n<p>静态方法会创建一个 DOMString。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objectURL = URL.createObjectURL(object);</span><br></pre></td></tr></table></figure>\n<p>**object：** 用于创建 URL 的 File 对象、Blob 对象或者 MediaSource 对象。</p>\n<h3 id=\"步骤十二api-解析windownavigator\"><a class=\"markdownIt-Anchor\" href=\"#步骤十二api-解析windownavigator\">#</a> 步骤十二：Api 解析：window.navigator</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 官方已不建议使用的文件下载方式，仅针对 ie 且兼容性 10 以上</span><br><span class=\"line\">// msSaveBlob 仅提供下载</span><br><span class=\"line\">// msSaveOrOpenBlob 支持下载和打开</span><br><span class=\"line\">window.navigator.msSaveOrOpenBlob(blob, fileName);</span><br></pre></td></tr></table></figure>\n<p>**blob：** 要下载的 blob 对象</p>\n<p>**fileName：** 下载后命名的文件名称。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>本方法仅针对图片压缩介绍了一些思路，简单的使用场景可能如下介绍，当然也会引申出来更多的使用场景，这些还有待大家一起挖掘。</p>\n<ul>\n<li>上传存储图片如果需要对文件大小格式有要求的，可以统一压缩处理图片</li>\n<li>前台页面想要编辑图片，可以在 Canvas 处理图片的时候，加一些其他逻辑，例如添加文字，剪裁，拼图等等操作</li>\n</ul>\n<p>tip：因部分接口有 IE 兼容性问题，IE 浏览器方面，仅能支持 IE 10 以上版本进行下载。</p>\n",
            "tags": [
                "JavaScript专题",
                "javascript"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2020/12/26/vuex%E7%AC%94%E8%AE%B0/",
            "url": "https://gaoyuan.ink/2020/12/26/vuex%E7%AC%94%E8%AE%B0/",
            "title": "vuex笔记",
            "date_published": "2020-12-26T13:43:23.000Z",
            "content_html": "<h1 id=\"vuex笔记\"><a class=\"markdownIt-Anchor\" href=\"#vuex笔记\">#</a> Vuex 笔记</h1>\n<h3 id=\"vuex概述\"><a class=\"markdownIt-Anchor\" href=\"#vuex概述\">#</a> Vuex 概述</h3>\n<h4 id=\"vuex是什么\"><a class=\"markdownIt-Anchor\" href=\"#vuex是什么\">#</a> vuex 是什么</h4>\n<p>​\tvuex 是实现组件全局状态（数据）管理的一种机制，可以方便实现组件之间数据的共享<br>\n<img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/image-20201221091304337.png\" alt=\"\"></p>\n<span id=\"more\"></span>\n<h4 id=\"使用vuex统一管理状态的好处\"><a class=\"markdownIt-Anchor\" href=\"#使用vuex统一管理状态的好处\">#</a> 使用 Vuex 统一管理状态的好处</h4>\n<ul>\n<li>能够在 vuex 中集中管理共享的数据，易于开发和后期维护</li>\n<li>能够高效地实现组件之间的数据共享，提高开发效率</li>\n<li>存储在 Vuex 中的数据都是响应式的，能够实施保持数据与页面的同步</li>\n</ul>\n<h4 id=\"什么样的数据适合存储到vuex中\"><a class=\"markdownIt-Anchor\" href=\"#什么样的数据适合存储到vuex中\">#</a> 什么样的数据适合存储到 Vuex 中</h4>\n<p>​\t一般情况下，只有组件之间共享的数据，才有必要存储到 vuex 中；对于组件中的私有数据，依旧存储在组件自身的 data 中即可</p>\n<h3 id=\"vuex的基本使用\"><a class=\"markdownIt-Anchor\" href=\"#vuex的基本使用\">#</a> vuex 的基本使用</h3>\n<h4 id=\"安装vuex依赖\"><a class=\"markdownIt-Anchor\" href=\"#安装vuex依赖\">#</a> 安装 vuex 依赖</h4>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">npm</span> install vex --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"导入vuex包\"><a class=\"markdownIt-Anchor\" href=\"#导入vuex包\">#</a> 导入 vuex 包</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建store对象\"><a class=\"markdownIt-Anchor\" href=\"#创建store对象\">#</a> 创建 store 对象</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.store(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// state中存放的就是全局共享的数据</span></span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"将store对象挂载到vue实例中\"><a class=\"markdownIt-Anchor\" href=\"#将store对象挂载到vue实例中\">#</a> 将 store 对象挂载到 vue 实例中</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">reader</span>: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(app),</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  <span class=\"comment\">// 将创建的共享数据对象，挂载到vue实例中</span></span><br><span class=\"line\">  <span class=\"comment\">// 所有的组件，就可以直接从store中获取全局的数据了</span></span><br><span class=\"line\">  store</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"核心概念概述\"><a class=\"markdownIt-Anchor\" href=\"#核心概念概述\">#</a> 核心概念概述</h3>\n<blockquote>\n<p>vuex 中的主要核心概念如下：</p>\n<ul>\n<li><strong>state</strong></li>\n<li><strong>Mutation</strong></li>\n<li><strong>Action</strong></li>\n<li><strong>Getter</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"state\"><a class=\"markdownIt-Anchor\" href=\"#state\">#</a> State</h4>\n<p>​\tState 提供唯一的公共数据源，所有的共享的数据都要统一放到 Store 的 State 中进行储存</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建store数据源，提供唯一公共数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.store(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">count</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>（1）组件访问 State 中数据的第一种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.state.全局数据名称</span><br></pre></td></tr></table></figure>\n<p>（2）组件访问 State 中数据的第二种方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.从vuex中按需导入 mapState函数</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过刚刚导入的 mapState 函数，将当前组件需要的全局数据，映射为当前数据的 computed 计算属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2.将全局数据，映射为当前组件的计算属性</span></span><br><span class=\"line\"><span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">\t...mapState([<span class=\"string\">&#x27;count&#x27;</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"mutation\"><a class=\"markdownIt-Anchor\" href=\"#mutation\">#</a> Mutation</h4>\n<p>Mutation 用于变更 Store 中的数据</p>\n<ol>\n<li>\n<p>只能通过 mutation 变更 Store 数据，不可以直接操作 Store 中的数据</p>\n</li>\n<li>\n<p>通过这种方式虽然操作起来稍微繁琐一些，但是可以集中件套所有数据的变化</p>\n</li>\n</ol>\n<h5 id=\"定义mutations\"><a class=\"markdownIt-Anchor\" href=\"#定义mutations\">#</a> 定义 mutations</h5>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义Mutation</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">count</span>: <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//变更状态</span></span><br><span class=\"line\">\t\t\tstate.count++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h5 id=\"触发mutations\"><a class=\"markdownIt-Anchor\" href=\"#触发mutations\">#</a> 触发 mutations</h5>\n<p>（1）触发 mutations 的第一种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 触发mutation</span></span><br><span class=\"line\"><span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">handle1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//\t触发mutation的第一种方式</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&#x27;add&#x27;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以在触发 mutations 时传递参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义Mutation</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">count</span>: <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"attr\">mutations</span>: &#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"title\">addN</span>(<span class=\"params\">state, step</span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//变更状态</span></span><br><span class=\"line\">\t\t\tstate.count += step</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发mutation</span></span><br><span class=\"line\"><span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">handle1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//\t触发mutation的第一种方式</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&#x27;addN&#x27;</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）触发 mutations 第二种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.从vuex中按需导入mapMutations函数</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过刚才导入的 mapMuntations 函数，将需要的 mutations 函数，映射为当前组件的 methods 方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2.将指定的mutations函数，映射为当前组件的methods函数</span></span><br><span class=\"line\"><span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">\t...mapMutations([<span class=\"string\">&#x27;add&#x27;</span>,<span class=\"string\">&#x27;addN&#x27;</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"action\"><a class=\"markdownIt-Anchor\" href=\"#action\">#</a> Action</h4>\n<blockquote>\n<p>Action 用于处理异步任务</p>\n</blockquote>\n<p>如果通过异步操作变更数据，必须通过 Action，而不能使用 Mutation，但是在 Action 中还是要通过出发 Mutation 的方式间接变更数据。</p>\n<h5 id=\"定义action\"><a class=\"markdownIt-Anchor\" href=\"#定义action\">#</a> 定义 Action</h5>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义Action</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// ...此处省略其他代码</span></span><br><span class=\"line\">  <span class=\"attr\">mutaions</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">\t\t\tstate.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">addAsync</span>(<span class=\"params\">context</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        context.commit(<span class=\"string\">&#x27;add&#x27;</span>)</span><br><span class=\"line\">      &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h5 id=\"触发action\"><a class=\"markdownIt-Anchor\" href=\"#触发action\">#</a> 触发 Action</h5>\n<p>（1）触发 actions 的第一种方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">handle</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 触发actions的第一种方式</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.$store.dispatch(<span class=\"string\">&#x27;addAsync&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>触发 actions 异步任务时携带参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义Action</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// ...此处省略其他代码</span></span><br><span class=\"line\">  <span class=\"attr\">mutaions</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">addN</span>(<span class=\"params\">state,step</span>)</span>&#123;</span><br><span class=\"line\">\t\t\tstate.count += step</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">actions</span>: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">addNAsync</span>(<span class=\"params\">context, step</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        context.commit(<span class=\"string\">&#x27;addN&#x27;</span>,step)</span><br><span class=\"line\">      &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发actions</span></span><br><span class=\"line\"><span class=\"attr\">methods</span>:&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">handle</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.$store.dispatch(<span class=\"string\">&#x27;addAsync&#x27;</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）触发 actions 的第二种方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.从vuex中按需导入mapActions函数</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过刚才导入的 mapActions 函数，映射为当前组件的 methods 函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">\t...mapAction([&#x27;addAsync&#x27;,&#x27;addNASync&#x27;])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"getter\"><a class=\"markdownIt-Anchor\" href=\"#getter\">#</a> Getter</h4>\n<p>Getter 用于对 store 中的数据进行加工处理形成新的数据</p>\n<ul>\n<li>\n<p>Getter 可以对 Store 中已有的数据加工处理之后形成新的数据，类似 Vue 的计算属性</p>\n</li>\n<li>\n<p>Store 中数据发生变化，Getter 的数据也会跟着变化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义Getter</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  <span class=\"attr\">state</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">count</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">getters</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">showNum</span>: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">`当前最新的数据时【 <span class=\"subst\">$&#123;state.count&#125;</span> 】`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;) </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>使用 Getter 的第一种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.getters.名称</span><br></pre></td></tr></table></figure>\n<p>使用 Getter 的第二种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vuex&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">  ...mapGetters([<span class=\"string\">&#x27;showNum&#x27;</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Vue专题",
                "vuex"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2020/12/16/HTTPS%E5%92%8CHTTP%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/",
            "url": "https://gaoyuan.ink/2020/12/16/HTTPS%E5%92%8CHTTP%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/",
            "title": "HTTPS和HTTP原理和区别",
            "date_published": "2020-12-16T14:08:28.000Z",
            "content_html": "<p>一、HTTP 和 HTTPS 的基本概念<br>\n HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p>\n<p>HTTP 原理：</p>\n<p>①  客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是 80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。</p>\n<p>②  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p>\n<span id=\"more\"></span>\n<p>HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如 TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>\n<p>​​<img data-src=\"https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<!-- more -->\n<p>HTTPS 设计目标：</p>\n<p>(1) 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</p>\n<p>(2) 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</p>\n<p>(3) 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</p>\n<p>二、HTTP 与 HTTPS  的区别<br>\n 1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是 http，而网易邮箱是 https 。)</p>\n<p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p>\n<p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>\n<p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>\n<p>三、HTTPS 相对于 HTTP 的改进<br>\n双向的身份认证</p>\n<p>客户端和服务端在传输数据之前，会通过基于 X.509 证书对双方进行身份认证 。具体过程如下：</p>\n<p>客户端发起 SSL 握手消息给服务端要求连接。</p>\n<p>服务端将证书发送给客户端。</p>\n<p>客户端检查服务端证书，确认是否由自己信任的证书签发机构签发 (客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。</p>\n<p>服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。</p>\n<p>注意：</p>\n<p>(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。</p>\n<p>(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p>\n<p>(3) 客户端内置的是 CA 的根证书 (Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p>\n<p>数据传输的机密性</p>\n<p>客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端，其中包含自己支持的非对成加密的密钥交换算法 (一般是 RSA)，数据签名摘要算法 ( 一般是 SHA 或者 MD5) ，加密传输数据的对称加密算法 ( 一般是 DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。</p>\n<p>防止重放攻击</p>\n<p>SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</p>\n<p>可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。</p>\n<p>四、HTTPS 的优点<br>\n 1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</p>\n<p>2、HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</p>\n<p>3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>\n<p>五、HTTPS 的缺点（对比优点）<br>\n1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。</p>\n<p>2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</p>\n<p>3、HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</p>\n<p>4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</p>\n<p>5、成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</p>\n<p>6、HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</p>\n<p>六、HTTPS 的连接过程</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180709141944471\" alt=\"\"></p>\n<p>图片中的过程是按 8 个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。</p>\n<p>① 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p>\n<p>② 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p>\n<p>③ 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 “发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</p>\n<p>④ 用户端随机产生一个用于通讯的 “对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的 “预主密码” 传给服务器。</p>\n<p>⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。</p>\n<p>⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA  是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p>\n<p>⑦ 服务器和客户端用相同的对称加密密钥，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p>\n<p>⑧ 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p>\n<p>⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p>\n<p>⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p>\n<p>上述的过程需要弄懂的核心思想<br>\n客户端解析证书</p>\n<p>这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个对称加密密钥，然后用公钥对该密钥进行非对称加密。</p>\n<p>传送加密信息</p>\n<p>这部分传送的是用公钥加密后的对称加密密钥，目的就是让服务端得到这个密钥，以后客户端和服务端的通信就可以通过这个密钥来进行加密解密了。</p>\n<p>服务端解密信息</p>\n<p>服务端用非对称加密算法里的私钥解密后，得到了客户端传过来的对称加密算法的私钥，然后把之后传输的内容通过该值进行对称加密。</p>\n<p>为什么用非对称加密协商对称加密密钥</p>\n<p>对称加密的特点：对称密码体制中只有一种密钥，并且是非公开的。如果要解密就得让对方知道密钥，所以想要保证其安全性就要保证密钥的安全。</p>\n<p>非对称加密的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了，这样安全性就大了很多。</p>\n<p>非对称加密公钥和私钥的使用方法：(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。</p>\n<p>补充：<br>\nSSL 提供服务<br>\n (1) 认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>\n<p>(2) 加密数据以防止数据中途被窃取；</p>\n<p>(3) 维护数据的完整性，确保数据在传输过程中不被改变。</p>\n<p>SSL 工作流程<br>\n服务器认证阶段：</p>\n<p>(1) 客户端向服务器发送一个开始信息 “Hello” 以便开始一个新的会话连接；</p>\n<p>(2) 服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的 “Hello” 信息时将包含生成主密钥所需的信息；</p>\n<p>(3) 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</p>\n<p>(4) 服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p>\n<p>用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p>\n<p>SSL 协议提供的安全通道有以下三个特性：</p>\n<p>机密性：SSL 协议使用密钥加密通信数据。</p>\n<p>可靠性：服务器和客户都会被认证，客户的认证是可选的。</p>\n<p>完整性：SSL 协议会对传送的数据进行完整性检查。</p>\n<p>服务器证书 (server certificates) 是 SSL 数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成 Web 服务器的 SSL 安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户提供验证您 Web 站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。</p>\n",
            "tags": [
                "HTTP",
                "HTTP"
            ]
        },
        {
            "id": "https://gaoyuan.ink/2020/11/18/vue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/",
            "url": "https://gaoyuan.ink/2020/11/18/vue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/",
            "title": "vue项目打包优化策略",
            "date_published": "2020-11-18T14:26:13.000Z",
            "content_html": "<p>使用 vue-cli 部署生产包时，发现资源包很大，打包后的 <code>vendor.js</code>  达到了 1.4M，这已经很大了，而且会影响到首屏加载。那么，怎么优化呢？</p>\n<h3 id=\"1组件按需加载\"><a class=\"markdownIt-Anchor\" href=\"#1组件按需加载\">#</a> 1. 组件按需加载</h3>\n<p>这是首先可以优化的点。如果频繁使用了第三方组件 / UI 库，如我的项目中经常同时使用了 element-ui, mint-ui,echarts 等组件库，如果全部引入，项目体积非常大，这时可以按需引入组件。</p>\n<p>示例如下：</p>\n<h4 id=\"11-element-ui\"><a class=\"markdownIt-Anchor\" href=\"#11-element-ui\">#</a> 1.1 element-ui</h4>\n<p>首先，安装 babel-plugin-component：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>然后，将.babelrc 修改为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// main.js</span><br><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import &#123; Dialog, Loading &#125; from &#x27;element-ui&#x27;</span><br><span class=\"line\">Vue.use(Dialog)</span><br><span class=\"line\">Vue.use(Loading.directive)</span><br><span class=\"line\">Vue.prototype.$loading = Loading.service</span><br><span class=\"line\">// 然后正常使用组件</span><br></pre></td></tr></table></figure>\n<h4 id=\"12-mint-ui\"><a class=\"markdownIt-Anchor\" href=\"#12-mint-ui\">#</a> 1.2 mint-ui</h4>\n<p>由于 mint-ui 是 element-ui 的移动端组件，所以它的使用和引入几乎和 element-ui 一样。</p>\n<p>首先，安装 babel-plugin-component：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>\n<p>然后，将.babelrc 修改为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [</span><br><span class=\"line\">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;plugins&quot;: [[&quot;component&quot;, [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;libraryName&quot;: &quot;mint-ui&quot;,</span><br><span class=\"line\">      &quot;style&quot;: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]]]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后引入部分组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// main.js</span><br><span class=\"line\">import Vue from &#x27;vue&#x27;</span><br><span class=\"line\">import &#123; Toast, MessageBox &#125; from &#x27;element-ui&#x27;</span><br><span class=\"line\">Vue.use(Dialog)</span><br><span class=\"line\">Vue.use(Loading.directive)</span><br><span class=\"line\">Vue.prototype.$loading = Loading.service</span><br><span class=\"line\">// 然后正常使用组件</span><br></pre></td></tr></table></figure>\n<p>注意，element-ui 和 mint-ui 不能同时在.babelrc 中进行插件设置，这种情况下，依然可以按需引入，但是不要在 <code>.babelrc</code>  中配置，在引入的地方同时引入 css 即可。</p>\n<h4 id=\"13-echarts\"><a class=\"markdownIt-Anchor\" href=\"#13-echarts\">#</a> 1.3 echarts</h4>\n<p>首先安装 babel-plugin-equire</p>\n<p>npm i babel-plugin-equire -D</p>\n<p>然后，在 <code>.babelrc</code>  文件中添加该插件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">       // other plugins</span><br><span class=\"line\">       ...</span><br><span class=\"line\">       </span><br><span class=\"line\">    &quot;equire&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个 js 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// echarts.js</span><br><span class=\"line\">// eslint-disable-next-line</span><br><span class=\"line\">const echarts = equire([</span><br><span class=\"line\">  &#x27;tooltip&#x27;,</span><br><span class=\"line\">  &#x27;candlestick&#x27;,</span><br><span class=\"line\">  &#x27;bar&#x27;,</span><br><span class=\"line\">  &#x27;line&#x27;,</span><br><span class=\"line\">  &#x27;axisPointer&#x27;,</span><br><span class=\"line\">  &#x27;legend&#x27;,</span><br><span class=\"line\">  &#x27;grid&#x27;</span><br><span class=\"line\">])</span><br><span class=\"line\">export default echarts</span><br><span class=\"line\">// 业务组件，引入echarts</span><br><span class=\"line\">import echarts from &#x27;@/assets/lib/echarts&#x27;</span><br><span class=\"line\">// 使用与以前一样</span><br></pre></td></tr></table></figure>\n<p>按需加载 echarts</p>\n<p>解决 vue-cli 首屏加载慢的问题</p>\n<h3 id=\"2路由懒加载\"><a class=\"markdownIt-Anchor\" href=\"#2路由懒加载\">#</a> 2. 路由懒加载</h3>\n<p>这里需要一个插件</p>\n<p>vue-router 官方推荐 syntax-dynamic-import 插件，不过它要求同时安装 @bable/core^7.0.0，如果你安装了 babel-core6，是会有版本冲突的。我的做法如下</p>\n<p>npm install babel-plugin-syntax-dynamic-import --save-dev(^6.18.0)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// router.js</span><br><span class=\"line\">const login = () =&gt; import(&#x27;@/components/login&#x27;)</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123; path: &#x27;/login&#x27;, component: login &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>还有一种魔法注释用法</p>\n<p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#x27;./Foo.vue&#x27;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3异步组件\"><a class=\"markdownIt-Anchor\" href=\"#3异步组件\">#</a> 3. 异步组件</h3>\n<p>如果组件在页面加载时不需要，只在调用时用到，这时可以使用异步组件的写法。仅仅是引入和组件注册写法不同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// template</span><br><span class=\"line\">&lt;test v-if=&quot;showTest&quot;&gt;&lt;/test&gt;</span><br><span class=\"line\">// script</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    test: () =&gt; import(&#x27;./test&#x27;) // 将组件异步引入，告诉webpack，将该部分代码分割打包</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods:&#123;</span><br><span class=\"line\">      clickTest () &#123;</span><br><span class=\"line\">          this.showTest = !this.showTest</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4图片的压缩合并\"><a class=\"markdownIt-Anchor\" href=\"#4图片的压缩合并\">#</a> 4. 图片的压缩合并</h3>\n<p>如有可能，将图片制作成精灵图</p>\n<h3 id=\"5cdn加速\"><a class=\"markdownIt-Anchor\" href=\"#5cdn加速\">#</a> 5.CDN 加速</h3>\n<p>在 index.html 中引入 cdn 资源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;!-- built files will be auto injected --&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.2/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;script src=&quot;https://cdn.bootcss.com/vue-resource/1.5.1/vue-resource.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>修改 build/webpack.base.conf.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  context: path.resolve(__dirname, &#x27;../&#x27;),</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: &#x27;./src/main.js&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  externals:&#123;</span><br><span class=\"line\">    &#x27;vue&#x27;: &#x27;Vue&#x27;,</span><br><span class=\"line\">    &#x27;vue-router&#x27;: &#x27;VueRouter&#x27;,</span><br><span class=\"line\">    &#x27;vuex&#x27;:&#x27;Vuex&#x27;,</span><br><span class=\"line\">    &#x27;vue-resource&#x27;: &#x27;VueResource&#x27;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改 src/main.js src/router/index.js 注释掉 import 引入的 vue,vue-resource</p>\n<p>// import Vue from ‘vue’</p>\n<p>// import VueResource from ‘vue-resource’</p>\n<p>// Vue.use(VueResource)</p>\n<h3 id=\"6压缩代码\"><a class=\"markdownIt-Anchor\" href=\"#6压缩代码\">#</a> 6. 压缩代码</h3>\n<p>vue-cli 已经使用 UglifyJsPlugin 插件来压缩代码，可以设置成如下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class=\"line\">  compress: &#123;</span><br><span class=\"line\">    warnings: false,</span><br><span class=\"line\">    drop_console: true,</span><br><span class=\"line\">    pure_funcs: [&#x27;console.log&#x27;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  sourceMap: false</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>其中 sourceMap: false 是禁用除错功能。</p>\n<p>如果设为 true，在部署包中会生成.map 结尾的 js 文件。它用于在代码混淆压缩的情况下仍可进行调试。这个功能虽好，但会大大增加整体资源包的体积，所以将其禁用。</p>\n",
            "tags": [
                "Vue专题",
                "vue",
                "webpack"
            ]
        }
    ]
}