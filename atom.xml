<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GaoYuan&#39;s Blog</title>
  
  <subtitle>生活就像海洋，只有意志将强的人才能到达彼岸</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-26T03:24:45.133Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>高原</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript基础（六）基本数据类型</title>
    <link href="http://example.com/2021/03/26/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2021/03/26/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-03-26T03:20:16.000Z</published>
    <updated>2021-03-26T03:24:45.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h2><p>可能许多习惯了C++、C#这类静态语言（强类型）语言的小伙伴们在编写Js代码时，会很不习惯，因为相对于静态语言来说，Js甚至没有类型的”概念“。</p><p>而且Js中吐槽较多的恰恰就包含类型转换，在我们日常写代码时总是遇到或显示或隐示的类型转换，比如：</p><p>你要获取数字<code>123</code>的个位十位百位，你会怎么做？</p><ul><li>toSrting()后通过下标获取？</li><li>取整取余？</li></ul><p>使用类型转换形式多样。有些方式简明易懂，也很安全，然而稍不留神，就会出现意想不到的结果。</p><p>为了学习和掌握类型转换，现在先让我们来深入了解一下值和类型。</p><span id="more"></span><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>JavaScript 拥有<strong>动态类型</strong>，这意味着相同的变量可用作不同的类型：类型是值的内部特征，它定义了值的行为，以使其区别于其他值。</p><p><strong>JavaScript中的内置类型:</strong></p><ul><li>null</li><li>undefined</li><li>布尔值（boolean）</li><li>数字（number）</li><li>字符串（string）</li><li>对象（Object）</li><li>symbol（ES6新增）</li></ul><p>对于null和undefined大家一定不陌生，我们会在第三节简单的分析他们之前的区别。</p><h2 id="二、数据类型分类"><a href="#二、数据类型分类" class="headerlink" title="二、数据类型分类"></a>二、数据类型分类</h2><p>除了<strong>对象</strong>，其他几个都是<strong>基本类型</strong>，这是因为声明变量时不同的内存分配而决定的：</p><h3 id="2-1-基本类型"><a href="#2-1-基本类型" class="headerlink" title="2.1 基本类型"></a>2.1 基本类型</h3><p>JavaScript 中共有 6 种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>。</p><p><code>基本类型</code>存储在<code>栈（stack）中</code>，也就是说：</p><ul><li>它们的值<strong>直接存储在变量访问的位置</strong>。</li><li>这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – <code>栈</code>中。</li><li>这样存储便于迅速查寻变量的值。</li><li>基本类型的值是按值访问的，且基本类型的值是不可变的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123hello321&quot;</span>;</span><br><span class="line">str.toUpperCase();     <span class="comment">// 123HELLO321</span></span><br><span class="line"><span class="built_in">console</span>.log(str);      <span class="comment">// 123hello321</span></span><br></pre></td></tr></table></figure><p><strong>基本类型的比较是它们的值的比较：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a == b);    <span class="comment">// == 只进行值的比较</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b);   <span class="comment">// === 不仅进行值得比较，还要进行数据类型的比较</span></span><br></pre></td></tr></table></figure><p>有关符号运算，优先级的问题，我觉得应该将它放在Js专题系列，单独讨论它们才能比较透彻，这里就不过多解释了。</p><p>来看下面的代码，我们用图示来分析它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">b = a;</span><br><span class="line">a = <span class="string">&#x27;字符串&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdnimg.cn/20200707105321216.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2-2-引用类型"><a href="#2-2-引用类型" class="headerlink" title="2.2 引用类型"></a>2.2 引用类型</h3><p><code>引用类型</code>存储在<code>堆（heap）</code>中的对象，也就是说:</p><ul><li>存储在变量处的值是一个指针（point），指向存储对象的内存地址。</li><li>引用类型的值是按引用访问的，且引用类型的值是<code>可变</code>的。</li><li>变量存储的是可以打开保存数据的房间的<code>钥匙</code></li><li><code>存储钥匙地址</code>的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</li></ul><p>除过上面的 6 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，有：</p><ul><li>Object</li><li>Array</li><li>Date</li><li>RegExp</li><li>Function</li><li>…</li></ul><p><strong>引用类型的比较是引用的比较：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;    <span class="comment">// 新建一个空对象 obj1</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;    <span class="comment">// 新建一个空对象 obj2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 == obj2);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>因为 obj1 和 obj2 分别引用的是存放在堆内存中的2个不同的对象，故变量 obj1 和 obj2 的值（引用地址）也是不一样的！</p><p>来看下面的代码，我们用图示来分析它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;高原&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">b = a;</span><br><span class="line">a.name = <span class="string">&quot;gaoyuan&quot;</span>;</span><br><span class="line">b.age = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  name: <span class="string">&#x27;高原&#x27;</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="https://img-blog.csdnimg.cn/20200707114641540.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p><strong>基本类型</strong></p><ul><li>栈内存中包括了变量的标识符和变量的值</li></ul><p><strong>引用类型</strong></p><ul><li>栈内存中保存了变量标识符和指向堆内存中该对象的指针</li><li>堆内存中保存了对象的内容</li><li></li></ul><h2 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h2><h3 id="3-1-JavaScript中的变量是没有类型的"><a href="#3-1-JavaScript中的变量是没有类型的" class="headerlink" title="3.1 JavaScript中的变量是没有类型的"></a>3.1 JavaScript中的变量是没有类型的</h3><p>来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>; <span class="comment">// 严格地说 变量a没有类型，它所保存的 100是数字类型的</span></span><br><span class="line"><span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// 其实检测是=&gt;typeof 100</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>变量a</code>可以随时持有任何类型的<code>值</code>。换个角度来理解就是，JavaScript不做“类型强制”；也就是说，语言引擎不要求变量总是持有与其初始值同类型的值。</p><h3 id="3-2-typeof检测不总是对的"><a href="#3-2-typeof检测不总是对的" class="headerlink" title="3.2 typeof检测不总是对的"></a>3.2 typeof检测不总是对的</h3><p><img data-src="https://img-blog.csdnimg.cn/20200706185843137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>需要注意的点：</p><p><strong>number</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本数学API和属性</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.LN2 === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// true  Math的属性</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span> === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// true 无穷</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// true 特殊的数字类型，not a number</span></span><br><span class="line"><span class="comment">// 被强转称数字的其他数据类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="string">&#x27;str&#x27;</span>) === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// Number(&#x27;str&#x27;) =&gt; NaN =&gt; number</span></span><br></pre></td></tr></table></figure><p><strong>string</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> (<span class="keyword">typeof</span> <span class="number">1</span>) === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// typeof always returns a string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="number">1</span>) === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// 强转成字符串</span></span><br></pre></td></tr></table></figure><p><strong>布尔值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="number">1</span>) === <span class="string">&#x27;boolean&#x27;</span>; <span class="comment">// 强制类型转换</span></span><br><span class="line"><span class="keyword">typeof</span> !!(<span class="number">1</span>) === <span class="string">&#x27;boolean&#x27;</span>; <span class="comment">// two calls of the ! (logical NOT) operator are equivalent to Boolean()</span></span><br></pre></td></tr></table></figure><p><strong>Symble</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">&#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="string">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>undefined</strong></p><p>一个没有被赋值的变量的数据类型是<code>undefined</code>(如果方法或者是语句中操作的变量没有被赋值，则会返回undefined) —— MDN</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>object</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;高原&#x27;</span> &#125; === <span class="string">&#x27;object&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>null</strong></p><p>值得我们注意恰恰是这个<code>null</code>,typeof 对它的处理返回的是<code>object</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">&#x27;object&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>function</strong></p><p>typeof检测函数返回的也是object，这是因为从规范上看<code>function</code>实际上是<code>object</code>的一个子类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Functions</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125; === <span class="string">&#x27;function&#x27;</span>;</span><br></pre></td></tr></table></figure><p>那么你还知道其他检测数据类型的方式吗？</p><h3 id="3-3-null和undefined"><a href="#3-3-null和undefined" class="headerlink" title="3.3 null和undefined"></a>3.3 null和undefined</h3><ul><li><p>null：特指对象的值未设置。它是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 基本类型</span><br></pre></td></tr></table></figure><p>之一。</p><ul><li>它不是全局对象的一个属性;</li><li>在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。</li></ul></li><li><p>undefined：表示声明但未被赋值的变量类型</p><ul><li>你可以使用<code>undefined</code>和严格相等或不相等操作符来决定一个变量是否拥有值。</li></ul></li></ul><p><strong>他们的区别：</strong></p><p>当检测 null 或 undefined 时，注意相等 <code>==</code>与<code>===</code>两个操作符的区别 ，前者会执行类型转换：</p><ul><li>typeof检测时两者的返回值不同</li><li>代表的含义不同</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// &quot;object&quot; (因为一些以前的原因而不是&#x27;null&#x27;)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span>  == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">null</span> <span class="comment">//true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、类型&quot;&gt;&lt;a href=&quot;#一、类型&quot; class=&quot;headerlink&quot; title=&quot;一、类型&quot;&gt;&lt;/a&gt;一、类型&lt;/h2&gt;&lt;p&gt;可能许多习惯了C++、C#这类静态语言（强类型）语言的小伙伴们在编写Js代码时，会很不习惯，因为相对于静态语言来说，Js甚至没有类型的”概念“。&lt;/p&gt;
&lt;p&gt;而且Js中吐槽较多的恰恰就包含类型转换，在我们日常写代码时总是遇到或显示或隐示的类型转换，比如：&lt;/p&gt;
&lt;p&gt;你要获取数字&lt;code&gt;123&lt;/code&gt;的个位十位百位，你会怎么做？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toSrting()后通过下标获取？&lt;/li&gt;
&lt;li&gt;取整取余？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用类型转换形式多样。有些方式简明易懂，也很安全，然而稍不留神，就会出现意想不到的结果。&lt;/p&gt;
&lt;p&gt;为了学习和掌握类型转换，现在先让我们来深入了解一下值和类型。&lt;/p&gt;</summary>
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础（五）闭包</title>
    <link href="http://example.com/2021/03/25/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E9%97%AD%E5%8C%85/"/>
    <id>http://example.com/2021/03/25/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E9%97%AD%E5%8C%85/</id>
    <published>2021-03-25T02:54:14.000Z</published>
    <updated>2021-03-25T03:03:37.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是闭包"><a href="#一、什么是闭包" class="headerlink" title="一、什么是闭包"></a>一、什么是闭包</h2><p>顾名思义，遇见问题先问为什么是我们一贯的思维方式，我们尝试回答一下：</p><ol><li>闭包就是函数内部的子函数—— <code>等于没说</code></li><li>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。——<code>靠谱</code></li><li>闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁——<code>靠谱</code></li><li>函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）——<code>很靠谱</code></li></ol><p>我们试着用代码来描述一下上面的回答，看看你最<strong>中意</strong>哪一个～</p><span id="more"></span><h3 id="1-1-闭包是函数内部的子函数"><a href="#1-1-闭包是函数内部的子函数" class="headerlink" title="1.1 闭包是函数内部的子函数"></a>1.1 闭包是函数内部的子函数</h3><p>先看这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure><p>基于词法作用域的查找规则，<code>bar函数</code>可以成功的打印<code>a</code>变量，并且它也是<code>foo</code>的子函数，但严格来说它并没有清晰的表达出闭包这一概念，说它表达的是<strong>嵌套函数可以访问声明于大外部作用域的变量</strong>更准确一些。</p><h3 id="1-2-闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁"><a href="#1-2-闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁" class="headerlink" title="1.2 闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁"></a>1.2 闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁</h3><p>再来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = foo();</span><br><span class="line">res(); <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure><p>结果一致，这是因为此时<code>res</code>是执行<code>foo</code>函数时返回的<code>bar</code>引用，bar函数得以保存了它饿词法环境。</p><h3 id="1-3-函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）"><a href="#1-3-函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）" class="headerlink" title="1.3 函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）"></a>1.3 函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）</h3><p>我们来看下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// gaoyuan</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">//gaoyuan</span></span><br></pre></td></tr></table></figure><p>foo的上下文被静态的保存了下来，而且是在该函数创建的时候就保存了。下面我们来验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// gaoyuan</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;老王&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    func()</span><br><span class="line">&#125;)(foo); <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure><p>这里我们就可以理解——函数被创建后就形成了闭包，他们保存了上层上下文的作用域链，并且保存在<code>[[scope]]</code>中，如果你对<code>[[scope]]</code>的概念已经模糊了，不妨花几分钟看看《JavaScript中的执行上下文》这篇文章。</p><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p><strong>注意：闭包是函数内部的返回的子函数这句话本身没错</strong>，但要看从什么角度出发：</p><p>ECMAScript中，闭包指的是：</p><ol><li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li><li>从实践角度：以下函数才算是闭包：<ul><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ul></li></ol><p><strong>总结：</strong></p><ul><li>闭包代码块创建该代码块的上下文中数据的结合</li><li>闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁</li><li>不同的角度对闭包的解释不同的</li></ul><p>注意：这些并不是闭包的全部，就好像当你被问到——闭包是什么的时候，你的上述回答并不能结束这个话题，往往会引申出更多的话题。</p><h2 id="二、尝试分析闭包"><a href="#二、尝试分析闭包" class="headerlink" title="二、尝试分析闭包"></a>二、尝试分析闭包</h2><p>还是那段经典代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line">foo(); <span class="comment">// local scope</span></span><br></pre></td></tr></table></figure><p>首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p><ol><li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li><li>全局执行上下文初始化</li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li><li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li><li>f 执行上下文初始化，创建变量对象、作用域链、this等</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li></ol><p><img data-src="https://img-blog.csdnimg.cn/20200628152924827.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>当 <code>f</code> 函数执行的时候，<code>checkscope</code> 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 <code>checkscope</code> 作用域下的 <code>scope</code> 值呢？</p><p>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：</p><p>因为这个作用域链：</p><ul><li><code>f 函数</code>依然可以读取到 <code>checkscopeContext.AO</code> 的值；</li><li>当 <code>f 函数</code>引用了 <code>checkscopeContext.AO</code> 中的值的时候，即使 <code>checkscopeContext</code> 被销毁了，JavaScript 依然会让 <code>checkscopeContext.AO</code> 活在内存中;</li><li><code>f 函数</code>依然可以通过 <code>f 函数</code>的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</li></ul><p>多么浪漫的思想——只要你需要我，那我我本应该被销毁，你也能找到我～</p><h2 id="三、经典问题"><a href="#三、经典问题" class="headerlink" title="三、经典问题"></a>三、经典问题</h2><h3 id="3-1-多个对象引用同一个-Scope-，你遇到过吗？"><a href="#3-1-多个对象引用同一个-Scope-，你遇到过吗？" class="headerlink" title="3.1 多个对象引用同一个[[Scope]]，你遇到过吗？"></a>3.1 多个对象引用同一个[[Scope]]，你遇到过吗？</h3><p>直接上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child1;</span><br><span class="line"><span class="keyword">var</span> child2;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    child1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(++x)</span><br><span class="line">    &#125;;</span><br><span class="line">    child2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(--x)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">parent();</span><br><span class="line">child1(); <span class="comment">// 2</span></span><br><span class="line">child1(); <span class="comment">// 3</span></span><br><span class="line">child2(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>大家可能不理解，<code>child1</code>和<code>child</code>他们两个函数在创建后都保存了上层上下文，万万没想到，<strong>同一个上下文创建的闭包是共用一个<code>[[scope]]</code>属性的</strong>，某个闭包对其中[[Scope]]的变量做修改会影响到其他闭包对其变量的读取。</p><h3 id="3-2-闭包轻松解决的经典问题"><a href="#3-2-闭包轻松解决的经典问题" class="headerlink" title="3.2 闭包轻松解决的经典问题"></a>3.2 闭包轻松解决的经典问题</h3><p>大家一定对下面这段代码很眼熟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>](); <span class="comment">// 10</span></span><br><span class="line">arr[<span class="number">1</span>](); <span class="comment">// 10</span></span><br><span class="line">arr[<span class="number">2</span>](); <span class="comment">// 10</span></span><br><span class="line">arr[<span class="number">3</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>我们这么解释它：<strong>同一个上下文中创建的闭包是共用一个[[Scope]]属性的</strong>。</p><p>因此上层上下文中的变量<code>i</code>是可以很容易就被改变的。</p><p>arr[0],arr[1]…arr[9]他们共用一个[[scope]]，最终执行的时候结果当然一样。</p><p><strong>如何利用闭包来解决这个问题呢？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    arr[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">arr[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">arr[<span class="number">2</span>](); <span class="comment">// 2</span></span><br><span class="line">arr[<span class="number">3</span>](); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>我们通过立即执行匿名函数的方式隔离了作用域，当执行 arr[0] 函数的时候，arr[0] 函数的作用域链发生了改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    Scope: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数执行上下文的AO为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        i: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，这时函数的<code>[[Scope]]</code>属性就有了真正想要的值了，为了达到这样的目的，我们不得不在<code>[[Scope]]</code>中创建额外的变量对象。要注意的是，在返回的函数中，如果要获取<code>i</code>的值，那么该值还是会是10。</p><h3 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h3><ul><li>函数内的所有内部函数都共享一个父作用域，因此创建的闭包是共用的。</li><li>利用闭包隔离作用域的特性可以解决共享作用域的问题</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=1200653736,2067630829&fm=26&gp=0.jpeg"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、什么是闭包&quot;&gt;&lt;a href=&quot;#一、什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;一、什么是闭包&quot;&gt;&lt;/a&gt;一、什么是闭包&lt;/h2&gt;&lt;p&gt;顾名思义，遇见问题先问为什么是我们一贯的思维方式，我们尝试回答一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;闭包就是函数内部的子函数—— &lt;code&gt;等于没说&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。——&lt;code&gt;靠谱&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁——&lt;code&gt;靠谱&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）——&lt;code&gt;很靠谱&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们试着用代码来描述一下上面的回答，看看你最&lt;strong&gt;中意&lt;/strong&gt;哪一个～&lt;/p&gt;</summary>
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础（四）立即调用函数</title>
    <link href="http://example.com/2021/03/24/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/03/24/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-24T01:37:26.000Z</published>
    <updated>2021-03-24T01:41:54.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章，主要讲解的立即执行函数或自执行匿名函数的含义、用法、以及使用它的主要场景。系列的前面几篇文章主要讲解了作用域、原型，本篇文章一样起到了承上启下的作用，如果您感兴趣，不妨去看看哦～</p></blockquote><h2 id="一、了解立即调用函数表达式"><a href="#一、了解立即调用函数表达式" class="headerlink" title="一、了解立即调用函数表达式"></a>一、了解立即调用函数表达式</h2><h3 id="1-1-思维导图"><a href="#1-1-思维导图" class="headerlink" title="1.1 思维导图"></a>1.1 思维导图</h3><p><img data-src="https://img-blog.csdnimg.cn/20200622113604893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><span id="more"></span><h3 id="1-2-什么是立即调用？"><a href="#1-2-什么是立即调用？" class="headerlink" title="1.2 什么是立即调用？"></a>1.2 什么是立即调用？</h3><p>在详细了解这个之前，我们来谈了解一下“自执行”这个叫法，本文对这个功能的叫法也不一定完全对，每个人对他的理解都不一样，我们在这里用<code>立即调用</code>～</p><p>立即调用：</p><ul><li>顾名思义，该表达式一被<code>创建就立即执行</code>。</li><li>是一个在定义时就会立即执行的 <code>JavaScript 函数</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x + x = &#x27;</span>, x + x);</span><br><span class="line">&#125;)(<span class="number">5</span>) <span class="comment">// x + x = 10</span></span><br></pre></td></tr></table></figure><p>这是一个被称为 <code>自执行匿名函数</code> 的设计模式，主要包含两部分:</p><ol><li>第一部分是包围在 圆括号运算符 <code>()</code> 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</li><li>第二部分再一次使用 <code>()</code> 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</li></ol><h3 id="1-3-核心问题"><a href="#1-3-核心问题" class="headerlink" title="1.3 核心问题"></a>1.3 核心问题</h3><p><strong>当你声明一个函数的时候，通过在后面加括号就可以实现立即执行吗？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;(); <span class="comment">// gaoyuan 成功了！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...是不是意味着后面加个括弧都可以自动执行？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;&#x27;</span>gaoyuan);</span><br><span class="line">&#125;(); <span class="comment">// Uncaught SyntaxError: Function statements require a function name</span></span><br><span class="line"><span class="comment">// 什么？还需要一个函数名？不是叫 自执行匿名函数吗？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我加上了函数名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;(); <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;)&#x27;</span></span><br></pre></td></tr></table></figure><p>很显然，例子中的第二条和第三条确实报错了，而且报错内容不一样，那么问题出现在哪呢？</p><h2 id="二、立即调用函数表达式报错了？"><a href="#二、立即调用函数表达式报错了？" class="headerlink" title="二、立即调用函数表达式报错了？"></a>二、立即调用函数表达式报错了？</h2><p>有时，我们定义函数之后，立即调用该函数，这时不能在函数的定义后面直接加圆括号，这会产生语法错误。产生语法错误的原因是，<code>function</code> 这个关键字，既可以当做语句，也可以当做表达式，比如下边：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表达式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>为了避免解析上的歧义，JS引擎规定，如果function出现在行首，一律解析成语句。因此JS引擎看到行首是function关键字以后，认为这一段都是函数定义，不应该以<code>括号结尾</code>，在它看来<code>括号</code>只是分组操作符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这个function在语法上是没问题的，但是依然只是一个语句</span></span><br><span class="line"><span class="comment">// 加上括号()以后依然会报错，因为分组操作符需要包含表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;(); <span class="comment">// SyntaxError: Unexpected token )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果你在括弧()里传入一个表达式，将不会有异常抛出</span></span><br><span class="line"><span class="comment">// 但是foo函数依然不会执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;</span><br><span class="line"></span><br><span class="line">( <span class="number">1</span> );</span><br></pre></td></tr></table></figure><h2 id="三、使用立即调用函数的正确姿势"><a href="#三、使用立即调用函数的正确姿势" class="headerlink" title="三、使用立即调用函数的正确姿势"></a>三、使用立即调用函数的正确姿势</h2><p>要解决上述问题，非常简单。</p><p>我们只需要用<code>大括弧</code>将代码的代码全部括住就行了，因为JavaScript里<code>括弧()</code>里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明。</p><h3 id="3-1-常见使用姿势"><a href="#3-1-常见使用姿势" class="headerlink" title="3.1 常见使用姿势"></a>3.1 常见使用姿势</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面2个括弧()都会立即执行</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ()); <span class="comment">// 推荐使用这个</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;)(); <span class="comment">// 但是这个也是可以用的</span></span><br></pre></td></tr></table></figure><h3 id="3-2-不常见的使用姿势（一）"><a href="#3-2-不常见的使用姿势（一）" class="headerlink" title="3.2 不常见的使用姿势（一）"></a>3.2 不常见的使用姿势（一）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的</span></span><br><span class="line"><span class="comment">// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>)</span><br><span class="line">&#125;(); <span class="comment">// gaoyuan</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>)</span><br><span class="line">&#125;(); <span class="comment">// gaoyuan</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>) &#125;(); <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure><h3 id="3-3-不常见的使用姿势（二）"><a href="#3-3-不常见的使用姿势（二）" class="headerlink" title="3.3 不常见的使用姿势（二）"></a>3.3 不常见的使用姿势（二）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果你不在意返回值，或者不怕难以阅读</span></span><br><span class="line"><span class="comment">// 你甚至可以在function前面加一元操作符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转bool</span></span><br><span class="line"><span class="keyword">var</span> res1 = !<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;res1:&#x27;</span>, res1); <span class="comment">// gaoyuan true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转数字</span></span><br><span class="line"><span class="keyword">var</span> res2 = +<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;res2:&#x27;</span>, res2); <span class="comment">// gaoyuan NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位非</span></span><br><span class="line"><span class="keyword">var</span> res3 = ～<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;res3:&#x27;</span>, res3); <span class="comment">// gaoyuan NaN</span></span><br></pre></td></tr></table></figure><h3 id="3-4-不常见的使用姿势（三）"><a href="#3-4-不常见的使用姿势（三）" class="headerlink" title="3.4 不常见的使用姿势（三）"></a>3.4 不常见的使用姿势（三）</h3><p>还有一个情况，使用new和void关键字，不过不太常见罢了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h2 id="四、常见使用场景"><a href="#四、常见使用场景" class="headerlink" title="四、常见使用场景"></a>四、常见使用场景</h2><h3 id="4-1-隔离作用域"><a href="#4-1-隔离作用域" class="headerlink" title="4.1 隔离作用域"></a>4.1 隔离作用域</h3><p>IIFE最常见的功能，就是隔离作用域，在ES6之前JS原生也没有块级作用域的概念，所以需要函数作用域来模拟。</p><p>举例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentTime = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> year  = time.getFullYear()</span><br><span class="line">    <span class="keyword">var</span> month = time.getMonth()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> date  = time.getDate();</span><br><span class="line">    <span class="keyword">var</span> hour  = time.getHours();</span><br><span class="line">    <span class="keyword">var</span> min   = time.getMinutes();</span><br><span class="line">    <span class="keyword">return</span> year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + date + <span class="string">&#x27; &#x27;</span> + hour + <span class="string">&#x27;:&#x27;</span> + min;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>你仍然可以在其他地方声明同名变量～</p><h3 id="4-2-惰性函数"><a href="#4-2-惰性函数" class="headerlink" title="4.2 惰性函数"></a>4.2 惰性函数</h3><p>DOM事件添加中，为了兼容现代浏览器和IE浏览器，我们需要对浏览器环境进行一次判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">type, el, fn</span>) </span>&#123;</span><br><span class="line">            el.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">type, el, fn</span>) </span>&#123;</span><br><span class="line">            el.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="4-3-用闭包保存状态"><a href="#4-3-用闭包保存状态" class="headerlink" title="4.3 用闭包保存状态"></a>4.3 用闭包保存状态</h3><p>这里我仅举个例子，为我的下一篇文章——《JavaScript中的闭包》卖个关子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">lockedInIndex</span>) </span>&#123;</span><br><span class="line">        elems[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert(<span class="string">&#x27;I am link #&#x27;</span> + lockedInIndex);</span><br><span class="line">        &#125;, <span class="string">&#x27;false&#x27;</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Barry&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 无法从外部访问变量 name</span></span><br><span class="line">name <span class="comment">// 抛出错误：&quot;Uncaught ReferenceError: name is not defined&quot;</span></span><br></pre></td></tr></table></figure><p>将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Barry&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// IIFE 执行后返回的结果：</span></span><br><span class="line">result; <span class="comment">// &quot;Barry&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章，主要讲解的立即执行函数或自执行匿名函数的含义、用法、以及使用它的主要场景。系列的前面几篇文章主要讲解了作用域、原型，本篇文章一样起到了承上启下的作用，如果您感兴趣，不妨去看看哦～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、了解立即调用函数表达式&quot;&gt;&lt;a href=&quot;#一、了解立即调用函数表达式&quot; class=&quot;headerlink&quot; title=&quot;一、了解立即调用函数表达式&quot;&gt;&lt;/a&gt;一、了解立即调用函数表达式&lt;/h2&gt;&lt;h3 id=&quot;1-1-思维导图&quot;&gt;&lt;a href=&quot;#1-1-思维导图&quot; class=&quot;headerlink&quot; title=&quot;1.1 思维导图&quot;&gt;&lt;/a&gt;1.1 思维导图&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&quot;https://img-blog.csdnimg.cn/20200622113604893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础（三）作用域</title>
    <link href="http://example.com/2021/03/23/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://example.com/2021/03/23/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2021-03-23T03:00:57.000Z</published>
    <updated>2021-03-23T03:07:10.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作用域的篇幅不会太长，作为自己对Js总结的第三篇文章，主要是承上启下。 之后会涉及到执行上下文，闭包等相关专题，为了避免内容过多，作用域这一部分单独总结。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/%E4%B8%8B%E8%BD%BD.jpeg" style="zoom:67%;" /><span id="more"></span><h2 id="一、作用域的定义"><a href="#一、作用域的定义" class="headerlink" title="一、作用域的定义"></a>一、作用域的定义</h2><p><strong>一张导图概括本节内容</strong> <img data-src="https://img-blog.csdnimg.cn/20200609102448438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> <strong>1.1 常见的解释</strong></p><ol><li>一段程序代码中所用到的<strong>名字</strong>并不总是有效，而限定它的可用性的范围就是这个名字的作用域；</li><li>作用域规定了<strong>如何查找变量</strong>，也就是确定当前执行代码对变量的访问权限；</li><li>通俗的讲作用域就是<strong>一套规则</strong>，用于确定在何处以及如何查找<strong>某个变量</strong>的规则</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a is not defined a变量并不是任何地方都可以被找到的</span></span><br></pre></td></tr></table></figure><p><strong>1.2 JavaScript中作用域工作模型</strong></p><p>JavaScript 采用是词法作用域(lexical scoping)，也就是静态作用域：</p><ul><li>函数的作用域在函数定义的时候就决定了</li></ul><p>与之对应的还有一个动态作用域：</p><ul><li>函数的作用域是在函数调用的时候才决定的；</li></ul><p><strong>1.3 全局变量和局部变量</strong></p><p>根据定义变量的方式又可以分为：</p><p>局部变量：只能在函数中访问，该函数外不可访问；</p><ul><li>定义在函数中的变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;高原&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// ？</span></span><br><span class="line">fn(); <span class="comment">// ？</span></span><br></pre></td></tr></table></figure><p>全局：任何地方都能访问到的对象拥有全局作用域。</p><ul><li>函数外定义的变量</li><li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a1-&#x27;</span>,a);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a2-&#x27;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a3-&#x27;</span>,a);</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a4-&#x27;</span>,a);</span><br></pre></td></tr></table></figure><p>注意：在ES6之后又提出了块级作用域，它们之间的区别我们之后再来讨论。</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=2659298556,3987226078&fm=26&gp=0.jpeg"></p><h2 id="二、理解作用域"><a href="#二、理解作用域" class="headerlink" title="二、理解作用域"></a>二、理解作用域</h2><p>根据第一节的描述，我们一一验证一下</p><p><strong>2.1 理解词法作用域</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p>我们结合定义去分析：</p><ul><li>执行<code>bar</code>函数，函数内部形成了局部作用域；</li><li>声明value变量，并赋值2</li><li>执行<code>foo</code>函数，函数foo的作用域内没有<code>value</code>这个变量，它会向外查找</li><li>根据词法作用域的规则，函数定义时，<code>foo</code>的外部作用域为全局作用域</li><li>打印<strong>结果是1</strong></li></ul><p>如果是动态作用域的话：结果<strong>就是2</strong>，不知道你是否想明白了？</p><p><strong>2.2 全局变量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;全局变量&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(str+<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(str+<span class="number">2</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(str+<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line">fn();</span><br><span class="line">&#125;;</span><br><span class="line">childFn();</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"><span class="comment">// 全局变量1</span></span><br><span class="line"><span class="comment">// 全局变量2</span></span><br><span class="line"><span class="comment">// 全局变量3</span></span><br></pre></td></tr></table></figure><p>再来分析下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">a = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a1-&#x27;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a2-&#x27;</span>,a);</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a3-&#x27;</span>,a);</span><br><span class="line"><span class="comment">// a2- 100 // 在当前作用域下查找变量a =&gt; 100</span></span><br><span class="line"><span class="comment">// a1- 1000 // 函数执行时，全局变量a已经被重新赋值</span></span><br><span class="line"><span class="comment">// a3- 1000 // 全局变量a =&gt; 1000</span></span><br></pre></td></tr></table></figure><p><strong>2.3 局部作用域</strong></p><p>局部作用域一般只在固定的代码片段内可访问到，最常见的就是以函数为单位的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name=<span class="string">&quot;高原&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">childFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;</span><br><span class="line">    childFn(); <span class="comment">// 高原</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// name is not defined</span></span><br></pre></td></tr></table></figure><h2 id="三、作用域链"><a href="#三、作用域链" class="headerlink" title="三、作用域链"></a>三、作用域链</h2><p><strong>3.1 当查找变量的时候都发生了什么？</strong></p><ul><li>会先从当前<strong>上下文的变量对象</strong>中查找；</li><li>如果没有找到，就会从父级(词法层面上的父级)<strong>执行上下文</strong>的变量对象中查找；</li><li>一直找到全局上下文的变量对象，也就是全局对象；</li><li>作用域链的顶端就是全局对象；</li></ul><p>这样<strong>由多个执行上下文的变量对象构成的链表就叫做作用域链</strong>，从某种意义上很类似原型和原型链。</p><p><strong>3.2 作用域链和原型继承查找时的区别：</strong></p><ul><li>查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回<code>undefined</code></li><li>查找的属性在作用域链中不存在的话就会抛出<code>ReferenceError</code>。</li></ul><p><strong>3.3 作用域嵌套</strong></p><p>既然每一个函数就可以形成一个作用域（<code>词法作用域</code> || <code>块级作用域</code>），那么当然也会存在多个作用域嵌套的情况，他们遵循这样的查询规则：</p><ul><li>内部作用域有权访问外部作用域;</li><li>外部作用域无法访问内部作用域;（真是是这样吗？）</li><li>兄弟作用域不可互相访问;</li></ul><p>在《你不知道的Js》中，希望读者可以将作用域的嵌套和作用域链想象成这样：</p><p><img data-src="https://img-blog.csdnimg.cn/2020060915193493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、思考与总结"><a href="#四、思考与总结" class="headerlink" title="四、思考与总结"></a>四、思考与总结</h2><p><strong>4.1 总结</strong></p><p><img data-src="https://img-blog.csdnimg.cn/20200609160809565.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>4.2 思考</strong></p><p>最后，让我们看一个《JavaScript权威指南》中的两段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(); <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br><span class="line">checkscope1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope2()();</span><br></pre></td></tr></table></figure><p>两段代码的结果都是”local scope”，书中的回答是：JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。</p><p>但是它们内部经历的事情是一样的吗？</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作用域的篇幅不会太长，作为自己对Js总结的第三篇文章，主要是承上启下。 之后会涉及到执行上下文，闭包等相关专题，为了避免内容过多，作用域这一部分单独总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/%E4%B8%8B%E8%BD%BD.jpeg&quot; style=&quot;zoom:67%;&quot; /&gt;</summary>
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础（二）从原型到原型链</title>
    <link href="http://example.com/2021/03/21/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://example.com/2021/03/21/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2021-03-21T02:09:04.000Z</published>
    <updated>2021-03-23T13:21:34.565Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要从构造函数 -&gt; 原型（隐式原型+显示原型）-&gt; 原型链的顺序，渐进式讲解，希望对你有所做帮助，共勉～</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又到了回忆过去的时候了，知识就是这样，原型和原型链在我之前的实习生涯中用到的很少——几乎没有（噗！我菜我摊牌了），但是它和this指向问题一样，是初级、中级前端开发在面试时永远绕不开的话题。是不是大家每次看面经的时候都会去搜索原型相关的知识点？</p><p>你看这知识，总是在考的时候，才能知道它的重要，就好像曾经有一段贼拉真挚的面试题摆在我面前…话题拉回来，今天我们就收了这个<strong>孽障</strong>！</p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/src=http___img.wxcha.com_file_201711_22_e1655873d2.jpg&refer=http___img.wxcha.jpeg" style="zoom:50%;" /><span id="more"></span><h2 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h2><h3 id="1-1-什么是构造函数？"><a href="#1-1-什么是构造函数？" class="headerlink" title="1.1 什么是构造函数？"></a>1.1 什么是构造函数？</h3><p>构造函数本身就是一个函数，与普通函数没有任何区别，不过<strong>为了规范一般将其首字母大写</strong>。构造函数和普通函数的区别在于，使用<strong>new</strong>生成实例的函数就是构造函数，直接调用的就是普通函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数。</p><h3 id="1-2-constructor？"><a href="#1-2-constructor？" class="headerlink" title="1.2 constructor？"></a>1.2 constructor？</h3><p><code>constructor</code> 返回创建实例对象时构造函数的引用。此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。</p><p><img data-src="https://img-blog.csdnimg.cn/20200604185358168.png" alt="被构造出来的person的"> 可以看到实例对象的constructor指向了它的构造函数，而它和原型的关系我们在之后会链接到一起。</p><h3 id="1-3-都有哪些数据类型或者函数拥有constructor呢？"><a href="#1-3-都有哪些数据类型或者函数拥有constructor呢？" class="headerlink" title="1.3 都有哪些数据类型或者函数拥有constructor呢？"></a>1.3 都有哪些数据类型或者函数拥有<code>constructor</code>呢？</h3><p>在JavaScript中，每个具有<strong>原型</strong>的对象都会自动获得constructor属性。除了：<code>arguments</code>、<code>Enumerator</code>、<code>Error</code>、<code>Global</code>、<code>Math</code>、<code>RegExp</code>等一些特殊对象之外，其他所有的JavaScript内置对象都具备constructor属性。例如：<code>Array</code>、<code>Boolean</code>、<code>Date</code>、<code>Function</code>、<code>Number</code>、<code>Object</code>、<code>String</code>等。所有主流浏览器均支持该属性。打开控制台我们可以验证一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span>.constructor) <span class="comment">// ƒ String() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span>.constructor === <span class="built_in">String</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].constructor) <span class="comment">// ƒ Array() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].constructor === <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(num.constructor) <span class="comment">// ƒ Number() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.constructor === <span class="built_in">Number</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().constructor) <span class="comment">// ƒ Date() &#123; [native code] &#125;</span></span><br><span class="line"><span class="comment">// 注意！！！不要混淆哦</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime().constructor) <span class="comment">// ƒ Number() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.constructor) <span class="comment">// ƒ Boolean() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(show.constructor) <span class="comment">// ƒ Function() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义构造函数，无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p.constructor) <span class="comment">// ƒ Person()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">name: <span class="string">&#x27;gaoyuan&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = Person()</span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor) <span class="comment">// ƒ Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-模拟实现一个new"><a href="#1-4-模拟实现一个new" class="headerlink" title="1.4 模拟实现一个new"></a>1.4 模拟实现一个new</h3><p>既然构造函数与普通函数的区别仅仅在于调用方式上，我们就应该了解new。</p><ul><li>当调用<code>new</code>运算符时，该函数总会返回一个对象；</li><li>通常情况下，构造器里的this就指向返回的这个对象；</li></ul><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">通常情况下</span><br><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.name; <span class="comment">// gaoyuan</span></span><br><span class="line"></span><br><span class="line">特殊情况</span><br><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">name: <span class="string">&#x27;老王&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.name <span class="comment">// 老王</span></span><br></pre></td></tr></table></figure><p>我们利用 <code>__proto__</code>（隐式原型，下文会提到）属性来模拟一下new 调用构造函数的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objectNew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 从object.prototype上克隆一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 取得外部传入的构造器，这里是Person</span></span><br><span class="line">    <span class="keyword">var</span> Constructor = [].shift.call( <span class="built_in">arguments</span> );</span><br><span class="line">    <span class="comment">// 更新，指向正确的原型</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype; <span class="comment">//知识点，要考、要考、要考</span></span><br><span class="line">    <span class="comment">// 借用外部传入的构造器给obj设置属性</span></span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 确保构造器总是返回一个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ref === <span class="string">&#x27;object&#x27;</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=1200653736,2067630829&fm=26&gp=0.jpeg" style="zoom: 67%;" /><h2 id="二、原型"><a href="#二、原型" class="headerlink" title="二、原型"></a>二、原型</h2><h3 id="2-1-prototype-显式原型"><a href="#2-1-prototype-显式原型" class="headerlink" title="2.1 prototype(显式原型)"></a>2.1 prototype(显式原型)</h3><p>JavaScript 是一种基于原型的语言 (prototype-based language)，在设计的时候模仿了Java的两套类型机制：<code>基本类型</code> 和 <code>对象类型</code>。可见原型很重要！</p><p>每个对象都拥有一个原型对象，类是以函数的形式来定义的。prototype表示该函数的原型，也表示一个类的成员的集合。看下图： <img data-src="https://img-blog.csdnimg.cn/20200605140618427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 可以发现Person函数自己的原型都有什么：</p><ul><li><code>constructor</code> (Person.prototype.constructor =&gt; Person)</li><li><code>__proto__</code> （我们称它为隐式原型）</li></ul><p>此时我们得到了第一张表示构造函数和实例原型之间的关系图：</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTEucG5n?x-oss-process=image/format,png" alt="构造函数和实例原型的关系图"></p><p>那么我们该怎么表示实例与构造函数原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p><h3 id="2-2-proto-隐式原型"><a href="#2-2-proto-隐式原型" class="headerlink" title="2.2 proto(隐式原型)"></a>2.2 <strong>proto</strong>(隐式原型)</h3><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫<code>__proto__</code>，这是一个访问器属性（即 getter 函数和 setter 函数），通过它可以访问到对象的内部<code>[[Prototype]]</code> (一个对象或 null )。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>于是我们更新下关系图：</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTIucG5n?x-oss-process=image/format,png" alt="实例与实例原型的关系图"></p><p><strong>小结：</strong> 每个引用类型的隐式原型都指向它的构造函数的显式原型</p><h3 id="2-3-constructor"><a href="#2-3-constructor" class="headerlink" title="2.3 constructor"></a>2.3 constructor</h3><p>前文提到了<code>constructor</code>，它与原型的关系也可以添加到这张图里，更新下关系图：</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTMucG5n?x-oss-process=image/format,png" alt="实例原型与构造函数的关系图"> 根据上图的关系，下面这段的结果，大家就一目了然了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>接下来我们要继续思考实例和原型的关系：</p><h2 id="三、实例与原型"><a href="#三、实例与原型" class="headerlink" title="三、实例与原型"></a>三、实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。这样一个查找过程</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;老王&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">&#x27;余光&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 余光</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 老王</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 余光（is me）。</p><p><strong>描述：</strong></p><p>但是当我们删除了 person 的 name 属性后，再次读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 老王（这…）</p><p><strong>总结：</strong></p><ul><li>尝试遍历<code>实例a</code>中的所有属性，但没有找到目标属性；</li><li>查找<code>name</code>属性的这个请求被委托给该<code>实例a</code>的构造器(<code>A</code>)的原型，它被<code>a.__proto__</code> 记录着并且指向A.prototype；</li><li>A.prototype存在目标属性，返回他的值；</li></ul><p>但是万一还没有找到呢？原型的原型又是什么呢？</p><h2 id="四、原型的原型"><a href="#四、原型的原型" class="headerlink" title="四、原型的原型"></a>四、原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&#x27;余光&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// 余光</span></span><br></pre></td></tr></table></figure><p>其实原型对象就是通过<code>Object</code>构造函数生成的，结合之前所讲，实例的 <code>__proto__</code> 指向构造函数的 <code>prototype</code> ，可以理解成，<code>Object.prototype()</code>是所有对象的根对象，所以我们再次更新下关系图：</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTQucG5n?x-oss-process=image/format,png" alt="原型的原型关系图"></p><h2 id="五、原型链"><a href="#五、原型链" class="headerlink" title="五、原型链"></a>五、原型链</h2><p>每个对象拥有一个原型对象，通过 <code>__proto__</code> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>。<strong>这种关系被称为原型链</strong> (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。</p><p>这个链条存在着终点，是因为：Object.prototype 的原型是——null，引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">《undefined与null的区别》 (opens new window)</a>就是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null 表示“没有对象”，即该处不应该有值。这句话也意味着 Object.prototype 没有原型</span><br></pre></td></tr></table></figure><p>我们最后更新一次关系图，蓝色线条就可以表示原型链这种关系。</p><p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTUucG5n?x-oss-process=image/format,png" alt="原型链示意图"></p><h3 id="补充，易错点"><a href="#补充，易错点" class="headerlink" title="补充，易错点"></a>补充，易错点</h3><p><strong>1.constructor</strong> 首先是 constructor 属性，我们看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure><p><strong>2.<code>__proto__</code></strong></p><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p><p><strong>3.真的是继承吗？</strong></p><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，<strong>委托</strong>的说法反而更准确些。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>使用<strong>new</strong>生成实例的函数就是构造函数，直接调用的就是普通函数；</li><li>每个对象都拥有一个原型对象；</li><li>每个引用类型的隐式原型都指向它的构造函数的显式原型；</li><li>Object.prototype是所有对象的根对象；</li><li>原型链存在终点，不会无限查找下去；</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要从构造函数 -&amp;gt; 原型（隐式原型+显示原型）-&amp;gt; 原型链的顺序，渐进式讲解，希望对你有所做帮助，共勉～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;又到了回忆过去的时候了，知识就是这样，原型和原型链在我之前的实习生涯中用到的很少——几乎没有（噗！我菜我摊牌了），但是它和this指向问题一样，是初级、中级前端开发在面试时永远绕不开的话题。是不是大家每次看面经的时候都会去搜索原型相关的知识点？&lt;/p&gt;
&lt;p&gt;你看这知识，总是在考的时候，才能知道它的重要，就好像曾经有一段贼拉真挚的面试题摆在我面前…话题拉回来，今天我们就收了这个&lt;strong&gt;孽障&lt;/strong&gt;！&lt;/p&gt;
&lt;img data-src=&quot;https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/src=http___img.wxcha.com_file_201711_22_e1655873d2.jpg&amp;refer=http___img.wxcha.jpeg&quot; style=&quot;zoom:50%;&quot; /&gt;</summary>
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础（一）this</title>
    <link href="http://example.com/2021/03/20/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89this/"/>
    <id>http://example.com/2021/03/20/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89this/</id>
    <published>2021-03-20T01:55:37.000Z</published>
    <updated>2021-03-23T13:21:28.492Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、this的指向"><a href="#一、this的指向" class="headerlink" title="一、this的指向"></a>一、this的指向</h3><p>百度、谷歌上输入“this的指向”关键字，大几千条文章肯定是有的，总不至于为了全方面、无死角的掌握它就要将所有的文章都看一遍吧？所以不如梳理出一个稳固的框架，我们一起来填充它。</p><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><p><img data-src="https://img-blog.csdnimg.cn/20200602110330766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><span id="more"></span><ul><li>this 总是（非严格模式下）指向一个对象，而具体指向哪个对象是在运行时基于函数的<code>执行环境</code>动态绑定的，而非函数被声明时的环境；</li><li>除了不常用的with和eval的情况，具体到实际应用中，this指向大概可以分为四种：<ul><li>作为对象的方法调用；</li><li>作为普通函数调用；</li><li>构造器调用；</li><li>call 或 apply调用；</li><li>箭头函数中，this指向函数上层作用域的this；</li></ul></li><li><strong>构造器</strong>和<strong>普通函数</strong>的区别在于<code>被调用的方式</code>；</li><li>A,call(B) =&gt; 可以理解成在B的作用域内调用了A方法；</li></ul><h4 id="1-1-作为对象的方法调用"><a href="#1-1-作为对象的方法调用" class="headerlink" title="1.1 作为对象的方法调用"></a>1.1 作为对象的方法调用</h4><p>当函数作为对象的方法被调用时，<code>this指向该对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;gaoyuan&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span> === obj);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.getName(); <span class="comment">// true gaoyuan</span></span><br></pre></td></tr></table></figure><h4 id="1-2-作为普通函数调用"><a href="#1-2-作为普通函数调用" class="headerlink" title="1.2 作为普通函数调用"></a>1.2 作为普通函数调用</h4><p>当函数不作为对象的属性被调用，而是以普通函数的方式，this总是指向全局对象（在浏览器中，通常是Window对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getName(); <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure><p>或者下面这段迷惑性的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">&#x27;老王&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;gaoyuan&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNew = obj.getName;</span><br><span class="line">getNew(); <span class="comment">// 老王</span></span><br></pre></td></tr></table></figure><p>而在ES5的严格模式下，this被规定为不会指向全局对象，而是<code>undefined</code></p><h4 id="1-3-构造器调用"><a href="#1-3-构造器调用" class="headerlink" title="1.3 构造器调用"></a>1.3 构造器调用</h4><p>除了一些内置函数，大部分Js中的函数都可以成为构造器，它们与普通函数没什么不同</p><p><strong>构造器</strong>和<strong>普通函数</strong>的区别在于<code>被调用的方式</code>： 当new运算符调用函数时，总是返回一个对象，this通常也指向这个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass()</span><br><span class="line">obj.name; <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure><p>但是，如果显式的返回了一个object对象，那么此次运算结果最终会返回这个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;myClass.name:&#x27;</span>, myClass.name); <span class="comment">// &#123; name: 2&#125;</span></span><br></pre></td></tr></table></figure><p>只要构造器不显示的返回任何数据，或者返回非对象类型的数据，就不会造成上述问题。</p><h4 id="1-4-call或apply调用"><a href="#1-4-call或apply调用" class="headerlink" title="1.4 call或apply调用"></a>1.4 call或apply调用</h4><p>跟普通的函数调用相比，用call和apply可以动态的改变函数的this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="number">1</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params">num = <span class="string">&#x27;&#x27;</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以理解成在 obj2的作用域下调用了 obj1.getName()函数</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName.call(obj2, <span class="number">2</span>)); <span class="comment">// 2 + 2 = 4</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName.apply(obj2, [<span class="number">2</span>])); <span class="comment">// 2 + 2 = 4</span></span><br></pre></td></tr></table></figure><h4 id="1-5-箭头函数"><a href="#1-5-箭头函数" class="headerlink" title="1.5 箭头函数"></a>1.5 箭头函数</h4><p>箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.name = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    getName: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getName()</span><br></pre></td></tr></table></figure><h4 id="1-6-常见的坑"><a href="#1-6-常见的坑" class="headerlink" title="1.6 常见的坑"></a>1.6 常见的坑</h4><p>就像标题一样，有的时候<code>this</code>会指向undefined</p><p><strong>情况一</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName2 = obj.getName;</span><br><span class="line">getName2()</span><br></pre></td></tr></table></figure><p>这个时候，getName2()作为普通函数被调用时，this指向全局对象——window。</p><p><strong>情况二</strong></p><p>当我们希望自己封装Dom方法，来精简代码时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getDomById = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;;</span><br><span class="line">getDomById(<span class="string">&#x27;div1&#x27;</span>) <span class="comment">//dom节点</span></span><br></pre></td></tr></table></figure><p>那么我们看看这么写行不行？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getDomById = <span class="built_in">document</span>.getElementById</span><br><span class="line">getDomById(<span class="string">&#x27;div1&#x27;</span>) <span class="comment">// Uncaught TypeError: Illegal invocation(非法调用)</span></span><br></pre></td></tr></table></figure><p>这是因为:</p><ul><li>当我们去调用<code>document</code>对象的方法时，方法内的this指向<code>document</code>。</li><li>当我们用getId应用document内的方法，再以普通函数的方式调用，函数内容的this就指向了全局对象。</li></ul><p><strong>利用call和apply修正情况二</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(<span class="built_in">document</span>, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="built_in">document</span>.getElementById)</span><br><span class="line"><span class="comment">// 利用立即执行函数将document保存在作用域中</span></span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=2299180848,518697654&fm=26&gp=0.jpeg"></p><h3 id="二、call和apply"><a href="#二、call和apply" class="headerlink" title="二、call和apply"></a>二、call和apply</h3><p>不要因为它的“强大”而对它产生抗拒，了解并熟悉它是我们必须要做的，共勉！</p><h4 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h4><p><img data-src="https://img-blog.csdnimg.cn/20200602153648211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="1-call和apply区别"><a href="#1-call和apply区别" class="headerlink" title="1.call和apply区别"></a>1.call和apply区别</h4><p>先来看区别，是因为它们<strong>几乎</strong>没有区别，下文代码实例call和apply都可以轻易的切换。</p><p>当它们被设计出来时要做到的事情一摸一样，唯一的区别就在于<code>传参的格式不一样</code></p><ul><li>apply接受两个参数<ul><li>第一个参数指定了函数体内this对象的指向</li><li>第二个参数为一个带下标的参数集合（可以是数组或者类数组）</li></ul></li><li>call接受的参数不固定<ul><li>第一个参数指定了函数体内this对象的指向</li><li>第二个参数及以后为函数调用的参数</li></ul></li></ul><p>因为在所有（非箭头）函数中都可以通过<code>arguments</code>对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，它本身就是一个类数组，我们apply在实际使用中更常见一些。</p><p>call是包装在apply上面的语法糖，如果我们明确的知道参数数量，并且希望展示它们，可以使用call。</p><p>当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会默认指向宿主对象，在浏览器中则是<code>window</code>。</p><p><strong>借用其他对象的方法</strong></p><p>我们可以直接传null来代替任意对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure><h4 id="2-call和apply能做什么？"><a href="#2-call和apply能做什么？" class="headerlink" title="2.call和apply能做什么？"></a>2.call和apply能做什么？</h4><p>使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数——来时<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN(opens new window)</a></p><ul><li>调用构造函数来<code>实现继承</code>;</li><li>调用函数并且指定上下文的 <code>this</code>;</li><li>调用函数并且不指定第一个参数;</li></ul><p><strong>1.调用构造函数来实现继承</strong></p><p>通过“借用”的方式来达到继承的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">Product.call(<span class="built_in">this</span>, name, price); <span class="comment">//</span></span><br><span class="line"><span class="built_in">this</span>.category = food;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hotDog = <span class="keyword">new</span> Food(<span class="string">&#x27;hotDog&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><strong>2.调用函数并且指定上下文的 <code>this</code></strong></p><p>此时this被指向了obj</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">&#x27;gaoyuan&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">showName.call(obj)</span><br></pre></td></tr></table></figure><p><strong>3.使用call单纯的调用某个函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>]); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=826503588,4160798134&fm=15&gp=0.jpeg"></p><h3 id="三、模拟实现一个call"><a href="#三、模拟实现一个call" class="headerlink" title="三、模拟实现一个call"></a>三、模拟实现一个call</h3><p>先来看一下call帮我们需要做什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;;</span><br><span class="line">show.call(foo); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>就像解方程，要在已知条件中寻找突破哦口：</p><ul><li><code>call</code> 使得this的指向变了，指向了foo;</li><li><code>show</code> 函数被执行了;</li><li>传入的参数应为 <code>this</code> + 参数列表;</li></ul><p><strong>第一版代码</strong></p><p>上面提到的3点，仅仅完成了一点，且传入的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.setCall = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// 此时this指向show</span></span><br><span class="line">    obj.func = <span class="built_in">this</span>; <span class="comment">// 将函数变成对象的内部属性</span></span><br><span class="line">    obj.func(obj.value) <span class="comment">// 指定函数</span></span><br><span class="line">    <span class="keyword">delete</span> obj.func <span class="comment">// 删除函数，当做什么都没发生～</span></span><br><span class="line">&#125;</span><br><span class="line">show.setCall(foo)</span><br></pre></td></tr></table></figure><p><strong>第二版代码</strong></p><p>为了解决参数的问题，我们要能获取到参数，并且正确的传入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.setCall = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>; <span class="comment">// 将函数变成对象的内部属性</span></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&#x27;obj.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>); <span class="comment">// 传入参数</span></span><br><span class="line">    <span class="keyword">delete</span> obj.fn; <span class="comment">// 删除函数，当做什么都没发生～</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show.setCall(foo, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure><p>此时，我们就可以做到，传入多个参数的情况下使用call了，但是如果你仅想用某个方法呢？</p><p><strong>第三版代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.setCall = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = obj || <span class="built_in">window</span>;</span><br><span class="line">  obj.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;obj.fn(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  <span class="keyword">delete</span> obj.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="built_in">this</span>.value,</span><br><span class="line">    name: name,</span><br><span class="line">    age: age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">bar.setCall(<span class="literal">null</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.setCall(obj, <span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>));</span><br></pre></td></tr></table></figure><h3 id="四、bind"><a href="#四、bind" class="headerlink" title="四、bind"></a>四、bind</h3><p>提到了<strong>call</strong>和<strong>apply</strong>，就绕不开**bind()<strong>，来看一下MDN上对</strong>bind()**的解释：</p><p>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><p>我们用Js来模拟一个bind方法，以便加深我们的认识</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(func, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="number">1</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">func.bind(obj)</span><br></pre></td></tr></table></figure><p>这样看上去，bind总会帮我们返回同样的<code>this</code>值，还是挺坚挺的哦～</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一、this的指向&quot;&gt;&lt;a href=&quot;#一、this的指向&quot; class=&quot;headerlink&quot; title=&quot;一、this的指向&quot;&gt;&lt;/a&gt;一、this的指向&lt;/h3&gt;&lt;p&gt;百度、谷歌上输入“this的指向”关键字，大几千条文章肯定是有的，总不至于为了全方面、无死角的掌握它就要将所有的文章都看一遍吧？所以不如梳理出一个稳固的框架，我们一起来填充它。&lt;/p&gt;
&lt;h4 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink&quot; title=&quot;思维导图&quot;&gt;&lt;/a&gt;思维导图&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&quot;https://img-blog.csdnimg.cn/20200602110330766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="javascript" scheme="http://example.com/categories/javascript/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>函数防抖与节流</title>
    <link href="http://example.com/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>http://example.com/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2021-03-19T01:43:56.000Z</published>
    <updated>2021-03-19T01:58:55.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><h3 id="一、为什么需要防抖"><a href="#一、为什么需要防抖" class="headerlink" title="一、为什么需要防抖"></a>一、为什么需要防抖</h3><ul><li>高频的函数操作可能产生不好的影响</li><li>如：resize、scroll、mousedown、mousemove、keyup、keydown……</li></ul><p>为此，我们举个示例代码来了解事件如何频繁的触发：</p><p>我们写一个 index.html 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;title&gt;debounce&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #wrapper &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            line-height: 200px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            color: #fff;</span><br><span class="line">            background-color: #444;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;wrapper&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var count &#x3D; 1;</span><br><span class="line">        var oDiv &#x3D; document.getElementById(&quot;wrapper&quot;);</span><br><span class="line">        function getUserAction() &#123;</span><br><span class="line">            oDiv.innerHTML &#x3D; count++;</span><br><span class="line">        &#125;</span><br><span class="line">        oDiv.onmousemove &#x3D; getUserAction;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><span id="more"></span><p>从左边滑到右边就触发了近100次<code>getUserAction</code> 函数！看如下Gif：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408456-269506ee-a343-41c8-86b8-e80da9304d8e.gif"></p><p>因为这个例子很简单，所以浏览器完全反应的过来，但假设：</p><ul><li>它的触发频次极高，1分钟2000次，且涉及到大量的位置计算、DOM 操作等工作，</li><li>存在接口请求，单个函数执行时间较长，但每个函数触发的间隔很近。</li></ul><p>这种在一瞬间（短时间内）对浏览器或服务器造成了过多压力的交互就需要进行优化了，为了解决这个问题，一般有两种解决方案：</p><ul><li>debounce 防抖</li><li>throttle 节流</li></ul><p>他们的目的都是：<strong>降低一个函数的触发频率，以提高性能或避免资源浪费。</strong></p><h3 id="二、防抖的原理"><a href="#二、防抖的原理" class="headerlink" title="二、防抖的原理"></a>二、防抖的原理</h3><p>今天重点讲讲防抖的实现。</p><p>防抖的原理就是：你尽管触发事件，但是我一定在事件触发<code>n秒无操作后</code>才执行。举个例子：</p><p>我们规定<code>3s</code>为防抖的标准，那么:</p><ol><li>第一次要求执行事件 - 此时倒计时3s</li><li>倒计时2s</li><li>倒计时1s</li><li>0.5s时事件再次被触发 - 此时倒计时3s</li><li>…3s内无事发生</li><li>执行事件，共用了5.5s</li></ol><h3 id="三、自己实现一个防抖"><a href="#三、自己实现一个防抖" class="headerlink" title="三、自己实现一个防抖"></a>三、自己实现一个防抖</h3><h4 id="3-1-第一版"><a href="#3-1-第一版" class="headerlink" title="3.1 第一版"></a>3.1 第一版</h4><p>我们根据上一节提到的核心思想，实现第一版代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer &#x3D; setTimeout(func, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要使用它，第一节的例子为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oDiv.onmousemove &#x3D; debounce(getUserAction, 2000);</span><br></pre></td></tr></table></figure><p>此时大家可以再次测试一下，事件持续发生时，只有在完全停止2s后，才会触发事件：</p><p>写到这里，作为针对部分高频事件的需求来说，已经结束了。我们来看看他的效果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408554-b0245fd8-1c4d-4085-80da-f91d8be8da6f.gif"></p><h4 id="3-2-第二版"><a href="#3-2-第二版" class="headerlink" title="3.2 第二版"></a>3.2 第二版</h4><p>大家都知道，dom节点在触发事件的时候，this指向它本身，本例中则指向<code>oDiv</code>，但是在本例中：我们看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 1;</span><br><span class="line">var oDiv &#x3D; document.getElementById(&quot;oDiv&quot;);</span><br><span class="line">function getUserAction() &#123;</span><br><span class="line">    oDiv.innerHTML &#x3D; count++;</span><br><span class="line">    console.log(&#39;this&#39;, this); &#x2F;&#x2F; 此时输出 Window...</span><br><span class="line">&#125;</span><br><span class="line">oDiv.onmousemove &#x3D; debounce(getUserAction, 2000);</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer &#x3D; setTimeout(func, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毕竟经过了一层匿名函数的包裹，this已经指向了window，为了减少影响，我们尝试修正它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this &#x3D; this; &#x2F;&#x2F; 记录当前this</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer &#x3D; setTimeout(function()&#123;</span><br><span class="line">            func.apply(_this); &#x2F;&#x2F;将 func的this改为_this</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-第三版"><a href="#3-3-第三版" class="headerlink" title="3.3 第三版"></a>3.3 第三版</h4><p>解决的this指向问题，我们的函数仍然不够“完美”，JavaScript中，事件处理函数会提供<code>event</code>对象，我们简称为e。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用了 debouce 函数</span><br><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    console.log(e); &#x2F;&#x2F; undefined</span><br><span class="line">    oDiv.innerHTML &#x3D; count++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了保证它的原汁原味，我们再改第三版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 1;</span><br><span class="line">var oDiv &#x3D; document.getElementById(&quot;oDiv&quot;);</span><br><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    oDiv.innerHTML &#x3D; count++;</span><br><span class="line">    console.log(&#39;e&#39;, e); &#x2F;&#x2F; MouseEvent</span><br><span class="line">&#125;</span><br><span class="line">oDiv.onmousemove &#x3D; debounce(getUserAction, 2000);</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this &#x3D; this; &#x2F;&#x2F; 记录当前this</span><br><span class="line">        var arg &#x3D; arguments; &#x2F;&#x2F; 记录参数</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">            func.apply(_this, arg); &#x2F;&#x2F;将 func的this改为_this</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们在尽可能保留Dom事件原有能力的情况下，给函数加上了防抖效果，它可以解决大部分我们日常开发的防抖问题，但我们需要更“完美”</p><h3 id="四、防抖进阶"><a href="#四、防抖进阶" class="headerlink" title="四、防抖进阶"></a>四、防抖进阶</h3><h4 id="4-1-立即执行"><a href="#4-1-立即执行" class="headerlink" title="4.1 立即执行"></a>4.1 立即执行</h4><p>这个需求就是：</p><ul><li>立即执行</li><li>保持<code>n</code>秒空白期</li><li>将<code>n</code>秒空白期置后</li></ul><p>想想这个需求也是很有道理的嘛，那我们加个<code>immediate</code>参数判断是否是立刻执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line">        if (timer) clearTimeout(timer); &#x2F;&#x2F; 常规流程，间隔内触发时清掉重置定时</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果已经执行过，不再执行</span><br><span class="line">            var callNow &#x3D; !timer; &#x2F;&#x2F; 1. callNow 初始值是 true, 同步立即执行；随后 timer 才开始执行</span><br><span class="line">            timer &#x3D; setTimeout(function()&#123;</span><br><span class="line">                timer &#x3D; null; &#x2F;&#x2F; wait 期间，timer 是一个 ID 数字，所以 callNow 为 false，func 在此期间永远不会执行</span><br><span class="line">            &#125;, wait) &#x2F;&#x2F; wait 之后，timer 赋值 null，callNow 为 true，func 又开始立即执行。</span><br><span class="line">            if (callNow) func.apply(_this, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timer &#x3D; setTimeout(function()&#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看下此时他是什么效果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408487-78c69123-24ec-4893-b442-366d3117eda2.gif"></p><h4 id="4-2-添加简单验证"><a href="#4-2-添加简单验证" class="headerlink" title="4.2 添加简单验证"></a>4.2 添加简单验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    &#x2F;&#x2F; 检查函数</span><br><span class="line">    if (typeof func !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        throw new TypeError(&#39;Expected a function&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 保证wait存在</span><br><span class="line">    wait &#x3D; +wait || 0;</span><br><span class="line">    const debounced &#x3D; function () &#123;</span><br><span class="line">        var _this &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line">        if (timer) clearTimeout(timer); &#x2F;&#x2F; 常规流程，间隔内触发时清掉重置定时</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果已经执行过，不再执行</span><br><span class="line">            var callNow &#x3D; !timer; &#x2F;&#x2F; 如果不存在定时器，则callNow为true</span><br><span class="line">            timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">                timer &#x3D; null; &#x2F;&#x2F; 为了保证之后的时效性，手动添加timer</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            &#x2F;&#x2F; 因为不存在timer，证明是首次执行，所以直接调用</span><br><span class="line">            if (callNow) func.apply(_this, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-添加取消事件方法"><a href="#4-3-添加取消事件方法" class="headerlink" title="4.3 添加取消事件方法"></a>4.3 添加取消事件方法</h4><p>如果你希望能取消被防抖的事件，我们可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    &#x2F;&#x2F; 检查函数</span><br><span class="line">    if (typeof func !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        throw new TypeError(&#39;Expected a function&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 保证wait存在</span><br><span class="line">    wait &#x3D; +wait || 0;</span><br><span class="line">    const debounced &#x3D; function () &#123;</span><br><span class="line">        var _this &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line">        if (timer) clearTimeout(timer); &#x2F;&#x2F; 常规流程，间隔内触发时清掉重置定时</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果已经执行过，不再执行</span><br><span class="line">            var callNow &#x3D; !timer; &#x2F;&#x2F; 如果不存在定时器，则callNow为true</span><br><span class="line">            timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">                timer &#x3D; null; &#x2F;&#x2F; 为了保证之后的时效性，手动添加timer</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            &#x2F;&#x2F; 因为不存在timer，证明是首次执行，所以直接调用</span><br><span class="line">            if (callNow) func.apply(_this, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const cancel &#x3D; function()&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    const pending &#x3D; function()&#123;</span><br><span class="line">        return timer !&#x3D;&#x3D; undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.cancel &#x3D; cancel;</span><br><span class="line">    debounced.pending &#x3D; pending;</span><br><span class="line">    return debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看效果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408427-b468ccd4-99ff-4eee-821a-290d95e04071.gif"></p><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们还是以移动事件举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #wrapper &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 140px;</span><br><span class="line">            background: rgba(0, 0, 0, 0.8);</span><br><span class="line">            color: #fff;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">            font-weight: bold;</span><br><span class="line">            line-height: 140px;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;wrapper&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var count &#x3D; 1;</span><br><span class="line">        function moveAction () &#123;</span><br><span class="line">            oWrapper.innerHTML &#x3D; count++;</span><br><span class="line">        &#125;</span><br><span class="line">        var oWrapper &#x3D; document.querySelector(&#39;#wrapper&#39;);</span><br><span class="line">        oWrapper.onmousemove &#x3D; moveAction;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>它的效果是这样：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551747-de70166f-f851-412c-ba2a-5a116a194f3d.gif"></p><h3 id="一、核心和基本实现"><a href="#一、核心和基本实现" class="headerlink" title="一、核心和基本实现"></a>一、核心和基本实现</h3><p>节流的原理很简单：<strong>如果你持续触发某个事件，特定的时间间隔内，只执行一次。</strong></p><p><strong>关于节流的实现，有两种主流的实现方式：</strong></p><ol><li>时间戳思路</li><li>定时器思路</li></ol><h4 id="1-1-时间戳思路"><a href="#1-1-时间戳思路" class="headerlink" title="1.1 时间戳思路"></a>1.1 时间戳思路</h4><p>顾名思义，通过两个时间戳来控制时间间隔，当触发事件的时候：</p><ol><li>我们取出当前的时间戳 <code>now</code>；</li><li>然后减去之前<strong>执行时</strong>的时间戳(首次值为 0 ) <code>prev</code>；</li><li>如果大<code>now - prev &gt; wait</code>，证明时间区间维护结束，执行指定事件，更新<code>prev</code>；</li></ol><p>根据这一思路，我们就可以实现第一版代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">oWrapper.onmousemove &#x3D; throttle(moveAction, 1000);</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var _this, arg;</span><br><span class="line">    var prev &#x3D; 0; &#x2F;&#x2F; 上一次触发的时间，第一次默认为0</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var now &#x3D; Date.now(); &#x2F;&#x2F; 触发时的时间</span><br><span class="line">        _this &#x3D; this;</span><br><span class="line">        if (now - prev &gt; wait) &#123;</span><br><span class="line">            func.apply(_this, arg); &#x2F;&#x2F; 允许传入参数，并修正this</span><br><span class="line">            prev &#x3D; now; &#x2F;&#x2F; 更新上一次触发的时间</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看借助它，效果是什么样的：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740552204-2bb5f2b1-3807-4d26-b3eb-d34e798ab60a.gif"></p><p>我们可以看到：</p><ol><li>当鼠标移入的时候，<strong>事件立刻执行</strong></li><li>每过 1s 会执行一次，且移动2.5s会执行2次，意味着动作<strong>停止后不会再执行</strong>。</li></ol><h4 id="1-2-定时器思路"><a href="#1-2-定时器思路" class="headerlink" title="1.2 定时器思路"></a>1.2 定时器思路</h4><p>利用定时器来保证间隔时间内事件的触发次数</p><ol><li>创建定时器<code>timer</code>，记录当前是否在<strong>周期</strong>内；</li><li>判断定时器是否存在，若存在则直接结束，否则执行事件；</li><li><code>wait</code>时间之后再次执行，并清掉定时器；</li></ol><p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var _this, arg;</span><br><span class="line">    var timer; &#x2F;&#x2F; 初始化</span><br><span class="line">    return function () &#123;</span><br><span class="line">        _this &#x3D; this; &#x2F;&#x2F; 记录this</span><br><span class="line">        arg &#x3D; arguments; &#x2F;&#x2F; 记录参数数组</span><br><span class="line">        if (timer) return; &#x2F;&#x2F; 时候未到</span><br><span class="line">        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            func.apply(_this, arg); &#x2F;&#x2F; 允许传入参数，并修正this</span><br><span class="line">            timer &#x3D; null;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看借助它，效果是什么样的：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551861-12bc2cce-f80a-45ff-9913-7798160b3438.gif"></p><p>但是，我们可以看到：</p><ol><li>当鼠标移入的时候，事件不会立刻执行;</li><li>鼠标定制后<code>wait</code>间隔后会执行一次</li></ol><h4 id="1-3-两种思路的区别"><a href="#1-3-两种思路的区别" class="headerlink" title="1.3 两种思路的区别"></a>1.3 两种思路的区别</h4><table><thead><tr><th></th><th>时间戳</th><th>定时器</th></tr></thead><tbody><tr><td>“起点”</td><td>立即执行</td><td>n 秒后执行</td></tr><tr><td>“终点”</td><td>停止后不会执行</td><td>停止会再执行一次</td></tr></tbody></table><h3 id="二、节流进阶"><a href="#二、节流进阶" class="headerlink" title="二、节流进阶"></a>二、节流进阶</h3><p>结合两种思想完成一个可以立即执行，且停止触发后再执行一次的节流方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous &#x3D; 0;</span><br><span class="line">    var later &#x3D; function() &#123;</span><br><span class="line">        previous &#x3D; +new Date();</span><br><span class="line">        timeout &#x3D; null;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">    &#125;;</span><br><span class="line">    var throttled &#x3D; function() &#123;</span><br><span class="line">        var now &#x3D; +new Date();</span><br><span class="line">        &#x2F;&#x2F;下次触发 func 剩余的时间</span><br><span class="line">        var remaining &#x3D; wait - (now - previous);</span><br><span class="line">        context &#x3D; this;</span><br><span class="line">        args &#x3D; arguments;</span><br><span class="line">         &#x2F;&#x2F; 如果没有剩余的时间了或者你改了系统时间</span><br><span class="line">        if (remaining &lt;&#x3D; 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous &#x3D; now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">        &#125; else if (!timeout) &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551783-4d2e4584-8e32-4ca2-a1de-c2ab865a882c.gif"></p><p>我在看代码的时候，我是反复打印数据才理解为什么会这样做，一起加油～</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;函数防抖&quot;&gt;&lt;a href=&quot;#函数防抖&quot; class=&quot;headerlink&quot; title=&quot;函数防抖&quot;&gt;&lt;/a&gt;函数防抖&lt;/h2&gt;&lt;h3 id=&quot;一、为什么需要防抖&quot;&gt;&lt;a href=&quot;#一、为什么需要防抖&quot; class=&quot;headerlink&quot; title=&quot;一、为什么需要防抖&quot;&gt;&lt;/a&gt;一、为什么需要防抖&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;高频的函数操作可能产生不好的影响&lt;/li&gt;
&lt;li&gt;如：resize、scroll、mousedown、mousemove、keyup、keydown……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为此，我们举个示例代码来