<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript基础（一）this</title>
    <url>/2021/03/20/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89this/</url>
    <content><![CDATA[<h3 id="一、this的指向"><a href="#一、this的指向" class="headerlink" title="一、this的指向"></a>一、this的指向</h3><p>百度、谷歌上输入“this的指向”关键字，大几千条文章肯定是有的，总不至于为了全方面、无死角的掌握它就要将所有的文章都看一遍吧？所以不如梳理出一个稳固的框架，我们一起来填充它。</p>
<h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><p><img data-src="https://img-blog.csdnimg.cn/20200602110330766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<span id="more"></span>

<ul>
<li>this 总是（非严格模式下）指向一个对象，而具体指向哪个对象是在运行时基于函数的<code>执行环境</code>动态绑定的，而非函数被声明时的环境；</li>
<li>除了不常用的with和eval的情况，具体到实际应用中，this指向大概可以分为四种：<ul>
<li>作为对象的方法调用；</li>
<li>作为普通函数调用；</li>
<li>构造器调用；</li>
<li>call 或 apply调用；</li>
<li>箭头函数中，this指向函数上层作用域的this；</li>
</ul>
</li>
<li><strong>构造器</strong>和<strong>普通函数</strong>的区别在于<code>被调用的方式</code>；</li>
<li>A,call(B) =&gt; 可以理解成在B的作用域内调用了A方法；</li>
</ul>
<h4 id="1-1-作为对象的方法调用"><a href="#1-1-作为对象的方法调用" class="headerlink" title="1.1 作为对象的方法调用"></a>1.1 作为对象的方法调用</h4><p>当函数作为对象的方法被调用时，<code>this指向该对象</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;gaoyuan&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span> === obj);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.getName(); <span class="comment">// true gaoyuan</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-作为普通函数调用"><a href="#1-2-作为普通函数调用" class="headerlink" title="1.2 作为普通函数调用"></a>1.2 作为普通函数调用</h4><p>当函数不作为对象的属性被调用，而是以普通函数的方式，this总是指向全局对象（在浏览器中，通常是Window对象）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getName(); <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure>

<p>或者下面这段迷惑性的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">&#x27;老王&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;gaoyuan&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNew = obj.getName;</span><br><span class="line">getNew(); <span class="comment">// 老王</span></span><br></pre></td></tr></table></figure>

<p>而在ES5的严格模式下，this被规定为不会指向全局对象，而是<code>undefined</code></p>
<h4 id="1-3-构造器调用"><a href="#1-3-构造器调用" class="headerlink" title="1.3 构造器调用"></a>1.3 构造器调用</h4><p>除了一些内置函数，大部分Js中的函数都可以成为构造器，它们与普通函数没什么不同</p>
<p><strong>构造器</strong>和<strong>普通函数</strong>的区别在于<code>被调用的方式</code>： 当new运算符调用函数时，总是返回一个对象，this通常也指向这个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass()</span><br><span class="line">obj.name; <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure>

<p>但是，如果显式的返回了一个object对象，那么此次运算结果最终会返回这个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;myClass.name:&#x27;</span>, myClass.name); <span class="comment">// &#123; name: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>只要构造器不显示的返回任何数据，或者返回非对象类型的数据，就不会造成上述问题。</p>
<h4 id="1-4-call或apply调用"><a href="#1-4-call或apply调用" class="headerlink" title="1.4 call或apply调用"></a>1.4 call或apply调用</h4><p>跟普通的函数调用相比，用call和apply可以动态的改变函数的this</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="number">1</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params">num = <span class="string">&#x27;&#x27;</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以理解成在 obj2的作用域下调用了 obj1.getName()函数</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName.call(obj2, <span class="number">2</span>)); <span class="comment">// 2 + 2 = 4</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName.apply(obj2, [<span class="number">2</span>])); <span class="comment">// 2 + 2 = 4</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5-箭头函数"><a href="#1-5-箭头函数" class="headerlink" title="1.5 箭头函数"></a>1.5 箭头函数</h4><p>箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.name = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    getName: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getName()</span><br></pre></td></tr></table></figure>

<h4 id="1-6-常见的坑"><a href="#1-6-常见的坑" class="headerlink" title="1.6 常见的坑"></a>1.6 常见的坑</h4><p>就像标题一样，有的时候<code>this</code>会指向undefined</p>
<p><strong>情况一</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName2 = obj.getName;</span><br><span class="line">getName2()</span><br></pre></td></tr></table></figure>

<p>这个时候，getName2()作为普通函数被调用时，this指向全局对象——window。</p>
<p><strong>情况二</strong></p>
<p>当我们希望自己封装Dom方法，来精简代码时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getDomById = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;;</span><br><span class="line">getDomById(<span class="string">&#x27;div1&#x27;</span>) <span class="comment">//dom节点</span></span><br></pre></td></tr></table></figure>

<p>那么我们看看这么写行不行？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getDomById = <span class="built_in">document</span>.getElementById</span><br><span class="line">getDomById(<span class="string">&#x27;div1&#x27;</span>) <span class="comment">// Uncaught TypeError: Illegal invocation(非法调用)</span></span><br></pre></td></tr></table></figure>

<p>这是因为:</p>
<ul>
<li>当我们去调用<code>document</code>对象的方法时，方法内的this指向<code>document</code>。</li>
<li>当我们用getId应用document内的方法，再以普通函数的方式调用，函数内容的this就指向了全局对象。</li>
</ul>
<p><strong>利用call和apply修正情况二</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(<span class="built_in">document</span>, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="built_in">document</span>.getElementById)</span><br><span class="line"><span class="comment">// 利用立即执行函数将document保存在作用域中</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=2299180848,518697654&fm=26&gp=0.jpeg"></p>
<h3 id="二、call和apply"><a href="#二、call和apply" class="headerlink" title="二、call和apply"></a>二、call和apply</h3><p>不要因为它的“强大”而对它产生抗拒，了解并熟悉它是我们必须要做的，共勉！</p>
<h4 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h4><p><img data-src="https://img-blog.csdnimg.cn/20200602153648211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="1-call和apply区别"><a href="#1-call和apply区别" class="headerlink" title="1.call和apply区别"></a>1.call和apply区别</h4><p>先来看区别，是因为它们<strong>几乎</strong>没有区别，下文代码实例call和apply都可以轻易的切换。</p>
<p>当它们被设计出来时要做到的事情一摸一样，唯一的区别就在于<code>传参的格式不一样</code></p>
<ul>
<li>apply接受两个参数<ul>
<li>第一个参数指定了函数体内this对象的指向</li>
<li>第二个参数为一个带下标的参数集合（可以是数组或者类数组）</li>
</ul>
</li>
<li>call接受的参数不固定<ul>
<li>第一个参数指定了函数体内this对象的指向</li>
<li>第二个参数及以后为函数调用的参数</li>
</ul>
</li>
</ul>
<p>因为在所有（非箭头）函数中都可以通过<code>arguments</code>对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，它本身就是一个类数组，我们apply在实际使用中更常见一些。</p>
<p>call是包装在apply上面的语法糖，如果我们明确的知道参数数量，并且希望展示它们，可以使用call。</p>
<p>当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会默认指向宿主对象，在浏览器中则是<code>window</code>。</p>
<p><strong>借用其他对象的方法</strong></p>
<p>我们可以直接传null来代替任意对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<h4 id="2-call和apply能做什么？"><a href="#2-call和apply能做什么？" class="headerlink" title="2.call和apply能做什么？"></a>2.call和apply能做什么？</h4><p>使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数——来时<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN(opens new window)</a></p>
<ul>
<li>调用构造函数来<code>实现继承</code>;</li>
<li>调用函数并且指定上下文的 <code>this</code>;</li>
<li>调用函数并且不指定第一个参数;</li>
</ul>
<p><strong>1.调用构造函数来实现继承</strong></p>
<p>通过“借用”的方式来达到继承的效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">	Product.call(<span class="built_in">this</span>, name, price); <span class="comment">//</span></span><br><span class="line">	<span class="built_in">this</span>.category = food;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hotDog = <span class="keyword">new</span> Food(<span class="string">&#x27;hotDog&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2.调用函数并且指定上下文的 <code>this</code></strong></p>
<p>此时this被指向了obj</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">&#x27;gaoyuan&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">showName.call(obj)</span><br></pre></td></tr></table></figure>

<p><strong>3.使用call单纯的调用某个函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>]); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=826503588,4160798134&fm=15&gp=0.jpeg"></p>
<h3 id="三、模拟实现一个call"><a href="#三、模拟实现一个call" class="headerlink" title="三、模拟实现一个call"></a>三、模拟实现一个call</h3><p>先来看一下call帮我们需要做什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">	value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;;</span><br><span class="line">show.call(foo); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>就像解方程，要在已知条件中寻找突破哦口：</p>
<ul>
<li><code>call</code> 使得this的指向变了，指向了foo;</li>
<li><code>show</code> 函数被执行了;</li>
<li>传入的参数应为 <code>this</code> + 参数列表;</li>
</ul>
<p><strong>第一版代码</strong></p>
<p>上面提到的3点，仅仅完成了一点，且传入的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.setCall = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// 此时this指向show</span></span><br><span class="line">    obj.func = <span class="built_in">this</span>; <span class="comment">// 将函数变成对象的内部属性</span></span><br><span class="line">    obj.func(obj.value) <span class="comment">// 指定函数</span></span><br><span class="line">    <span class="keyword">delete</span> obj.func <span class="comment">// 删除函数，当做什么都没发生～</span></span><br><span class="line">&#125;</span><br><span class="line">show.setCall(foo)</span><br></pre></td></tr></table></figure>

<p><strong>第二版代码</strong></p>
<p>为了解决参数的问题，我们要能获取到参数，并且正确的传入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.setCall = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>; <span class="comment">// 将函数变成对象的内部属性</span></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&#x27;obj.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>); <span class="comment">// 传入参数</span></span><br><span class="line">    <span class="keyword">delete</span> obj.fn; <span class="comment">// 删除函数，当做什么都没发生～</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show.setCall(foo, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>

<p>此时，我们就可以做到，传入多个参数的情况下使用call了，但是如果你仅想用某个方法呢？</p>
<p><strong>第三版代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.setCall = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = obj || <span class="built_in">window</span>;</span><br><span class="line">  obj.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;obj.fn(&#x27;</span> + args +<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  <span class="keyword">delete</span> obj.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="built_in">this</span>.value,</span><br><span class="line">    name: name,</span><br><span class="line">    age: age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">bar.setCall(<span class="literal">null</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.setCall(obj, <span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>));</span><br></pre></td></tr></table></figure>

<h3 id="四、bind"><a href="#四、bind" class="headerlink" title="四、bind"></a>四、bind</h3><p>提到了<strong>call</strong>和<strong>apply</strong>，就绕不开**bind()<strong>，来看一下MDN上对</strong>bind()**的解释：</p>
<p>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<p>我们用Js来模拟一个bind方法，以便加深我们的认识</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(func, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="number">1</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">func.bind(obj)</span><br></pre></td></tr></table></figure>

<p>这样看上去，bind总会帮我们返回同样的<code>this</code>值，还是挺坚挺的哦～</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS和HTTP原理和区别</title>
    <url>/2020/12/16/HTTPS%E5%92%8CHTTP%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>一、HTTP 和 HTTPS 的基本概念<br>HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p>
<p>HTTP 原理：</p>
<p>①  客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。</p>
<p>②  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p>
<span id="more"></span>

<p>HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p>​​<img data-src="https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70">                                    </p>
<!-- more -->

<p>HTTPS 设计目标：</p>
<p>(1) 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</p>
<p>(2) 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</p>
<p>(3) 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</p>
<p>二、HTTP 与 HTTPS  的区别<br>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p>
<p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p>
<p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
<p>三、HTTPS 相对于 HTTP 的改进<br>双向的身份认证</p>
<p>客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证 。具体过程如下：</p>
<p>客户端发起 SSL 握手消息给服务端要求连接。</p>
<p>服务端将证书发送给客户端。</p>
<p>客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。</p>
<p>服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。</p>
<p>注意：</p>
<p>(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。</p>
<p>(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p>
<p>(3) 客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p>
<p>数据传输的机密性</p>
<p>客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA)，数据签名摘要算法 ( 一般是SHA或者MD5) ，加密传输数据的对称加密算法 ( 一般是DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。</p>
<p>防止重放攻击</p>
<p>SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</p>
<p>可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。</p>
<p>四、HTTPS 的优点<br>1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</p>
<p>2、HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</p>
<p>3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<p>五、HTTPS 的缺点（对比优点）<br>1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。</p>
<p>2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</p>
<p>3、HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</p>
<p>4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</p>
<p>5、成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</p>
<p>6、HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</p>
<p>六、HTTPS 的连接过程</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180709141944471"></p>
<p>图片中的过程是按 8 个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。</p>
<p>① 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p>
<p>② 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p>
<p>③ 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 “发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</p>
<p>④ 用户端随机产生一个用于通讯的 “对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</p>
<p>⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。</p>
<p>⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA  是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p>
<p>⑦ 服务器和客户端用相同的对称加密密钥，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p>
<p>⑧ 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p>
<p>⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p>
<p>⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p>
<p>上述的过程需要弄懂的核心思想<br>客户端解析证书</p>
<p>这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个对称加密密钥，然后用公钥对该密钥进行非对称加密。</p>
<p>传送加密信息</p>
<p>这部分传送的是用公钥加密后的对称加密密钥，目的就是让服务端得到这个密钥，以后客户端和服务端的通信就可以通过这个密钥来进行加密解密了。</p>
<p>服务端解密信息</p>
<p>服务端用非对称加密算法里的私钥解密后，得到了客户端传过来的对称加密算法的私钥，然后把之后传输的内容通过该值进行对称加密。</p>
<p>为什么用非对称加密协商对称加密密钥</p>
<p>对称加密的特点：对称密码体制中只有一种密钥，并且是非公开的。如果要解密就得让对方知道密钥，所以想要保证其安全性就要保证密钥的安全。</p>
<p>非对称加密的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了，这样安全性就大了很多。</p>
<p>非对称加密公钥和私钥的使用方法：(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。</p>
<p>补充：<br>SSL 提供服务<br>(1) 认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>(2) 加密数据以防止数据中途被窃取；</p>
<p>(3) 维护数据的完整性，确保数据在传输过程中不被改变。</p>
<p>SSL 工作流程<br>服务器认证阶段：</p>
<p>(1) 客户端向服务器发送一个开始信息 “Hello” 以便开始一个新的会话连接；</p>
<p>(2) 服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的 “Hello” 信息时将包含生成主密钥所需的信息；</p>
<p>(3) 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</p>
<p>(4) 服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p>
<p>用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p>
<p>SSL 协议提供的安全通道有以下三个特性：</p>
<p>机密性：SSL 协议使用密钥加密通信数据。</p>
<p>可靠性：服务器和客户都会被认证，客户的认证是可选的。</p>
<p>完整性：SSL 协议会对传送的数据进行完整性检查。</p>
<p>服务器证书(server certificates)是 SSL 数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成 Web 服务器的 SSL 安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户提供验证您 Web 站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现图片压缩</title>
    <url>/2021/02/11/JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<blockquote>
<p>说起图片压缩，大家想到的或者平时用到的很多工具都可以实现，例如，客户端类的有图片压缩工具 PPDuck3， JS 实现类的有插件 compression.js ，亦或是在线处理类的 OSS 上传，文件上传后，在访问文件时中也有图片的压缩配置选项，那能不能使用 JS 实现的图片压缩代码呢？当然可以，那我们先来理一下思路。</p>
</blockquote>
<h2 id="压缩思路"><a href="#压缩思路" class="headerlink" title="压缩思路"></a>压缩思路</h2><p>涉及到 JS 的图片压缩，我的想法是需要用到 Canvas 的绘图能力，通过调整图片的分辨率或者绘图质量来达到图片压缩的效果，实现思路如下：</p>
<ul>
<li>获取上传 Input 中的图片对象 File</li>
<li>将图片转换成 base64 格式</li>
<li>base64 编码的图片通过 Canvas 转换压缩，这里会用到的 Canvas 的 drawImage 以及 toDataURL 这两个 Api，一个调节图片的分辨率的，一个是调节图片压缩质量并且输出的，后续会有详细介绍</li>
<li>转换后的图片生成对应的新图片，然后输出</li>
<li></li>
</ul>
<h2 id="优缺点介绍"><a href="#优缺点介绍" class="headerlink" title="优缺点介绍"></a>优缺点介绍</h2><p>不过 Canvas 压缩的方式也有着自己的优缺点：</p>
<ul>
<li>优点：实现简单，参数可以配置化，自定义图片的尺寸，指定区域裁剪等等。</li>
<li>缺点：只有 jpeg 、webp 支持原图尺寸下图片质量的调整来达到压缩图片的效果，其他图片格式，仅能通过调节尺寸来实现</li>
</ul>
<span id="more"></span>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;input-img&quot; @change&#x3D;&quot;compress&quot; &#x2F;&gt;</span><br><span class="line">    &lt;a :download&#x3D;&quot;fileName&quot; :href&#x3D;&quot;compressImg&quot; &gt;普通下载&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;downloadImg&quot;&gt;兼容 IE 下载&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;img :src&#x3D;&quot;compressImg&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;export default &#123;</span><br><span class="line">  name: &#39;compress&#39;,</span><br><span class="line">  data: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      compressImg: null,</span><br><span class="line">      fileName: null,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    compress() &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取文件对象</span><br><span class="line">      const fileObj &#x3D; document.querySelector(&#39;#input-img&#39;).files[0];</span><br><span class="line">      &#x2F;&#x2F; 获取文件名称，后续下载重命名</span><br><span class="line">      this.fileName &#x3D; &#96;$&#123;new Date().getTime()&#125;-$&#123;fileObj.name&#125;&#96;;</span><br><span class="line">      &#x2F;&#x2F; 获取文件后缀名</span><br><span class="line">      const fileNames &#x3D; fileObj.name.split(&#39;.&#39;);</span><br><span class="line">      const type &#x3D; fileNames[fileNames.length-1];</span><br><span class="line">      &#x2F;&#x2F; 压缩图片</span><br><span class="line">      this.handleCompressImage(fileObj, type);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleCompressImage(img, type) &#123;</span><br><span class="line">      const vm &#x3D; this;</span><br><span class="line">      let reader &#x3D; new FileReader();</span><br><span class="line">      &#x2F;&#x2F; 读取文件</span><br><span class="line">      reader.readAsDataURL(img);</span><br><span class="line">      reader.onload &#x3D; function(e) &#123;</span><br><span class="line">        let image &#x3D; new Image(); &#x2F;&#x2F;新建一个img标签</span><br><span class="line">        image.src &#x3D; e.target.result;</span><br><span class="line">        image.onload &#x3D; function() &#123;</span><br><span class="line">          let canvas &#x3D; document.createElement(&#39;canvas&#39;);</span><br><span class="line">          let context &#x3D; canvas.getContext(&#39;2d&#39;);</span><br><span class="line">          &#x2F;&#x2F; 定义 canvas 大小，也就是压缩后下载的图片大小</span><br><span class="line">          let imageWidth &#x3D; image.width; &#x2F;&#x2F;压缩后图片的大小</span><br><span class="line">          let imageHeight &#x3D; image.height;</span><br><span class="line">          canvas.width &#x3D; imageWidth;</span><br><span class="line">          canvas.height &#x3D; imageHeight;</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F; 图片不压缩，全部加载展示</span><br><span class="line">          context.drawImage(image, 0, 0);</span><br><span class="line">          &#x2F;&#x2F; 图片按压缩尺寸载入</span><br><span class="line">          &#x2F;&#x2F; let imageWidth &#x3D; 500; &#x2F;&#x2F;压缩后图片的大小</span><br><span class="line">          &#x2F;&#x2F; let imageHeight &#x3D; 200;</span><br><span class="line">          &#x2F;&#x2F; context.drawImage(image, 0, 0, 500, 200);</span><br><span class="line">          &#x2F;&#x2F; 图片去截取指定位置载入</span><br><span class="line">          &#x2F;&#x2F; context.drawImage(image,100, 100, 100, 100, 0, 0, imageWidth, imageHeight);</span><br><span class="line">          vm.compressImg &#x3D; canvas.toDataURL(&#96;image&#x2F;$&#123;type&#125;&#96;);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; base64 图片转 blob 后下载</span><br><span class="line">    downloadImg() &#123;</span><br><span class="line">      let parts &#x3D; this.compressImg.split(&#39;;base64,&#39;);</span><br><span class="line">      let contentType &#x3D; parts[0].split(&#39;:&#39;)[1];</span><br><span class="line">      let raw &#x3D; window.atob(parts[1]);</span><br><span class="line">      let rawLength &#x3D; raw.length;</span><br><span class="line">      let uInt8Array &#x3D; new Uint8Array(rawLength);</span><br><span class="line">      for(let i &#x3D; 0; i &lt; rawLength; ++i) &#123;</span><br><span class="line">        uInt8Array[i] &#x3D; raw.charCodeAt(i);</span><br><span class="line">      &#125;</span><br><span class="line">      const blob &#x3D; new Blob([uInt8Array], &#123;type: contentType&#125;);</span><br><span class="line">      this.compressImg &#x3D; URL.createObjectURL(blob);</span><br><span class="line">      if (window.navigator.msSaveOrOpenBlob) &#123;</span><br><span class="line">        &#x2F;&#x2F; 兼容 ie 的下载方式</span><br><span class="line">        window.navigator.msSaveOrOpenBlob(blob, this.fileName);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        const a &#x3D; document.createElement(&#39;a&#39;);</span><br><span class="line">        a.href &#x3D; this.compressImg;</span><br><span class="line">        a.setAttribute(&#39;download&#39;, this.fileName);</span><br><span class="line">        a.click();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><blockquote>
<p>上面的代码是可以直接拿来看效果的，不喜欢用 Vue 的也可以把代码稍微调整一下，下面开始具体分解一下代码的实现思路</p>
</blockquote>
<h3 id="步骤一：Input-上传-File-处理"><a href="#步骤一：Input-上传-File-处理" class="headerlink" title="步骤一：Input 上传 File 处理"></a>步骤一：Input 上传 File 处理</h3><p>将 File 对象通过 <code>FileReader</code> 的 <code>readAsDataURL</code> 方法转换为URL格式的字符串（base64 编码）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fileObj &#x3D; document.querySelector(&#39;#input-img&#39;).files[0];</span><br><span class="line">let reader &#x3D; new FileReader();</span><br><span class="line">&#x2F;&#x2F; 读取文件</span><br><span class="line">reader.readAsDataURL(fileObj);</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="步骤二：Canvas-处理-File-对象"><a href="#步骤二：Canvas-处理-File-对象" class="headerlink" title="步骤二：Canvas 处理 File 对象"></a>步骤二：Canvas 处理 File 对象</h3><p>建立一个 <code>Image</code> 对象，一个 <code>canvas</code> 画布，设定自己想要下载的图片尺寸，调用 <code>drawImage</code> 方法在 canvas 中绘制上传的图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let image &#x3D; new Image(); &#x2F;&#x2F;新建一个img标签</span><br><span class="line">image.src &#x3D; e.target.result;</span><br><span class="line">let canvas &#x3D; document.createElement(&#39;canvas&#39;);</span><br><span class="line">let context &#x3D; canvas.getContext(&#39;2d&#39;);</span><br><span class="line">context.drawImage(image, 0, 0);</span><br></pre></td></tr></table></figure>


<h3 id="步骤三：Api-解析：drawImage"><a href="#步骤三：Api-解析：drawImage" class="headerlink" title="步骤三：Api 解析：drawImage"></a>步骤三：Api 解析：drawImage</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure>

<p>**img:**就是图片对象，可以是页面上获取的 DOM 对象，也可以是虚拟 DOM 中的图片对象。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1598786576273-20cc4996-634f-4a19-8fb8-68262d4313b0.webp"></p>
<p><strong>（1）dx、dy、dWidth、dHeight：</strong></p>
<p>表示在 <code>canvas</code> 画布上规划出一片区域用来放置图片，<code>dx, dy</code> 为绘图位置在 Canvas 元素的 X 轴、Y 轴坐标，<code>dWidth, dHeight</code> 指在 Canvas 元素上绘制图像的宽度和高度（如果不说明， 在绘制时图片的宽度和高度不会缩放）。</p>
<p><strong>（2）sx、sy、swidth、sheight:</strong></p>
<p>这 4 个参数是用来裁剪源图片的，表示图片在 <code>canvas</code> 画布上显示的大小和位置。<code>sx, sy</code> 表示在源图片上裁剪位置的 X 轴、Y 轴坐标，然后以 <code>swidth, sheight</code> 尺寸来选择一个区域范围，裁剪出来的图片作为最终在 Canvas 上显示的图片内容（ <code>swidth, sheight</code> 不说明的情况下，整个矩形（裁剪）从坐标的 <code>sx</code> 和 <code>sy</code> 开始，到图片的右下角结束）。</p>
<p>以下为图片绘制的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">context.drawImage(image, 0, 0, 100, 100);</span><br><span class="line">context.drawImage(image, 300, 300, 200, 200);</span><br><span class="line">context.drawImage(image, 0, 100, 150, 150, 300, 0, 150, 150);</span><br></pre></td></tr></table></figure>

<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1598786576278-66f315b0-3c36-45b3-825d-c8f3171672e1.webp"></p>
<p>Api 中奇怪之处在于，sx、sy、swidth、sheight 为选填参数，但位置在 dx、dy、dWidth、dHeight 之前。</p>
<h3 id="步骤四：Canvas-输出图片"><a href="#步骤四：Canvas-输出图片" class="headerlink" title="步骤四：Canvas 输出图片"></a>步骤四：Canvas 输出图片</h3><p>调用 <code>canvas</code> 的 <code>toDataURL</code> 方法可以输出 base64 格式的图片。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.toDataURL(&#96;image&#x2F;$&#123;type&#125;&#96;);</span><br></pre></td></tr></table></figure>


<h3 id="步骤五：Api-解析：toDataURL"><a href="#步骤五：Api-解析：toDataURL" class="headerlink" title="步骤五：Api 解析：toDataURL"></a>步骤五：Api 解析：toDataURL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas.toDataURL(type, encoderOptions);</span><br></pre></td></tr></table></figure>

<p><strong>type （可选）：</strong>图片格式，默认为 image/png。</p>
<p><strong>encoderOptions （可选）：</strong>在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。</p>
<p><strong>a 标签的下载</strong>：调用 <code>&lt;a&gt;</code> 标签的 <code>download</code> 属性，即可完成图片的下载。</p>
<h3 id="步骤六：Api-解析：download"><a href="#步骤六：Api-解析：download" class="headerlink" title="步骤六：Api 解析：download"></a>步骤六：Api 解析：download</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; href 下载必填</span><br><span class="line">&lt;a download&#x3D;&quot;filename&quot; href&#x3D;&quot;href&quot;&gt; 下载 &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p><strong>filename：</strong>选填，规定作为文件名来使用的文本。</p>
<p><strong>href：</strong>文件的下载地址。</p>
<h3 id="步骤七：非主流浏览器下载处理"><a href="#步骤七：非主流浏览器下载处理" class="headerlink" title="步骤七：非主流浏览器下载处理"></a>步骤七：非主流浏览器下载处理</h3><p>这一步可以解决 Chroma 、 Firefox 和 Safari（自测支持） 浏览器的下载功能，因为 IE 等浏览器不支持 <code>download</code> 属性，所以需要进行其他方式的下载，也就有了代码中的后续内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; base64 图片转 blob 后下载</span><br><span class="line">downloadImg() &#123;</span><br><span class="line">  let parts &#x3D; this.compressImg.split(&#39;;base64,&#39;);</span><br><span class="line">  let contentType &#x3D; parts[0].split(&#39;:&#39;)[1];</span><br><span class="line">  let raw &#x3D; window.atob(parts[1]);</span><br><span class="line">  let rawLength &#x3D; raw.length;</span><br><span class="line">  let uInt8Array &#x3D; new Uint8Array(rawLength);</span><br><span class="line">  for(let i &#x3D; 0; i &lt; rawLength; ++i) &#123;</span><br><span class="line">    uInt8Array[i] &#x3D; raw.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  const blob &#x3D; new Blob([uInt8Array], &#123;type: contentType&#125;);</span><br><span class="line">  this.compressImg &#x3D; URL.createObjectURL(blob);</span><br><span class="line">  if (window.navigator.msSaveOrOpenBlob) &#123;</span><br><span class="line">    &#x2F;&#x2F; 兼容 ie 的下载方式</span><br><span class="line">    window.navigator.msSaveOrOpenBlob(blob, this.fileName);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    const a &#x3D; document.createElement(&#39;a&#39;);</span><br><span class="line">    a.href &#x3D; this.compressImg;</span><br><span class="line">    a.setAttribute(&#39;download&#39;, this.fileName);</span><br><span class="line">    a.click();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将之前 <code>canvas</code> 生成的 base64 数据拆分后，通过 <code>atob</code> 方法解码</li>
<li>将解码后的数据转换成 Uint8Array 格式的无符号整形数组</li>
<li>转换后的数组来生成一个 Blob 数据对象，通过 <code>URL.createObjectURL(blob)</code> 来生成一个临时的 DOM 对象</li>
<li>之后 IE 类浏览器可以调用 <code>window.navigator.msSaveOrOpenBlob</code> 方法来执行下载，其他浏览器也可以继续通过 <code>&lt;a&gt;</code> 标签的 <code>download</code> 属性来进行下载</li>
</ul>
<h3 id="步骤八：Api-解析：atob"><a href="#步骤八：Api-解析：atob" class="headerlink" title="步骤八：Api 解析：atob"></a>步骤八：Api 解析：atob</h3><p>base-64 解码使用方法是 atob()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.atob(encodedStr)</span><br></pre></td></tr></table></figure>

<p><strong>encodedStr：</strong>必需，是一个通过 btoa() 方法编码的字符串，btoa() 是 base64 编码的使用方法。</p>
<h3 id="步骤九：Api-解析：Uint8Array"><a href="#步骤九：Api-解析：Uint8Array" class="headerlink" title="步骤九：Api 解析：Uint8Array"></a>步骤九：Api 解析：Uint8Array</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Uint8Array(length)</span><br></pre></td></tr></table></figure>

<p><strong>length：</strong>创建初始化为 0 的，包含 length 个元素的无符号整型数组。</p>
<h3 id="步骤十：Api-解析：Blob"><a href="#步骤十：Api-解析：Blob" class="headerlink" title="步骤十：Api 解析：Blob"></a>步骤十：Api 解析：Blob</h3><p><code>Blob</code> 对象表示一个不可变、原始数据的类文件对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数允许通过其它对象创建 Blob 对象</span><br><span class="line">new Blob([obj],&#123;type:createType&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>obj：</strong>字符串内容</p>
<p><strong>createType：</strong>要构造的类型，兼容性 IE 10 以上</p>
<h3 id="步骤十一：Api-解析：createObjectURL"><a href="#步骤十一：Api-解析：createObjectURL" class="headerlink" title="步骤十一：Api 解析：createObjectURL"></a>步骤十一：Api 解析：createObjectURL</h3><p>静态方法会创建一个 DOMString。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objectURL &#x3D; URL.createObjectURL(object);</span><br></pre></td></tr></table></figure>

<p><strong>object：</strong>用于创建 URL 的 File 对象、Blob 对象或者 MediaSource 对象。</p>
<h3 id="步骤十二：Api-解析：window-navigator"><a href="#步骤十二：Api-解析：window-navigator" class="headerlink" title="步骤十二：Api 解析：window.navigator"></a>步骤十二：Api 解析：window.navigator</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 官方已不建议使用的文件下载方式，仅针对 ie 且兼容性 10 以上</span><br><span class="line">&#x2F;&#x2F; msSaveBlob 仅提供下载</span><br><span class="line">&#x2F;&#x2F; msSaveOrOpenBlob 支持下载和打开</span><br><span class="line">window.navigator.msSaveOrOpenBlob(blob, fileName);</span><br></pre></td></tr></table></figure>

<p><strong>blob：</strong>要下载的 blob 对象</p>
<p><strong>fileName：</strong>下载后命名的文件名称。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本方法仅针对图片压缩介绍了一些思路，简单的使用场景可能如下介绍，当然也会引申出来更多的使用场景，这些还有待大家一起挖掘。</p>
<ul>
<li>上传存储图片如果需要对文件大小格式有要求的，可以统一压缩处理图片</li>
<li>前台页面想要编辑图片，可以在 Canvas 处理图片的时候，加一些其他逻辑，例如添加文字，剪裁，拼图等等操作</li>
</ul>
<p>tip：因部分接口有 IE 兼容性问题，IE 浏览器方面，仅能支持 IE 10 以上版本进行下载。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础（三）作用域</title>
    <url>/2021/03/23/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<blockquote>
<p>作用域的篇幅不会太长，作为自己对Js总结的第三篇文章，主要是承上启下。 之后会涉及到执行上下文，闭包等相关专题，为了避免内容过多，作用域这一部分单独总结。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/%E4%B8%8B%E8%BD%BD.jpeg" style="zoom:67%;" />

<span id="more"></span>

<h2 id="一、作用域的定义"><a href="#一、作用域的定义" class="headerlink" title="一、作用域的定义"></a>一、作用域的定义</h2><p><strong>一张导图概括本节内容</strong> <img data-src="https://img-blog.csdnimg.cn/20200609102448438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> <strong>1.1 常见的解释</strong></p>
<ol>
<li>一段程序代码中所用到的<strong>名字</strong>并不总是有效，而限定它的可用性的范围就是这个名字的作用域；</li>
<li>作用域规定了<strong>如何查找变量</strong>，也就是确定当前执行代码对变量的访问权限；</li>
<li>通俗的讲作用域就是<strong>一套规则</strong>，用于确定在何处以及如何查找<strong>某个变量</strong>的规则</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a is not defined a变量并不是任何地方都可以被找到的</span></span><br></pre></td></tr></table></figure>

<p><strong>1.2 JavaScript中作用域工作模型</strong></p>
<p>JavaScript 采用是词法作用域(lexical scoping)，也就是静态作用域：</p>
<ul>
<li>函数的作用域在函数定义的时候就决定了</li>
</ul>
<p>与之对应的还有一个动态作用域：</p>
<ul>
<li>函数的作用域是在函数调用的时候才决定的；</li>
</ul>
<p><strong>1.3 全局变量和局部变量</strong></p>
<p>根据定义变量的方式又可以分为：</p>
<p>局部变量：只能在函数中访问，该函数外不可访问；</p>
<ul>
<li>定义在函数中的变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">&#x27;高原&#x27;</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// ？</span></span><br><span class="line">fn(); <span class="comment">// ？</span></span><br></pre></td></tr></table></figure>

<p>全局：任何地方都能访问到的对象拥有全局作用域。</p>
<ul>
<li>函数外定义的变量</li>
<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a1-&#x27;</span>,a);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	a = <span class="number">1000</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;a2-&#x27;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a3-&#x27;</span>,a);</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a4-&#x27;</span>,a);</span><br></pre></td></tr></table></figure>

<p>注意：在ES6之后又提出了块级作用域，它们之间的区别我们之后再来讨论。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=2659298556,3987226078&fm=26&gp=0.jpeg"></p>
<h2 id="二、理解作用域"><a href="#二、理解作用域" class="headerlink" title="二、理解作用域"></a>二、理解作用域</h2><p>根据第一节的描述，我们一一验证一下</p>
<p><strong>2.1 理解词法作用域</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<p>我们结合定义去分析：</p>
<ul>
<li>执行<code>bar</code>函数，函数内部形成了局部作用域；</li>
<li>声明value变量，并赋值2</li>
<li>执行<code>foo</code>函数，函数foo的作用域内没有<code>value</code>这个变量，它会向外查找</li>
<li>根据词法作用域的规则，函数定义时，<code>foo</code>的外部作用域为全局作用域</li>
<li>打印<strong>结果是1</strong></li>
</ul>
<p>如果是动态作用域的话：结果<strong>就是2</strong>，不知道你是否想明白了？</p>
<p><strong>2.2 全局变量</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;全局变量&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(str+<span class="number">1</span>);</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">childFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(str+<span class="number">2</span>);</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(str+<span class="number">3</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		fn();</span><br><span class="line">	&#125;;</span><br><span class="line">	childFn();</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"><span class="comment">// 全局变量1</span></span><br><span class="line"><span class="comment">// 全局变量2</span></span><br><span class="line"><span class="comment">// 全局变量3</span></span><br></pre></td></tr></table></figure>

<p>再来分析下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	a = <span class="number">1000</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;a1-&#x27;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a2-&#x27;</span>,a);</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a3-&#x27;</span>,a);</span><br><span class="line"><span class="comment">// a2- 100 // 在当前作用域下查找变量a =&gt; 100</span></span><br><span class="line"><span class="comment">// a1- 1000 // 函数执行时，全局变量a已经被重新赋值</span></span><br><span class="line"><span class="comment">// a3- 1000 // 全局变量a =&gt; 1000</span></span><br></pre></td></tr></table></figure>

<p><strong>2.3 局部作用域</strong></p>
<p>局部作用域一般只在固定的代码片段内可访问到，最常见的就是以函数为单位的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name=<span class="string">&quot;高原&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">childFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;</span><br><span class="line">    childFn(); <span class="comment">// 高原</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// name is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="三、作用域链"><a href="#三、作用域链" class="headerlink" title="三、作用域链"></a>三、作用域链</h2><p><strong>3.1 当查找变量的时候都发生了什么？</strong></p>
<ul>
<li>会先从当前<strong>上下文的变量对象</strong>中查找；</li>
<li>如果没有找到，就会从父级(词法层面上的父级)<strong>执行上下文</strong>的变量对象中查找；</li>
<li>一直找到全局上下文的变量对象，也就是全局对象；</li>
<li>作用域链的顶端就是全局对象；</li>
</ul>
<p>这样<strong>由多个执行上下文的变量对象构成的链表就叫做作用域链</strong>，从某种意义上很类似原型和原型链。</p>
<p><strong>3.2 作用域链和原型继承查找时的区别：</strong></p>
<ul>
<li>查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回<code>undefined</code></li>
<li>查找的属性在作用域链中不存在的话就会抛出<code>ReferenceError</code>。</li>
</ul>
<p><strong>3.3 作用域嵌套</strong></p>
<p>既然每一个函数就可以形成一个作用域（<code>词法作用域</code> || <code>块级作用域</code>），那么当然也会存在多个作用域嵌套的情况，他们遵循这样的查询规则：</p>
<ul>
<li>内部作用域有权访问外部作用域;</li>
<li>外部作用域无法访问内部作用域;（真是是这样吗？）</li>
<li>兄弟作用域不可互相访问;</li>
</ul>
<p>在《你不知道的Js》中，希望读者可以将作用域的嵌套和作用域链想象成这样：</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020060915193493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="四、思考与总结"><a href="#四、思考与总结" class="headerlink" title="四、思考与总结"></a>四、思考与总结</h2><p><strong>4.1 总结</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20200609160809565.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>4.2 思考</strong></p>
<p>最后，让我们看一个《JavaScript权威指南》中的两段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(); <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br><span class="line">checkscope1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope2()();</span><br></pre></td></tr></table></figure>

<p>两段代码的结果都是”local scope”，书中的回答是：JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。</p>
<p>但是它们内部经历的事情是一样的吗？</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础（二）从原型到原型链</title>
    <url>/2021/03/21/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<blockquote>
<p>本文主要从构造函数 -&gt; 原型（隐式原型+显示原型）-&gt; 原型链的顺序，渐进式讲解，希望对你有所做帮助，共勉～</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又到了回忆过去的时候了，知识就是这样，原型和原型链在我之前的实习生涯中用到的很少——几乎没有（噗！我菜我摊牌了），但是它和this指向问题一样，是初级、中级前端开发在面试时永远绕不开的话题。是不是大家每次看面经的时候都会去搜索原型相关的知识点？</p>
<p>你看这知识，总是在考的时候，才能知道它的重要，就好像曾经有一段贼拉真挚的面试题摆在我面前…话题拉回来，今天我们就收了这个<strong>孽障</strong>！</p>
<img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/src=http___img.wxcha.com_file_201711_22_e1655873d2.jpg&refer=http___img.wxcha.jpeg" style="zoom:50%;" />

<span id="more"></span>

<h2 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h2><h3 id="1-1-什么是构造函数？"><a href="#1-1-什么是构造函数？" class="headerlink" title="1.1 什么是构造函数？"></a>1.1 什么是构造函数？</h3><p>构造函数本身就是一个函数，与普通函数没有任何区别，不过<strong>为了规范一般将其首字母大写</strong>。构造函数和普通函数的区别在于，使用<strong>new</strong>生成实例的函数就是构造函数，直接调用的就是普通函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，Person 就是一个构造函数。</p>
<h3 id="1-2-constructor？"><a href="#1-2-constructor？" class="headerlink" title="1.2 constructor？"></a>1.2 constructor？</h3><p><code>constructor</code> 返回创建实例对象时构造函数的引用。此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20200604185358168.png" alt="被构造出来的person的"> 可以看到实例对象的constructor指向了它的构造函数，而它和原型的关系我们在之后会链接到一起。</p>
<h3 id="1-3-都有哪些数据类型或者函数拥有constructor呢？"><a href="#1-3-都有哪些数据类型或者函数拥有constructor呢？" class="headerlink" title="1.3 都有哪些数据类型或者函数拥有constructor呢？"></a>1.3 都有哪些数据类型或者函数拥有<code>constructor</code>呢？</h3><p>在JavaScript中，每个具有<strong>原型</strong>的对象都会自动获得constructor属性。除了：<code>arguments</code>、<code>Enumerator</code>、<code>Error</code>、<code>Global</code>、<code>Math</code>、<code>RegExp</code>等一些特殊对象之外，其他所有的JavaScript内置对象都具备constructor属性。例如：<code>Array</code>、<code>Boolean</code>、<code>Date</code>、<code>Function</code>、<code>Number</code>、<code>Object</code>、<code>String</code>等。所有主流浏览器均支持该属性。打开控制台我们可以验证一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span>.constructor) <span class="comment">// ƒ String() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span>.constructor === <span class="built_in">String</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].constructor) <span class="comment">// ƒ Array() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].constructor === <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(num.constructor) <span class="comment">// ƒ Number() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.constructor === <span class="built_in">Number</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().constructor) <span class="comment">// ƒ Date() &#123; [native code] &#125;</span></span><br><span class="line"><span class="comment">// 注意！！！不要混淆哦</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime().constructor) <span class="comment">// ƒ Number() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.constructor) <span class="comment">// ƒ Boolean() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(show.constructor) <span class="comment">// ƒ Function() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义构造函数，无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p.constructor) <span class="comment">// ƒ Person()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		name: <span class="string">&#x27;gaoyuan&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = Person()</span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor) <span class="comment">// ƒ Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-模拟实现一个new"><a href="#1-4-模拟实现一个new" class="headerlink" title="1.4 模拟实现一个new"></a>1.4 模拟实现一个new</h3><p>既然构造函数与普通函数的区别仅仅在于调用方式上，我们就应该了解new。</p>
<ul>
<li>当调用<code>new</code>运算符时，该函数总会返回一个对象；</li>
<li>通常情况下，构造器里的this就指向返回的这个对象；</li>
</ul>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">通常情况下</span><br><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.name; <span class="comment">// gaoyuan</span></span><br><span class="line"></span><br><span class="line">特殊情况</span><br><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		name: <span class="string">&#x27;老王&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.name <span class="comment">// 老王</span></span><br></pre></td></tr></table></figure>

<p>我们利用 <code>__proto__</code>（隐式原型，下文会提到）属性来模拟一下new 调用构造函数的过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objectNew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 从object.prototype上克隆一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 取得外部传入的构造器，这里是Person</span></span><br><span class="line">    <span class="keyword">var</span> Constructor = [].shift.call( <span class="built_in">arguments</span> );</span><br><span class="line">    <span class="comment">// 更新，指向正确的原型</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype; <span class="comment">//知识点，要考、要考、要考</span></span><br><span class="line">    <span class="comment">// 借用外部传入的构造器给obj设置属性</span></span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 确保构造器总是返回一个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ref === <span class="string">&#x27;object&#x27;</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=1200653736,2067630829&fm=26&gp=0.jpeg" style="zoom: 67%;" />

<h2 id="二、原型"><a href="#二、原型" class="headerlink" title="二、原型"></a>二、原型</h2><h3 id="2-1-prototype-显式原型"><a href="#2-1-prototype-显式原型" class="headerlink" title="2.1 prototype(显式原型)"></a>2.1 prototype(显式原型)</h3><p>JavaScript 是一种基于原型的语言 (prototype-based language)，在设计的时候模仿了Java的两套类型机制：<code>基本类型</code> 和 <code>对象类型</code>。可见原型很重要！</p>
<p>每个对象都拥有一个原型对象，类是以函数的形式来定义的。prototype表示该函数的原型，也表示一个类的成员的集合。看下图： <img data-src="https://img-blog.csdnimg.cn/20200605140618427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 可以发现Person函数自己的原型都有什么：</p>
<ul>
<li><code>constructor</code> (Person.prototype.constructor =&gt; Person)</li>
<li><code>__proto__</code> （我们称它为隐式原型）</li>
</ul>
<p>此时我们得到了第一张表示构造函数和实例原型之间的关系图：</p>
<p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTEucG5n?x-oss-process=image/format,png" alt="构造函数和实例原型的关系图"></p>
<p>那么我们该怎么表示实例与构造函数原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p>
<h3 id="2-2-proto-隐式原型"><a href="#2-2-proto-隐式原型" class="headerlink" title="2.2 proto(隐式原型)"></a>2.2 <strong>proto</strong>(隐式原型)</h3><p>这是每一个JavaScript对象(除了 null )都具有的一个属性，叫<code>__proto__</code>，这是一个访问器属性（即 getter 函数和 setter 函数），通过它可以访问到对象的内部<code>[[Prototype]]</code> (一个对象或 null )。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>于是我们更新下关系图：</p>
<p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTIucG5n?x-oss-process=image/format,png" alt="实例与实例原型的关系图"></p>
<p><strong>小结：</strong> 每个引用类型的隐式原型都指向它的构造函数的显式原型</p>
<h3 id="2-3-constructor"><a href="#2-3-constructor" class="headerlink" title="2.3 constructor"></a>2.3 constructor</h3><p>前文提到了<code>constructor</code>，它与原型的关系也可以添加到这张图里，更新下关系图：</p>
<p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTMucG5n?x-oss-process=image/format,png" alt="实例原型与构造函数的关系图"> 根据上图的关系，下面这段的结果，大家就一目了然了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>接下来我们要继续思考实例和原型的关系：</p>
<h2 id="三、实例与原型"><a href="#三、实例与原型" class="headerlink" title="三、实例与原型"></a>三、实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。这样一个查找过程</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;老王&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">&#x27;余光&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 余光</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 老王</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 余光（is me）。</p>
<p><strong>描述：</strong></p>
<p>但是当我们删除了 person 的 name 属性后，再次读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 老王（这…）</p>
<p><strong>总结：</strong></p>
<ul>
<li>尝试遍历<code>实例a</code>中的所有属性，但没有找到目标属性；</li>
<li>查找<code>name</code>属性的这个请求被委托给该<code>实例a</code>的构造器(<code>A</code>)的原型，它被<code>a.__proto__</code> 记录着并且指向A.prototype；</li>
<li>A.prototype存在目标属性，返回他的值；</li>
</ul>
<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>
<h2 id="四、原型的原型"><a href="#四、原型的原型" class="headerlink" title="四、原型的原型"></a>四、原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&#x27;余光&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// 余光</span></span><br></pre></td></tr></table></figure>

<p>其实原型对象就是通过<code>Object</code>构造函数生成的，结合之前所讲，实例的 <code>__proto__</code> 指向构造函数的 <code>prototype</code> ，可以理解成，<code>Object.prototype()</code>是所有对象的根对象，所以我们再次更新下关系图：</p>
<p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTQucG5n?x-oss-process=image/format,png" alt="原型的原型关系图"></p>
<h2 id="五、原型链"><a href="#五、原型链" class="headerlink" title="五、原型链"></a>五、原型链</h2><p>每个对象拥有一个原型对象，通过 <code>__proto__</code> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>。<strong>这种关系被称为原型链</strong> (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。</p>
<p>这个链条存在着终点，是因为：Object.prototype 的原型是——null，引用阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">《undefined与null的区别》 (opens new window)</a>就是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">null 表示“没有对象”，即该处不应该有值。这句话也意味着 Object.prototype 没有原型</span><br></pre></td></tr></table></figure>

<p>我们最后更新一次关系图，蓝色线条就可以表示原型链这种关系。</p>
<p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTUucG5n?x-oss-process=image/format,png" alt="原型链示意图"></p>
<h3 id="补充，易错点"><a href="#补充，易错点" class="headerlink" title="补充，易错点"></a>补充，易错点</h3><p><strong>1.constructor</strong> 首先是 constructor 属性，我们看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>

<p><strong>2.<code>__proto__</code></strong></p>
<p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<p><strong>3.真的是继承吗？</strong></p>
<p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：</p>
<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，<strong>委托</strong>的说法反而更准确些。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul>
<li>使用<strong>new</strong>生成实例的函数就是构造函数，直接调用的就是普通函数；</li>
<li>每个对象都拥有一个原型对象；</li>
<li>每个引用类型的隐式原型都指向它的构造函数的显式原型；</li>
<li>Object.prototype是所有对象的根对象；</li>
<li>原型链存在终点，不会无限查找下去；</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础（五）闭包</title>
    <url>/2021/03/25/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="一、什么是闭包"><a href="#一、什么是闭包" class="headerlink" title="一、什么是闭包"></a>一、什么是闭包</h2><p>顾名思义，遇见问题先问为什么是我们一贯的思维方式，我们尝试回答一下：</p>
<ol>
<li>闭包就是函数内部的子函数—— <code>等于没说</code></li>
<li>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。——<code>靠谱</code></li>
<li>闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁——<code>靠谱</code></li>
<li>函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）——<code>很靠谱</code></li>
</ol>
<p>我们试着用代码来描述一下上面的回答，看看你最<strong>中意</strong>哪一个～</p>
<span id="more"></span>

<h3 id="1-1-闭包是函数内部的子函数"><a href="#1-1-闭包是函数内部的子函数" class="headerlink" title="1.1 闭包是函数内部的子函数"></a>1.1 闭包是函数内部的子函数</h3><p>先看这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure>

<p>基于词法作用域的查找规则，<code>bar函数</code>可以成功的打印<code>a</code>变量，并且它也是<code>foo</code>的子函数，但严格来说它并没有清晰的表达出闭包这一概念，说它表达的是<strong>嵌套函数可以访问声明于大外部作用域的变量</strong>更准确一些。</p>
<h3 id="1-2-闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁"><a href="#1-2-闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁" class="headerlink" title="1.2 闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁"></a>1.2 闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁</h3><p>再来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = foo();</span><br><span class="line">res(); <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure>

<p>结果一致，这是因为此时<code>res</code>是执行<code>foo</code>函数时返回的<code>bar</code>引用，bar函数得以保存了它饿词法环境。</p>
<h3 id="1-3-函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）"><a href="#1-3-函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）" class="headerlink" title="1.3 函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）"></a>1.3 函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）</h3><p>我们来看下面代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// gaoyuan</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">//gaoyuan</span></span><br></pre></td></tr></table></figure>

<p>foo的上下文被静态的保存了下来，而且是在该函数创建的时候就保存了。下面我们来验证一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;gaoyuan&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// gaoyuan</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;老王&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    func()</span><br><span class="line">&#125;)(foo); <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure>

<p>这里我们就可以理解——函数被创建后就形成了闭包，他们保存了上层上下文的作用域链，并且保存在<code>[[scope]]</code>中，如果你对<code>[[scope]]</code>的概念已经模糊了，不妨花几分钟看看《JavaScript中的执行上下文》这篇文章。</p>
<h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p><strong>注意：闭包是函数内部的返回的子函数这句话本身没错</strong>，但要看从什么角度出发：</p>
<p>ECMAScript中，闭包指的是：</p>
<ol>
<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>
<li>从实践角度：以下函数才算是闭包：<ul>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li>闭包代码块创建该代码块的上下文中数据的结合</li>
<li>闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁</li>
<li>不同的角度对闭包的解释不同的</li>
</ul>
<p>注意：这些并不是闭包的全部，就好像当你被问到——闭包是什么的时候，你的上述回答并不能结束这个话题，往往会引申出更多的话题。</p>
<h2 id="二、尝试分析闭包"><a href="#二、尝试分析闭包" class="headerlink" title="二、尝试分析闭包"></a>二、尝试分析闭包</h2><p>还是那段经典代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line">foo(); <span class="comment">// local scope</span></span><br></pre></td></tr></table></figure>

<p>首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p>
<ol>
<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li>
<li>全局执行上下文初始化</li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li>
<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>
<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li>
<li>f 执行上下文初始化，创建变量对象、作用域链、this等</li>
<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>
</ol>
<p><img data-src="https://img-blog.csdnimg.cn/20200628152924827.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>当 <code>f</code> 函数执行的时候，<code>checkscope</code> 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 <code>checkscope</code> 作用域下的 <code>scope</code> 值呢？</p>
<p>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：</p>
<p>因为这个作用域链：</p>
<ul>
<li><code>f 函数</code>依然可以读取到 <code>checkscopeContext.AO</code> 的值；</li>
<li>当 <code>f 函数</code>引用了 <code>checkscopeContext.AO</code> 中的值的时候，即使 <code>checkscopeContext</code> 被销毁了，JavaScript 依然会让 <code>checkscopeContext.AO</code> 活在内存中;</li>
<li><code>f 函数</code>依然可以通过 <code>f 函数</code>的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</li>
</ul>
<p>多么浪漫的思想——只要你需要我，那我我本应该被销毁，你也能找到我～</p>
<h2 id="三、经典问题"><a href="#三、经典问题" class="headerlink" title="三、经典问题"></a>三、经典问题</h2><h3 id="3-1-多个对象引用同一个-Scope-，你遇到过吗？"><a href="#3-1-多个对象引用同一个-Scope-，你遇到过吗？" class="headerlink" title="3.1 多个对象引用同一个[[Scope]]，你遇到过吗？"></a>3.1 多个对象引用同一个[[Scope]]，你遇到过吗？</h3><p>直接上代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child1;</span><br><span class="line"><span class="keyword">var</span> child2;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    child1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(++x)</span><br><span class="line">    &#125;;</span><br><span class="line">    child2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(--x)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">parent();</span><br><span class="line">child1(); <span class="comment">// 2</span></span><br><span class="line">child1(); <span class="comment">// 3</span></span><br><span class="line">child2(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>大家可能不理解，<code>child1</code>和<code>child</code>他们两个函数在创建后都保存了上层上下文，万万没想到，<strong>同一个上下文创建的闭包是共用一个<code>[[scope]]</code>属性的</strong>，某个闭包对其中[[Scope]]的变量做修改会影响到其他闭包对其变量的读取。</p>
<h3 id="3-2-闭包轻松解决的经典问题"><a href="#3-2-闭包轻松解决的经典问题" class="headerlink" title="3.2 闭包轻松解决的经典问题"></a>3.2 闭包轻松解决的经典问题</h3><p>大家一定对下面这段代码很眼熟：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>](); <span class="comment">// 10</span></span><br><span class="line">arr[<span class="number">1</span>](); <span class="comment">// 10</span></span><br><span class="line">arr[<span class="number">2</span>](); <span class="comment">// 10</span></span><br><span class="line">arr[<span class="number">3</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>我们这么解释它：<strong>同一个上下文中创建的闭包是共用一个[[Scope]]属性的</strong>。</p>
<p>因此上层上下文中的变量<code>i</code>是可以很容易就被改变的。</p>
<p>arr[0],arr[1]…arr[9]他们共用一个[[scope]]，最终执行的时候结果当然一样。</p>
<p><strong>如何利用闭包来解决这个问题呢？</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    arr[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">arr[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">arr[<span class="number">2</span>](); <span class="comment">// 2</span></span><br><span class="line">arr[<span class="number">3</span>](); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>我们通过立即执行匿名函数的方式隔离了作用域，当执行 arr[0] 函数的时候，arr[0] 函数的作用域链发生了改变：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    Scope: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名函数执行上下文的AO为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">匿名函数Context = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        i: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，这时函数的<code>[[Scope]]</code>属性就有了真正想要的值了，为了达到这样的目的，我们不得不在<code>[[Scope]]</code>中创建额外的变量对象。要注意的是，在返回的函数中，如果要获取<code>i</code>的值，那么该值还是会是10。</p>
<h3 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h3><ul>
<li>函数内的所有内部函数都共享一个父作用域，因此创建的闭包是共用的。</li>
<li>利用闭包隔离作用域的特性可以解决共享作用域的问题</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=1200653736,2067630829&fm=26&gp=0.jpeg"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础（六）基本数据类型</title>
    <url>/2021/03/26/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h2><p>可能许多习惯了C++、C#这类静态语言（强类型）语言的小伙伴们在编写Js代码时，会很不习惯，因为相对于静态语言来说，Js甚至没有类型的”概念“。</p>
<p>而且Js中吐槽较多的恰恰就包含类型转换，在我们日常写代码时总是遇到或显示或隐示的类型转换，比如：</p>
<p>你要获取数字<code>123</code>的个位十位百位，你会怎么做？</p>
<ul>
<li>toSrting()后通过下标获取？</li>
<li>取整取余？</li>
</ul>
<p>使用类型转换形式多样。有些方式简明易懂，也很安全，然而稍不留神，就会出现意想不到的结果。</p>
<p>为了学习和掌握类型转换，现在先让我们来深入了解一下值和类型。</p>
<span id="more"></span>

<h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>JavaScript 拥有<strong>动态类型</strong>，这意味着相同的变量可用作不同的类型：类型是值的内部特征，它定义了值的行为，以使其区别于其他值。</p>
<p><strong>JavaScript中的内置类型:</strong></p>
<ul>
<li>null</li>
<li>undefined</li>
<li>布尔值（boolean）</li>
<li>数字（number）</li>
<li>字符串（string）</li>
<li>对象（Object）</li>
<li>symbol（ES6新增）</li>
</ul>
<p>对于null和undefined大家一定不陌生，我们会在第三节简单的分析他们之前的区别。</p>
<h2 id="二、数据类型分类"><a href="#二、数据类型分类" class="headerlink" title="二、数据类型分类"></a>二、数据类型分类</h2><p>除了<strong>对象</strong>，其他几个都是<strong>基本类型</strong>，这是因为声明变量时不同的内存分配而决定的：</p>
<h3 id="2-1-基本类型"><a href="#2-1-基本类型" class="headerlink" title="2.1 基本类型"></a>2.1 基本类型</h3><p>JavaScript 中共有 6 种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>。</p>
<p><code>基本类型</code>存储在<code>栈（stack）中</code>，也就是说：</p>
<ul>
<li>它们的值<strong>直接存储在变量访问的位置</strong>。</li>
<li>这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – <code>栈</code>中。</li>
<li>这样存储便于迅速查寻变量的值。</li>
<li>基本类型的值是按值访问的，且基本类型的值是不可变的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123hello321&quot;</span>;</span><br><span class="line">str.toUpperCase();     <span class="comment">// 123HELLO321</span></span><br><span class="line"><span class="built_in">console</span>.log(str);      <span class="comment">// 123hello321</span></span><br></pre></td></tr></table></figure>

<p><strong>基本类型的比较是它们的值的比较：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a == b);    <span class="comment">// == 只进行值的比较</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b);   <span class="comment">// === 不仅进行值得比较，还要进行数据类型的比较</span></span><br></pre></td></tr></table></figure>

<p>有关符号运算，优先级的问题，我觉得应该将它放在Js专题系列，单独讨论它们才能比较透彻，这里就不过多解释了。</p>
<p>来看下面的代码，我们用图示来分析它</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">b = a;</span><br><span class="line">a = <span class="string">&#x27;字符串&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/20200707105321216.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-2-引用类型"><a href="#2-2-引用类型" class="headerlink" title="2.2 引用类型"></a>2.2 引用类型</h3><p><code>引用类型</code>存储在<code>堆（heap）</code>中的对象，也就是说:</p>
<ul>
<li>存储在变量处的值是一个指针（point），指向存储对象的内存地址。</li>
<li>引用类型的值是按引用访问的，且引用类型的值是<code>可变</code>的。</li>
<li>变量存储的是可以打开保存数据的房间的<code>钥匙</code></li>
<li><code>存储钥匙地址</code>的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</li>
</ul>
<p>除过上面的 6 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，有：</p>
<ul>
<li>Object</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Function</li>
<li>…</li>
</ul>
<p><strong>引用类型的比较是引用的比较：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;    <span class="comment">// 新建一个空对象 obj1</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;    <span class="comment">// 新建一个空对象 obj2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 == obj2);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>因为 obj1 和 obj2 分别引用的是存放在堆内存中的2个不同的对象，故变量 obj1 和 obj2 的值（引用地址）也是不一样的！</p>
<p>来看下面的代码，我们用图示来分析它</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;高原&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">b = a;</span><br><span class="line">a.name = <span class="string">&quot;gaoyuan&quot;</span>;</span><br><span class="line">b.age = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  name: <span class="string">&#x27;高原&#x27;</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/20200707114641540.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p><strong>基本类型</strong></p>
<ul>
<li>栈内存中包括了变量的标识符和变量的值</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li>栈内存中保存了变量标识符和指向堆内存中该对象的指针</li>
<li>堆内存中保存了对象的内容</li>
<li></li>
</ul>
<h2 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h2><h3 id="3-1-JavaScript中的变量是没有类型的"><a href="#3-1-JavaScript中的变量是没有类型的" class="headerlink" title="3.1 JavaScript中的变量是没有类型的"></a>3.1 JavaScript中的变量是没有类型的</h3><p>来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>; <span class="comment">// 严格地说 变量a没有类型，它所保存的 100是数字类型的</span></span><br><span class="line"><span class="keyword">typeof</span> a === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// 其实检测是=&gt;typeof 100</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> a === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>变量a</code>可以随时持有任何类型的<code>值</code>。换个角度来理解就是，JavaScript不做“类型强制”；也就是说，语言引擎不要求变量总是持有与其初始值同类型的值。</p>
<h3 id="3-2-typeof检测不总是对的"><a href="#3-2-typeof检测不总是对的" class="headerlink" title="3.2 typeof检测不总是对的"></a>3.2 typeof检测不总是对的</h3><p><img data-src="https://img-blog.csdnimg.cn/20200706185843137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>需要注意的点：</p>
<p><strong>number</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数学API和属性</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.LN2 === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// true  Math的属性</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span> === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// true 无穷</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// true 特殊的数字类型，not a number</span></span><br><span class="line"><span class="comment">// 被强转称数字的其他数据类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="string">&#x27;str&#x27;</span>) === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// Number(&#x27;str&#x27;) =&gt; NaN =&gt; number</span></span><br></pre></td></tr></table></figure>

<p><strong>string</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> (<span class="keyword">typeof</span> <span class="number">1</span>) === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// typeof always returns a string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="number">1</span>) === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// 强转成字符串</span></span><br></pre></td></tr></table></figure>

<p><strong>布尔值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="number">1</span>) === <span class="string">&#x27;boolean&#x27;</span>; <span class="comment">// 强制类型转换</span></span><br><span class="line"><span class="keyword">typeof</span> !!(<span class="number">1</span>) === <span class="string">&#x27;boolean&#x27;</span>; <span class="comment">// two calls of the ! (logical NOT) operator are equivalent to Boolean()</span></span><br></pre></td></tr></table></figure>

<p><strong>Symble</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">&#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="string">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>undefined</strong></p>
<p>一个没有被赋值的变量的数据类型是<code>undefined</code>(如果方法或者是语句中操作的变量没有被赋值，则会返回undefined) —— MDN</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>object</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;高原&#x27;</span> &#125; === <span class="string">&#x27;object&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>null</strong></p>
<p>值得我们注意恰恰是这个<code>null</code>,typeof 对它的处理返回的是<code>object</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">&#x27;object&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>function</strong></p>
<p>typeof检测函数返回的也是object，这是因为从规范上看<code>function</code>实际上是<code>object</code>的一个子类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Functions</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125; === <span class="string">&#x27;function&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>那么你还知道其他检测数据类型的方式吗？</p>
<h3 id="3-3-null和undefined"><a href="#3-3-null和undefined" class="headerlink" title="3.3 null和undefined"></a>3.3 null和undefined</h3><ul>
<li><p>null：特指对象的值未设置。它是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JavaScript 基本类型</span><br></pre></td></tr></table></figure>

<p>之一。</p>
<ul>
<li>它不是全局对象的一个属性;</li>
<li>在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。</li>
</ul>
</li>
<li><p>undefined：表示声明但未被赋值的变量类型</p>
<ul>
<li>你可以使用<code>undefined</code>和严格相等或不相等操作符来决定一个变量是否拥有值。</li>
</ul>
</li>
</ul>
<p><strong>他们的区别：</strong></p>
<p>当检测 null 或 undefined 时，注意相等 <code>==</code>与<code>===</code>两个操作符的区别 ，前者会执行类型转换：</p>
<ul>
<li>typeof检测时两者的返回值不同</li>
<li>代表的含义不同</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// &quot;object&quot; (因为一些以前的原因而不是&#x27;null&#x27;)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span>  == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">null</span> <span class="comment">//true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础（四）立即调用函数</title>
    <url>/2021/03/24/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章，主要讲解的立即执行函数或自执行匿名函数的含义、用法、以及使用它的主要场景。系列的前面几篇文章主要讲解了作用域、原型，本篇文章一样起到了承上启下的作用，如果您感兴趣，不妨去看看哦～</p>
</blockquote>
<h2 id="一、了解立即调用函数表达式"><a href="#一、了解立即调用函数表达式" class="headerlink" title="一、了解立即调用函数表达式"></a>一、了解立即调用函数表达式</h2><h3 id="1-1-思维导图"><a href="#1-1-思维导图" class="headerlink" title="1.1 思维导图"></a>1.1 思维导图</h3><p><img data-src="https://img-blog.csdnimg.cn/20200622113604893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<span id="more"></span>

<h3 id="1-2-什么是立即调用？"><a href="#1-2-什么是立即调用？" class="headerlink" title="1.2 什么是立即调用？"></a>1.2 什么是立即调用？</h3><p>在详细了解这个之前，我们来谈了解一下“自执行”这个叫法，本文对这个功能的叫法也不一定完全对，每个人对他的理解都不一样，我们在这里用<code>立即调用</code>～</p>
<p>立即调用：</p>
<ul>
<li>顾名思义，该表达式一被<code>创建就立即执行</code>。</li>
<li>是一个在定义时就会立即执行的 <code>JavaScript 函数</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x + x = &#x27;</span>, x + x);</span><br><span class="line">&#125;)(<span class="number">5</span>) <span class="comment">// x + x = 10</span></span><br></pre></td></tr></table></figure>

<p>这是一个被称为 <code>自执行匿名函数</code> 的设计模式，主要包含两部分:</p>
<ol>
<li>第一部分是包围在 圆括号运算符 <code>()</code> 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</li>
<li>第二部分再一次使用 <code>()</code> 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</li>
</ol>
<h3 id="1-3-核心问题"><a href="#1-3-核心问题" class="headerlink" title="1.3 核心问题"></a>1.3 核心问题</h3><p><strong>当你声明一个函数的时候，通过在后面加括号就可以实现立即执行吗？</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;(); <span class="comment">// gaoyuan 成功了！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...是不是意味着后面加个括弧都可以自动执行？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;&#x27;</span>gaoyuan);</span><br><span class="line">&#125;(); <span class="comment">// Uncaught SyntaxError: Function statements require a function name</span></span><br><span class="line"><span class="comment">// 什么？还需要一个函数名？不是叫 自执行匿名函数吗？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我加上了函数名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;(); <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>很显然，例子中的第二条和第三条确实报错了，而且报错内容不一样，那么问题出现在哪呢？</p>
<h2 id="二、立即调用函数表达式报错了？"><a href="#二、立即调用函数表达式报错了？" class="headerlink" title="二、立即调用函数表达式报错了？"></a>二、立即调用函数表达式报错了？</h2><p>有时，我们定义函数之后，立即调用该函数，这时不能在函数的定义后面直接加圆括号，这会产生语法错误。产生语法错误的原因是，<code>function</code> 这个关键字，既可以当做语句，也可以当做表达式，比如下边：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表达式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>为了避免解析上的歧义，JS引擎规定，如果function出现在行首，一律解析成语句。因此JS引擎看到行首是function关键字以后，认为这一段都是函数定义，不应该以<code>括号结尾</code>，在它看来<code>括号</code>只是分组操作符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面这个function在语法上是没问题的，但是依然只是一个语句</span></span><br><span class="line"><span class="comment">// 加上括号()以后依然会报错，因为分组操作符需要包含表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;(); <span class="comment">// SyntaxError: Unexpected token )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果你在括弧()里传入一个表达式，将不会有异常抛出</span></span><br><span class="line"><span class="comment">// 但是foo函数依然不会执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;</span><br><span class="line"></span><br><span class="line">( <span class="number">1</span> );</span><br></pre></td></tr></table></figure>

<h2 id="三、使用立即调用函数的正确姿势"><a href="#三、使用立即调用函数的正确姿势" class="headerlink" title="三、使用立即调用函数的正确姿势"></a>三、使用立即调用函数的正确姿势</h2><p>要解决上述问题，非常简单。</p>
<p>我们只需要用<code>大括弧</code>将代码的代码全部括住就行了，因为JavaScript里<code>括弧()</code>里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明。</p>
<h3 id="3-1-常见使用姿势"><a href="#3-1-常见使用姿势" class="headerlink" title="3.1 常见使用姿势"></a>3.1 常见使用姿势</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面2个括弧()都会立即执行</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ()); <span class="comment">// 推荐使用这个</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;)(); <span class="comment">// 但是这个也是可以用的</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-不常见的使用姿势（一）"><a href="#3-2-不常见的使用姿势（一）" class="headerlink" title="3.2 不常见的使用姿势（一）"></a>3.2 不常见的使用姿势（一）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的</span></span><br><span class="line"><span class="comment">// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>)</span><br><span class="line">&#125;(); <span class="comment">// gaoyuan</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>)</span><br><span class="line">&#125;(); <span class="comment">// gaoyuan</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>) &#125;(); <span class="comment">// gaoyuan</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-不常见的使用姿势（二）"><a href="#3-3-不常见的使用姿势（二）" class="headerlink" title="3.3 不常见的使用姿势（二）"></a>3.3 不常见的使用姿势（二）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果你不在意返回值，或者不怕难以阅读</span></span><br><span class="line"><span class="comment">// 你甚至可以在function前面加一元操作符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转bool</span></span><br><span class="line"><span class="keyword">var</span> res1 = !<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;res1:&#x27;</span>, res1); <span class="comment">// gaoyuan true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转数字</span></span><br><span class="line"><span class="keyword">var</span> res2 = +<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;res2:&#x27;</span>, res2); <span class="comment">// gaoyuan NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位非</span></span><br><span class="line"><span class="keyword">var</span> res3 = ～<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;res3:&#x27;</span>, res3); <span class="comment">// gaoyuan NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-不常见的使用姿势（三）"><a href="#3-4-不常见的使用姿势（三）" class="headerlink" title="3.4 不常见的使用姿势（三）"></a>3.4 不常见的使用姿势（三）</h3><p>还有一个情况，使用new和void关键字，不过不太常见罢了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gaoyuan&#x27;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<h2 id="四、常见使用场景"><a href="#四、常见使用场景" class="headerlink" title="四、常见使用场景"></a>四、常见使用场景</h2><h3 id="4-1-隔离作用域"><a href="#4-1-隔离作用域" class="headerlink" title="4.1 隔离作用域"></a>4.1 隔离作用域</h3><p>IIFE最常见的功能，就是隔离作用域，在ES6之前JS原生也没有块级作用域的概念，所以需要函数作用域来模拟。</p>
<p>举例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> currentTime = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> year  = time.getFullYear()</span><br><span class="line">    <span class="keyword">var</span> month = time.getMonth()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> date  = time.getDate();</span><br><span class="line">    <span class="keyword">var</span> hour  = time.getHours();</span><br><span class="line">    <span class="keyword">var</span> min   = time.getMinutes();</span><br><span class="line">    <span class="keyword">return</span> year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + date + <span class="string">&#x27; &#x27;</span> + hour + <span class="string">&#x27;:&#x27;</span> + min;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>你仍然可以在其他地方声明同名变量～</p>
<h3 id="4-2-惰性函数"><a href="#4-2-惰性函数" class="headerlink" title="4.2 惰性函数"></a>4.2 惰性函数</h3><p>DOM事件添加中，为了兼容现代浏览器和IE浏览器，我们需要对浏览器环境进行一次判断：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">type, el, fn</span>) </span>&#123;</span><br><span class="line">            el.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">type, el, fn</span>) </span>&#123;</span><br><span class="line">            el.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="4-3-用闭包保存状态"><a href="#4-3-用闭包保存状态" class="headerlink" title="4.3 用闭包保存状态"></a>4.3 用闭包保存状态</h3><p>这里我仅举个例子，为我的下一篇文章——《JavaScript中的闭包》卖个关子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">lockedInIndex</span>) </span>&#123;</span><br><span class="line">        elems[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            alert(<span class="string">&#x27;I am link #&#x27;</span> + lockedInIndex);</span><br><span class="line">        &#125;, <span class="string">&#x27;false&#x27;</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Barry&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 无法从外部访问变量 name</span></span><br><span class="line">name <span class="comment">// 抛出错误：&quot;Uncaught ReferenceError: name is not defined&quot;</span></span><br></pre></td></tr></table></figure>

<p>将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Barry&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// IIFE 执行后返回的结果：</span></span><br><span class="line">result; <span class="comment">// &quot;Barry&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL列类型和列上约束</title>
    <url>/2017/08/06/MySQL%E5%88%97%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%97%E4%B8%8A%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h2 id="1-常用SQL命令"><a href="#1-常用SQL命令" class="headerlink" title="1.常用SQL命令"></a>1.常用SQL命令</h2><h3 id="（1）添加数据："><a href="#（1）添加数据：" class="headerlink" title="（1）添加数据："></a>（1）添加数据：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(….);</span><br></pre></td></tr></table></figure>

<h3 id="（2）删除数据："><a href="#（2）删除数据：" class="headerlink" title="（2）删除数据："></a>（2）删除数据：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span>  <span class="keyword">FROM</span> 表名;		#删除所有的记录行，慎用！</span><br><span class="line"><span class="keyword">DELETE</span>	<span class="keyword">FROM</span>	表名	<span class="keyword">WHERE</span>	列<span class="operator">=</span>值;		#删除满足条件的行</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="（3）修改数据："><a href="#（3）修改数据：" class="headerlink" title="（3）修改数据："></a>（3）修改数据：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE 	表名	<span class="keyword">SET</span>  列<span class="operator">=</span>值，列<span class="operator">=</span>值；		#删除所有记录行，慎用</span><br><span class="line">UPDATE	表名	<span class="keyword">SET</span>	 列<span class="operator">=</span>值，列<span class="operator">=</span>值  <span class="keyword">WHERE</span>   列<span class="operator">=</span>值；</span><br></pre></td></tr></table></figure>



<h2 id="2-MySQL中的列类型"><a href="#2-MySQL中的列类型" class="headerlink" title="2.MySQL中的列类型"></a>2.MySQL中的列类型</h2><h3 id="（1）数字类型"><a href="#（1）数字类型" class="headerlink" title="（1）数字类型"></a>（1）数字类型</h3><h4 id="整型："><a href="#整型：" class="headerlink" title="整型："></a>整型：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TINYINT: 占1个字节 -128~127。</span><br><span class="line">SMALLINT: 占2个字节 -32768~32767。</span><br><span class="line">INT: 占4个字节 -2147483648~2147483647。</span><br><span class="line">BIGINT: 占4/8个字节。</span><br></pre></td></tr></table></figure>

<h4 id="小数型："><a href="#小数型：" class="headerlink" title="小数型："></a>小数型：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FLOAT(M-M位有效数字,D-小数点后面D位小数):单精度浮点型，占4个字节。</span><br><span class="line">DOUBLE(M,D):双精度浮点型，占8个字节。</span><br><span class="line">DECIMAL(M,D):严格定点数，用于精确运算，如货币金额。</span><br></pre></td></tr></table></figure>

<h3 id="（2）字符串类型"><a href="#（2）字符串类型" class="headerlink" title="（2）字符串类型"></a>（2）字符串类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CHAR(M) : M不能超过255。</span><br><span class="line">VARCHAR(M) : M不能超过65535。</span><br><span class="line">TEXT(M) : M不能超过2^32,即40亿个字符。</span><br></pre></td></tr></table></figure>

<p><strong>面试问题</strong>：CHAR(8)和VARCHAR(8)的区别?<br>user_name  CHAR(8)：定长字符串，可能产生空间浪费，但读取速度快</p>
<blockquote>
<p>‘a’  实际存储为： ‘a\0\0\0\0\0\0\0’<br>‘ab’实际存储为： ‘ab\0\0\0\0\0\0’<br>‘abc’实际存储为： ‘abc\0\0\0\0\0’<br>‘abcd’实际存储为： ‘abcd\0\0\0\0’<br>‘abcde’实际存储为： ‘abcde\0\0\0’<br>‘abcdef’实际存储为： ‘abcdef\0\0’<br>‘abcdefg’实际存储为： ‘abcdefg\0’<br>‘abcdefgh’实际存储为： ‘abcdefgh’<br>‘abcdefghi’实际存储为： ‘abcdefgh’</p>
</blockquote>
<p>user_name  VARCHAR(8)：   变长字符串，不会产生空间浪费，但读取速度稍慢</p>
<blockquote>
<p> ‘a’  实际存储为： ‘a\0’<br> ‘ab’实际存储为： ‘ab\0’<br> ‘abc’实际存储为： ‘abc\0’<br> ‘abcd’实际存储为： ‘abcd\0’<br>‘abcde’实际存储为： ‘abcde\0’<br>‘abcdef’实际存储为： ‘abcdef\0’<br>‘abcdefg’实际存储为： ‘abcdefg\0’<br>‘abcdefgh’实际存储为： ‘abcdefgh’<br>‘abcdefghi’实际存储为： ‘abcdefgh’　</p>
</blockquote>
<h3 id="（3）日期时间类型"><a href="#（3）日期时间类型" class="headerlink" title="（3）日期时间类型"></a>（3）日期时间类型</h3><p>​    DATE : 日期类型，必须用引号括起来，采用’yyyy-mm-dd’格式。<br>​    TIME : 时间类型，必须用引号括起来，采用’hh:mi:ss’格式。<br>​    DATETIME : 时期时间类型，必须用引号括起来，采用’yyyy-mm-dd hh:mi:ss’格式。</p>
<h3 id="（4）布尔类型"><a href="#（4）布尔类型" class="headerlink" title="（4）布尔类型"></a>（4）布尔类型</h3><p>​    BOOL/BOOLEAN : 智能表示TRUE(等价于1)或FLASE(等价于0)。</p>
<h2 id="3-列上的约束"><a href="#3-列上的约束" class="headerlink" title="3.列上的约束"></a>3.列上的约束</h2><h3 id="1-Constraint约束"><a href="#1-Constraint约束" class="headerlink" title="(1)Constraint约束"></a>(1)Constraint约束</h3><p>列上的值往往是有限制，如：</p>
<p>性别:只能取男或者女<br>政治面貌：只能取党员，团员，群众之一</p>
<h3 id="2-主键约束-PRIMARY-KEY"><a href="#2-主键约束-PRIMARY-KEY" class="headerlink" title="(2)主键约束(PRIMARY  KEY)"></a>(2)主键约束(PRIMARY  KEY)</h3><p>语法：列名 类型 PRIMARY KEY<br>声明为”主键”的列上不能出现null值，且不能重复，如商品编号；表中所有的记录行会自动按照主键列上的值进行排序——一个表至多只能声明一个主键列。</p>
<h3 id="3-唯一约束-UNIQUE"><a href="#3-唯一约束-UNIQUE" class="headerlink" title="(3)唯一约束(UNIQUE)"></a>(3)唯一约束(UNIQUE)</h3><p>语法：列名 类型 UNIQUE<br>声明为”唯一”约束的列上不能出现重复值，但可以出现多个NULL</p>
<h3 id="4-非空约束-NOT-NULL"><a href="#4-非空约束-NOT-NULL" class="headerlink" title="(4)非空约束(NOT  NULL)"></a>(4)非空约束(NOT  NULL)</h3><p>语法：列名 类型 NOT  NULL<br>声明为”非空”约束的列上不能出现NULL，但可以重复。</p>
<h3 id="5-检查约束——MySQL不支持"><a href="#5-检查约束——MySQL不支持" class="headerlink" title="(5)检查约束——MySQL不支持"></a>(5)检查约束——MySQL不支持</h3><h3 id="6-默认值约束-DEFAULT"><a href="#6-默认值约束-DEFAULT" class="headerlink" title="(6)默认值约束(DEFAULT)"></a>(6)默认值约束(DEFAULT)</h3><p>语法：列名 类型 DEFAULT 值<br>声明了默认值的列若未指定值，则使用默认值；若指定的特定值的值，则使用指定的值。</p>
<h3 id="7-外键约束"><a href="#7-外键约束" class="headerlink" title="(7)外键约束"></a>(7)外键约束</h3><p>外键：POREIGN  KEY,可重复可为空，外键列上出现的值必须正另一个表的主键列上。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex笔记</title>
    <url>/2020/12/26/vuex%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Vuex笔记"><a href="#Vuex笔记" class="headerlink" title="Vuex笔记"></a>Vuex笔记</h1><h3 id="Vuex概述"><a href="#Vuex概述" class="headerlink" title="Vuex概述"></a>Vuex概述</h3><h4 id="vuex是什么"><a href="#vuex是什么" class="headerlink" title="vuex是什么"></a>vuex是什么</h4><p>​    vuex是实现组件全局状态（数据）管理的一种机制，可以方便实现组件之间数据的共享<br><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/image-20201221091304337.png"></p>
<span id="more"></span>

<h4 id="使用Vuex统一管理状态的好处"><a href="#使用Vuex统一管理状态的好处" class="headerlink" title="使用Vuex统一管理状态的好处"></a>使用Vuex统一管理状态的好处</h4><ul>
<li>能够在vuex中集中管理共享的数据，易于开发和后期维护</li>
<li>能够高效地实现组件之间的数据共享，提高开发效率</li>
<li>存储在Vuex中的数据都是响应式的，能够实施保持数据与页面的同步</li>
</ul>
<h4 id="什么样的数据适合存储到Vuex中"><a href="#什么样的数据适合存储到Vuex中" class="headerlink" title="什么样的数据适合存储到Vuex中"></a>什么样的数据适合存储到Vuex中</h4><p>​    一般情况下，只有组件之间共享的数据，才有必要存储到vuex中；对于组件中的私有数据，依旧存储在组件自身的data中即可</p>
<h3 id="vuex的基本使用"><a href="#vuex的基本使用" class="headerlink" title="vuex的基本使用"></a>vuex的基本使用</h3><h4 id="安装vuex依赖"><a href="#安装vuex依赖" class="headerlink" title="安装vuex依赖"></a>安装vuex依赖</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">npm</span> install vex --save</span><br></pre></td></tr></table></figure>

<h4 id="导入vuex包"><a href="#导入vuex包" class="headerlink" title="导入vuex包"></a>导入vuex包</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>

<h4 id="创建store对象"><a href="#创建store对象" class="headerlink" title="创建store对象"></a>创建store对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">  <span class="comment">// state中存放的就是全局共享的数据</span></span><br><span class="line">  state: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="将store对象挂载到vue实例中"><a href="#将store对象挂载到vue实例中" class="headerlink" title="将store对象挂载到vue实例中"></a>将store对象挂载到vue实例中</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  reader: <span class="function"><span class="params">h</span> =&gt;</span> h(app),</span><br><span class="line">  router,</span><br><span class="line">  <span class="comment">// 将创建的共享数据对象，挂载到vue实例中</span></span><br><span class="line">  <span class="comment">// 所有的组件，就可以直接从store中获取全局的数据了</span></span><br><span class="line">  store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="核心概念概述"><a href="#核心概念概述" class="headerlink" title="核心概念概述"></a>核心概念概述</h3><blockquote>
<p>vuex中的主要核心概念如下：</p>
<ul>
<li><strong>state</strong></li>
<li><strong>Mutation</strong></li>
<li><strong>Action</strong></li>
<li><strong>Getter</strong></li>
</ul>
</blockquote>
<h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>​    State提供唯一的公共数据源，所有的共享的数据都要统一放到Store的State中进行储存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建store数据源，提供唯一公共数据</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（1）组件访问State中数据的第一种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.全局数据名称</span><br></pre></td></tr></table></figure>

<p>（2）组件访问State中数据的第二种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从vuex中按需导入 mapState函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过刚刚导入的mapState函数，将当前组件需要的全局数据，映射为当前数据的computed计算属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.将全局数据，映射为当前组件的计算属性</span></span><br><span class="line">computed: &#123;</span><br><span class="line">	...mapState([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>Mutation用于变更Store中的数据</p>
<ol>
<li><p>只能通过mutation变更Store数据，不可以直接操作Store中的数据</p>
</li>
<li><p>通过这种方式虽然操作起来稍微繁琐一些，但是可以集中件套所有数据的变化</p>
</li>
</ol>
<h5 id="定义mutations"><a href="#定义mutations" class="headerlink" title="定义mutations"></a>定义mutations</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Mutation</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">	state: &#123;</span><br><span class="line">		count: <span class="number">0</span></span><br><span class="line">	&#125;,</span><br><span class="line">	mutations: &#123;</span><br><span class="line">		<span class="function"><span class="title">add</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//变更状态</span></span><br><span class="line">			state.count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="触发mutations"><a href="#触发mutations" class="headerlink" title="触发mutations"></a>触发mutations</h5><p>（1）触发mutations的第一种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发mutation</span></span><br><span class="line">methods: &#123;</span><br><span class="line">	<span class="function"><span class="title">handle1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//	触发mutation的第一种方式</span></span><br><span class="line">		<span class="built_in">this</span>.$store.commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在触发mutations时传递参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Mutation</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">	state: &#123;</span><br><span class="line">		count: <span class="number">0</span></span><br><span class="line">	&#125;,</span><br><span class="line">	mutations: &#123;</span><br><span class="line">		<span class="function"><span class="title">addN</span>(<span class="params">state, step</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//变更状态</span></span><br><span class="line">			state.count += step</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发mutation</span></span><br><span class="line">methods: &#123;</span><br><span class="line">	<span class="function"><span class="title">handle1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//	触发mutation的第一种方式</span></span><br><span class="line">		<span class="built_in">this</span>.$store.commit(<span class="string">&#x27;addN&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）触发mutations第二种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从vuex中按需导入mapMutations函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过刚才导入的mapMuntations函数，将需要的mutations函数，映射为当前组件的methods方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.将指定的mutations函数，映射为当前组件的methods函数</span></span><br><span class="line">methods: &#123;</span><br><span class="line">	...mapMutations([<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;addN&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><blockquote>
<p>Action用于处理异步任务</p>
</blockquote>
<p>如果通过异步操作变更数据，必须通过Action，而不能使用Mutation，但是在Action中还是要通过出发Mutation的方式间接变更数据。</p>
<h5 id="定义Action"><a href="#定义Action" class="headerlink" title="定义Action"></a>定义Action</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Action</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  	<span class="comment">// ...此处省略其他代码</span></span><br><span class="line">  mutaions: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">			state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">addAsync</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="触发Action"><a href="#触发Action" class="headerlink" title="触发Action"></a>触发Action</h5><p>（1）触发actions的第一种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">	<span class="function"><span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 触发actions的第一种方式</span></span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addAsync&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发actions异步任务时携带参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Action</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  	<span class="comment">// ...此处省略其他代码</span></span><br><span class="line">  mutaions: &#123;</span><br><span class="line">    <span class="function"><span class="title">addN</span>(<span class="params">state,step</span>)</span>&#123;</span><br><span class="line">			state.count += step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">addNAsync</span>(<span class="params">context, step</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;addN&#x27;</span>,step)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发actions</span></span><br><span class="line">methods:&#123;</span><br><span class="line">	<span class="function"><span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addAsync&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）触发actions的第二种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从vuex中按需导入mapActions函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过刚才导入的mapActions函数，映射为当前组件的methods函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">	...mapAction([&#39;addAsync&#39;,&#39;addNASync&#39;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h4><p>Getter用于对store中的数据进行加工处理形成新的数据</p>
<ul>
<li><p>Getter可以对Store中已有的数据加工处理之后形成新的数据，类似Vue的计算属性</p>
</li>
<li><p>Store中数据发生变化，Getter的数据也会跟着变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Getter</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    showNum: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`当前最新的数据时【 <span class="subst">$&#123;state.count&#125;</span> 】`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用Getter的第一种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.getters.名称</span><br></pre></td></tr></table></figure>

<p>使用Getter的第二种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters([<span class="string">&#x27;showNum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE组件之间通信的6种方式</title>
    <url>/2021/02/20/VUE%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%846%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1-方法一：props和-emit"><a href="#1-方法一：props和-emit" class="headerlink" title="1.方法一：props和**$emit**"></a>1.方法一：<strong>props</strong>和**$emit**</h3><p>父组件通过props向下传递数据给子组件，子组件通过event给父组件发送消息，实际上就是子组件把自己的数据发送给父组件。</p>
<h3 id="2-方法二：-attrs和-listeners"><a href="#2-方法二：-attrs和-listeners" class="headerlink" title="2.方法二：**$attrs和$listeners**"></a>2.方法二：**$attrs<strong>和</strong>$listeners**</h3><p>​    第一种方式处理父子组件之间的数据传输有一个问题：如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？ 如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C；要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件A之间传递消息给组件C。</p>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--组件C--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;$attrs.messagec&quot; @input&#x3D;&quot;passCData($attrs.messagec)&quot;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">    name: &#39;C&#39;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      passCData(val)&#123;</span><br><span class="line">        &#x2F;&#x2F;触发父组件A中的事件,把从A得到的数据hello C还给A组件</span><br><span class="line">        this.$emit(&#39;getCData&#39;,val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--组件B--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;mymessage&quot; @input&#x3D;&quot;passData(mymessage)&quot;&gt;</span><br><span class="line">    &lt;!-- C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 --&gt;</span><br><span class="line">    &lt;!-- 通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） --&gt;</span><br><span class="line">    &lt;C v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot;&gt;&lt;&#x2F;C&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">    name: &#39;B&#39;,</span><br><span class="line">    props:[</span><br><span class="line">      message:&#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: null</span><br><span class="line">      &#125;</span><br><span class="line">    ],&#x2F;&#x2F;得到父组件A传递过来的数据,hello B</span><br><span class="line">    methods:&#123;</span><br><span class="line">      passData(val)&#123;</span><br><span class="line">        &#x2F;&#x2F;触发父组件中的事件,把message给组件A</span><br><span class="line">        this.$emit(&#39;getChildData&#39;,val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--组件A--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;p&gt;this is parent compoent!&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;B </span><br><span class="line">     :messagec&#x3D;&quot;messagec&quot; </span><br><span class="line">     :message&#x3D;&quot;message&quot; </span><br><span class="line">     :getCData&#x3D;&quot;getCData&quot;</span><br><span class="line">     :getChildData&#x3D;&quot;getChildData&quot;&gt;&lt;&#x2F;B&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">    name: &#39;A&#39;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message:&#39;hello B&#39;,</span><br><span class="line">        messagec:&#39;hello C&#39; &#x2F;&#x2F;传递给c组件的数据</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      getChildData(val)&#123;</span><br><span class="line">        console.log(&#39;这是来自B组件的数据&#39;,val) &#x2F;&#x2F;打印hello B</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F;执行C子组件触发的事件</span><br><span class="line">      getCData(val)&#123;</span><br><span class="line">        console.log(&quot;这是来自C组件的数据：&quot;, val) &#x2F;&#x2F;打印hello C</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="3-方法3：provide和-inject"><a href="#3-方法3：provide和-inject" class="headerlink" title="3.方法3：provide和 inject"></a>3.方法3：<strong>provide</strong>和 <strong>inject</strong></h3><p>在 Vue.js 的 <code>2.2.0+</code> 版本中添加加了 provide 和 inject 选项。他们成对出现，用于父级组件向下传递数据。</p>
<p>父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provide中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;this is parent compoent!&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;child&gt;&lt;&#x2F;child&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">    name: &#39;parent&#39;,</span><br><span class="line">    provide: &#123;</span><br><span class="line">      forChidrenData:&#39;这是要个子组件的数据&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message:&#39;hello&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;mymessage&quot;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">    name: &#39;child&#39;,</span><br><span class="line">    inject:[&#39;forChidrenData&#39;], &#x2F;&#x2F;得到父组件传递过来的数据</span><br><span class="line">    provide: &#123;</span><br><span class="line">      forChidrenData:&#39;这是要个子组件的数据&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        mymessage:this.forChidrenData</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="4-方法四：vuex处理组件之间的数据交互"><a href="#4-方法四：vuex处理组件之间的数据交互" class="headerlink" title="4.方法四：vuex处理组件之间的数据交互"></a>4.方法四：<strong>vuex处理组件之间的数据交互</strong></h3><p>​    如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>
<h3 id="5-方法五：中央事件总线"><a href="#5-方法五：中央事件总线" class="headerlink" title="5.方法五：中央事件总线"></a>5.方法五：<strong>中央事件总线</strong></h3><p>​    如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。</p>
<blockquote>
<p>公共事件总线eventBus的实质就是创建一个vue实例，通过一个空的vue实例作为桥梁实现vue组件间的通信。它是实现非父子组件通信的一种解决方案。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--兄弟组件A--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;this is brother1 compoent!&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;mymessage&quot; @input&#x3D;&quot;passData(mymessage)&quot;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">    name: &#39;brother1&#39;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        mymessage:&#39;hello brother1&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      passData(val)&#123;</span><br><span class="line">        &#x2F;&#x2F;触发全局事件globalEvent</span><br><span class="line">        bus.$emit(&#39;globalEvent&#39;, val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--兄弟组件B--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;this is brother2 compoent!&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">    name: &#39;brother2&#39;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        brothermessage:&#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">      &#x2F;&#x2F;绑定全局事件globalEvent</span><br><span class="line">      bus.$on(&#39;globalEvent&#39;,(val)&#x3D;&gt;&#123;</span><br><span class="line">        this.brothermessage &#x3D; val;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;中央事件总线</span><br><span class="line">var bus&#x3D;new Vue();</span><br><span class="line">var app&#x3D;new Vue(&#123;</span><br><span class="line">  el:&#39;#app&#39;,</span><br><span class="line">  template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;brother1&gt;&lt;&#x2F;brother1&gt;</span><br><span class="line">      &lt;brother2&gt;&lt;&#x2F;brother2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;,</span><br><span class="line">   beforeDestroy()&#123;</span><br><span class="line">sd     bus.$off(&#39;globalEvent&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="6-方法六：-parent和-children"><a href="#6-方法六：-parent和-children" class="headerlink" title="6.方法六：**$parent和$children**"></a>6.方法六：**$parent<strong>和</strong>$children**</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;child&#39;,&#123;</span><br><span class="line">  props:&#123;</span><br><span class="line">    value:String, &#x2F;&#x2F;v-model会自动传递一个字段为value的prop属性</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      mymessage:this.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    changeValue()&#123;</span><br><span class="line">      this.$parent.message &#x3D; this.mymessage;&#x2F;&#x2F;通过如此调用可以改变父组件的值</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;mymessage&quot; @change&#x3D;&quot;changeValue&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line">Vue.component(&#39;parent&#39;,&#123;</span><br><span class="line">  template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;this is parent compoent!&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;changeChildValue&quot;&gt;test&lt;&#x2F;button &gt;</span><br><span class="line">      &lt;child&gt;&lt;&#x2F;child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    changeChildValue()&#123;</span><br><span class="line">      this.$children[0].mymessage &#x3D; &#39;hello&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message:&#39;hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var app&#x3D;new Vue(&#123;</span><br><span class="line">  el:&#39;#app&#39;,</span><br><span class="line">  template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;parent&gt;&lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目打包优化策略</title>
    <url>/2020/11/18/vue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>使用vue-cli部署生产包时，发现资源包很大，打包后的<code>vendor.js</code>达到了1.4M，这已经很大了，而且会影响到首屏加载。那么，怎么优化呢？</p>
<h3 id="1-组件按需加载"><a href="#1-组件按需加载" class="headerlink" title="1.组件按需加载"></a>1.组件按需加载</h3><p>这是首先可以优化的点。如果频繁使用了第三方组件/UI库，如我的项目中经常同时使用了 element-ui, mint-ui,echarts等组件库，如果全部引入，项目体积非常大，这时可以按需引入组件。</p>
<p>示例如下：</p>
<h4 id="1-1-element-ui"><a href="#1-1-element-ui" class="headerlink" title="1.1 element-ui"></a>1.1 element-ui</h4><p>首先，安装 babel-plugin-component：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>然后，将.babelrc 修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import &#123; Dialog, Loading &#125; from &#39;element-ui&#39;</span><br><span class="line">Vue.use(Dialog)</span><br><span class="line">Vue.use(Loading.directive)</span><br><span class="line">Vue.prototype.$loading &#x3D; Loading.service</span><br><span class="line">&#x2F;&#x2F; 然后正常使用组件</span><br></pre></td></tr></table></figure>

<h4 id="1-2-mint-ui"><a href="#1-2-mint-ui" class="headerlink" title="1.2 mint-ui"></a>1.2 mint-ui</h4><p>由于mint-ui是element-ui的移动端组件，所以它的使用和引入几乎和element-ui一样。</p>
<p>首先，安装 babel-plugin-component：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>



<p>然后，将.babelrc 修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [[&quot;component&quot;, [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;libraryName&quot;: &quot;mint-ui&quot;,</span><br><span class="line">      &quot;style&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  ]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后引入部分组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import &#123; Toast, MessageBox &#125; from &#39;element-ui&#39;</span><br><span class="line">Vue.use(Dialog)</span><br><span class="line">Vue.use(Loading.directive)</span><br><span class="line">Vue.prototype.$loading &#x3D; Loading.service</span><br><span class="line">&#x2F;&#x2F; 然后正常使用组件</span><br></pre></td></tr></table></figure>

<p>注意，element-ui和mint-ui不能同时在.babelrc中进行插件设置，这种情况下，依然可以按需引入，但是不要在<code>.babelrc</code>中配置，在引入的地方同时引入css即可。</p>
<h4 id="1-3-echarts"><a href="#1-3-echarts" class="headerlink" title="1.3 echarts"></a>1.3 echarts</h4><p>首先安装babel-plugin-equire</p>
<p>npm i babel-plugin-equire -D</p>
<p>然后，在<code>.babelrc</code>文件中添加该插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">       &#x2F;&#x2F; other plugins</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">    &quot;equire&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建一个js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; echarts.js</span><br><span class="line">&#x2F;&#x2F; eslint-disable-next-line</span><br><span class="line">const echarts &#x3D; equire([</span><br><span class="line">  &#39;tooltip&#39;,</span><br><span class="line">  &#39;candlestick&#39;,</span><br><span class="line">  &#39;bar&#39;,</span><br><span class="line">  &#39;line&#39;,</span><br><span class="line">  &#39;axisPointer&#39;,</span><br><span class="line">  &#39;legend&#39;,</span><br><span class="line">  &#39;grid&#39;</span><br><span class="line">])</span><br><span class="line">export default echarts</span><br><span class="line">&#x2F;&#x2F; 业务组件，引入echarts</span><br><span class="line">import echarts from &#39;@&#x2F;assets&#x2F;lib&#x2F;echarts&#39;</span><br><span class="line">&#x2F;&#x2F; 使用与以前一样</span><br></pre></td></tr></table></figure>



<p>按需加载echarts</p>
<p>解决vue-cli首屏加载慢的问题</p>
<h3 id="2-路由懒加载"><a href="#2-路由懒加载" class="headerlink" title="2.路由懒加载"></a>2.路由懒加载</h3><p>这里需要一个插件</p>
<p>vue-router官方推荐syntax-dynamic-import插件，不过它要求同时安装@bable/core^7.0.0，如果你安装了babel-core6，是会有版本冲突的。我的做法如下</p>
<p>npm install babel-plugin-syntax-dynamic-import –save-dev(^6.18.0)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; router.js</span><br><span class="line">const login &#x3D; () &#x3D;&gt; import(&#39;@&#x2F;components&#x2F;login&#39;)</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;login&#39;, component: login &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>还有一种魔法注释用法</p>
<p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Foo &#x3D; () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;group-foo&quot; *&#x2F; &#39;.&#x2F;Foo.vue&#39;)</span><br></pre></td></tr></table></figure>





<h3 id="3-异步组件"><a href="#3-异步组件" class="headerlink" title="3.异步组件"></a>3.异步组件</h3><p>如果组件在页面加载时不需要，只在调用时用到，这时可以使用异步组件的写法。仅仅是引入和组件注册写法不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; template</span><br><span class="line">&lt;test v-if&#x3D;&quot;showTest&quot;&gt;&lt;&#x2F;test&gt;</span><br><span class="line">&#x2F;&#x2F; script</span><br><span class="line">  components: &#123;</span><br><span class="line">    test: () &#x3D;&gt; import(&#39;.&#x2F;test&#39;) &#x2F;&#x2F; 将组件异步引入，告诉webpack，将该部分代码分割打包</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">      clickTest () &#123;</span><br><span class="line">          this.showTest &#x3D; !this.showTest</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-图片的压缩合并"><a href="#4-图片的压缩合并" class="headerlink" title="4.图片的压缩合并"></a>4.图片的压缩合并</h3><p>如有可能，将图片制作成精灵图</p>
<h3 id="5-CDN加速"><a href="#5-CDN加速" class="headerlink" title="5.CDN加速"></a>5.CDN加速</h3><p>在index.html中引入cdn资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;!-- built files will be auto injected --&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue&#x2F;2.5.2&#x2F;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue-router&#x2F;3.0.1&#x2F;vue-router.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vuex&#x2F;3.0.1&#x2F;vuex.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue-resource&#x2F;1.5.1&#x2F;vue-resource.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>修改 build/webpack.base.conf.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  context: path.resolve(__dirname, &#39;..&#x2F;&#39;),</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#39;.&#x2F;src&#x2F;main.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  externals:&#123;</span><br><span class="line">    &#39;vue&#39;: &#39;Vue&#39;,</span><br><span class="line">    &#39;vue-router&#39;: &#39;VueRouter&#39;,</span><br><span class="line">    &#39;vuex&#39;:&#39;Vuex&#39;,</span><br><span class="line">    &#39;vue-resource&#39;: &#39;VueResource&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>修改src/main.js src/router/index.js 注释掉import引入的vue,vue-resource</p>
<p>// import Vue from ‘vue’</p>
<p>// import VueResource from ‘vue-resource’</p>
<p>// Vue.use(VueResource)</p>
<h3 id="6-压缩代码"><a href="#6-压缩代码" class="headerlink" title="6.压缩代码"></a>6.压缩代码</h3><p>vue-cli已经使用UglifyJsPlugin 插件来压缩代码，可以设置成如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">  compress: &#123;</span><br><span class="line">    warnings: false,</span><br><span class="line">    drop_console: true,</span><br><span class="line">    pure_funcs: [&#39;console.log&#39;]</span><br><span class="line">  &#125;,</span><br><span class="line">  sourceMap: false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其中sourceMap: false是禁用除错功能。</p>
<p>如果设为true，在部署包中会生成.map结尾的js文件。它用于在代码混淆压缩的情况下仍可进行调试。这个功能虽好，但会大大增加整体资源包的体积，所以将其禁用。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手四次挥手的原理</title>
    <url>/2021/03/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>  握手的过程：</p>
<p>   1、第一次握手：客户端给服务器发送一个 SYN 报文。</p>
<p>   2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。</p>
<p>   3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。</p>
<p>   4、服务器收到 ACK 报文之后，三次握手建立完成。</p>
<p>   作用是为了确认双方的接收与发送能力是否正常。</p>
   <span id="more"></span>

<p>   <strong>这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：</strong></p>
<blockquote>
<p>   第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>   第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>   第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>
</blockquote>
<p>   因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>   这样回答其实也是可以的，但我觉得，这个过程的我们应该要描述的更<strong>详细一点</strong>，因为三次握手的过程中，双方是<strong>由很多状态的改变的</strong>，而这些状态，也是面试官可能会问的点。所以我觉得在回答三次握手的时候，我们应该要描述的详细一点，而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：</p>
<p>   <strong>刚开始客户端处于 closed 的状态，服务端处于 listen 状态</strong>。然后<br>   1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 <strong>ISN（c）</strong>。此时客户端处于 <strong>SYN_Send</strong> 状态。</p>
<p>   2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <strong>SYN_REVD</strong> 的状态。</p>
<p>   3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <strong>establised</strong> 状态。</p>
<p>   4、服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了链接。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/2019060815530363.png"></p>
<h3 id="1、三次握手的作用"><a href="#1、三次握手的作用" class="headerlink" title="1、三次握手的作用"></a>1、三次握手的作用</h3><p>   三次握手的作用也是有好多的，多记住几个，保证不亏。例如：<br>   1、确认双方的接受能力、发送能力是否正常。<br>   2、指定自己的初始化序列号，为后面的可靠传送做准备。<br>   3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>
<h3 id="2、（ISN）是固定的吗？"><a href="#2、（ISN）是固定的吗？" class="headerlink" title="2、（ISN）是固定的吗？"></a>2、（ISN）是固定的吗？</h3><p>   三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>   <strong>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</strong></p>
<h3 id="3、什么是半连接队列"><a href="#3、什么是半连接队列" class="headerlink" title="3、什么是半连接队列"></a>3、什么是半连接队列</h3><p>   服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<blockquote>
<p>   这里在补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, …</p>
</blockquote>
<h3 id="4、三次握手过程中可以携带数据吗"><a href="#4、三次握手过程中可以携带数据吗" class="headerlink" title="4、三次握手过程中可以携带数据吗"></a>4、三次握手过程中可以携带数据吗</h3><p>   很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>
<p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。<br>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>   <strong>四次挥手也一样，千万不要对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。然后结束，最好是说的详细一点，例如想下面这样就差不多了，要把每个阶段的状态记好。</strong></p>
<p>   刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：</p>
<p>   1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>FIN_WAIT1</strong>状态。</p>
<p>   2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT</strong>状态。</p>
<p>   3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</p>
<p>   4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p>
<p>   5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190608160051238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtaXNwb3NzaWJsZQ==,size_16,color_FFFFFF,t_70"></p>
<p>   这里特别需要主要的就是TIME_WAIT这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p>
<p>   至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<p>   <strong>这里我给出每个状态所包含的含义，有兴趣的可以看看。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LISTEN - 侦听来自远方TCP端口的连接请求； </span><br><span class="line">SYN-SENT -在发送连接请求后等待匹配的连接请求； </span><br><span class="line">SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； </span><br><span class="line">ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； </span><br><span class="line">FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</span><br><span class="line">FIN-WAIT-2 - 从远程TCP等待连接中断请求；</span><br><span class="line">CLOSE-WAIT - 等待从本地用户发来的连接中断请求； </span><br><span class="line">CLOSING -等待远程TCP对连接中断的确认； </span><br><span class="line">LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； </span><br><span class="line">TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； </span><br><span class="line">CLOSED - 没有任何连接状态；</span><br></pre></td></tr></table></figure>


<p>   <strong>最后，在放张三次握手与四次挥手的图</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20190608160404569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtaXNwb3NzaWJsZQ==,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hbuilder快速打包一个app</title>
    <url>/2018/07/12/%E4%BD%BF%E7%94%A8Hbuilder%E5%BF%AB%E9%80%9F%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AAapp/</url>
    <content><![CDATA[<p>HBuilder提供的打包有云端打包和本地打包两种，云端打包的特点是DCloud官方配置好了原生的打包环境，可以把HTML等文件编译为原生安装包。</p>
<p>优点：速度快，所需要的环境少，加快了开发者速度，不会因为各种JDK，java，Android环境而无法打包生成apk或ipa头疼，大大减少了开发繁琐操作。</p>
<p>方法步骤：</p>
<span id="more"></span>

<p>1.下载HBuilder，注册并登陆。首先打开“文件”-“新建”-“移动APP”，输入“应用名称”，“位置”可以根据需要自己选择即可，“选择模板”建议选择空模板，如下图所示：</p>
<p>​​<img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712163802432"></p>
<p>2.新建完成后， 在项目管理器会显示新建的项目目录，其中css，img，js和index.html这几个文件可删可改可替换。<br>unpackage文件夹是放置app图标和启动界面的图片。</p>
<p>manifest.json文件是移动App的配置文件，用于指定应用的显示名称、图标、应用入口文件地址及需要使用的设备权限等信息，用户可通过HBuilder的可视化界面视图或者源码视图来配置移动App的信息，如下图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712164108624"></p>
<p>3.如果删除了css，img，js文件夹和index.html文件，就把其他自己打包好的的项目文件对应复制到文件夹中，注意html文件中的引用路径需要保持正确，如下图自己拷贝的项目（我的是项目打包后的build文件和index.html文件，其中css/js/img都在build文件夹下）：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712164250660"></p>
<p>4.文件复制完成后，刷新更新下，双击打开manifest.json文件来配置App。</p>
<p>appid：点击云端获取。版本号：根据需要来编辑。页面入口：默认是index.html，根据自己项目需要，更改APP的启动页面。应用描述：自己随便填。应用是否全屏显示：勾上就全屏显示，如下图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712164915305"></p>
<p>5.图标配置：点击页面下方的图标配置，配置APP显示图标。</p>
<p>点击”+”号的正方形方框，选择图标素材的路径找到图标素材，再点击” 自动生成所有图标并替换”按钮，完成图标生成和替换，如下图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712165506582"></p>
<p>生成的图标自动在unpackage文件夹下，如下图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712165618254"></p>
<p>6.在启动图片设置里点击”选择”，找到刚放进来的启动图片，如下图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712165842174"></p>
<p>7.SDK配置：有需要就配置，没有就默认就行。</p>
<p>   模块权限配置：有需要就配置，没有就默认就行。</p>
<p>8.云端打包：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712170045185"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712170127683"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712170219731"></p>
<p>然后等待几分钟，刷新状态，就可以看到制作完成，是否下载？点击下载。然后将apk发送到手机上安装就可以正常运行了！</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712171021649"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/2018071217113978"></p>
<p>以下是apk安装后再模拟器上运行效果：</p>
<p><img data-src="https://img-blog.csdn.net/20180712171240702?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDE1NTQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p><img data-src="https://img-blog.csdn.net/20180712171322289?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDE1NTQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p><img data-src="https://img-blog.csdn.net/20180712171518460?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDE1NTQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
]]></content>
      <categories>
        <category>Hbuilder</category>
      </categories>
      <tags>
        <tag>Hbuilder</tag>
      </tags>
  </entry>
  <entry>
    <title>函数防抖与节流</title>
    <url>/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><h3 id="一、为什么需要防抖"><a href="#一、为什么需要防抖" class="headerlink" title="一、为什么需要防抖"></a>一、为什么需要防抖</h3><ul>
<li>高频的函数操作可能产生不好的影响</li>
<li>如：resize、scroll、mousedown、mousemove、keyup、keydown……</li>
</ul>
<p>为此，我们举个示例代码来了解事件如何频繁的触发：</p>
<p>我们写一个 index.html 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;title&gt;debounce&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #wrapper &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            line-height: 200px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            color: #fff;</span><br><span class="line">            background-color: #444;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;wrapper&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var count &#x3D; 1;</span><br><span class="line">        var oDiv &#x3D; document.getElementById(&quot;wrapper&quot;);</span><br><span class="line">        function getUserAction() &#123;</span><br><span class="line">            oDiv.innerHTML &#x3D; count++;</span><br><span class="line">        &#125;</span><br><span class="line">        oDiv.onmousemove &#x3D; getUserAction;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>从左边滑到右边就触发了近100次<code>getUserAction</code> 函数！看如下Gif：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408456-269506ee-a343-41c8-86b8-e80da9304d8e.gif"></p>
<p>因为这个例子很简单，所以浏览器完全反应的过来，但假设：</p>
<ul>
<li>它的触发频次极高，1分钟2000次，且涉及到大量的位置计算、DOM 操作等工作，</li>
<li>存在接口请求，单个函数执行时间较长，但每个函数触发的间隔很近。</li>
</ul>
<p>这种在一瞬间（短时间内）对浏览器或服务器造成了过多压力的交互就需要进行优化了，为了解决这个问题，一般有两种解决方案：</p>
<ul>
<li>debounce 防抖</li>
<li>throttle 节流</li>
</ul>
<p>他们的目的都是：<strong>降低一个函数的触发频率，以提高性能或避免资源浪费。</strong></p>
<h3 id="二、防抖的原理"><a href="#二、防抖的原理" class="headerlink" title="二、防抖的原理"></a>二、防抖的原理</h3><p>今天重点讲讲防抖的实现。</p>
<p>防抖的原理就是：你尽管触发事件，但是我一定在事件触发<code>n秒无操作后</code>才执行。举个例子：</p>
<p>我们规定<code>3s</code>为防抖的标准，那么:</p>
<ol>
<li>第一次要求执行事件 - 此时倒计时3s</li>
<li>倒计时2s</li>
<li>倒计时1s</li>
<li>0.5s时事件再次被触发 - 此时倒计时3s</li>
<li>…3s内无事发生</li>
<li>执行事件，共用了5.5s</li>
</ol>
<h3 id="三、自己实现一个防抖"><a href="#三、自己实现一个防抖" class="headerlink" title="三、自己实现一个防抖"></a>三、自己实现一个防抖</h3><h4 id="3-1-第一版"><a href="#3-1-第一版" class="headerlink" title="3.1 第一版"></a>3.1 第一版</h4><p>我们根据上一节提到的核心思想，实现第一版代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer &#x3D; setTimeout(func, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要使用它，第一节的例子为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oDiv.onmousemove &#x3D; debounce(getUserAction, 2000);</span><br></pre></td></tr></table></figure>

<p>此时大家可以再次测试一下，事件持续发生时，只有在完全停止2s后，才会触发事件：</p>
<p>写到这里，作为针对部分高频事件的需求来说，已经结束了。我们来看看他的效果：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408554-b0245fd8-1c4d-4085-80da-f91d8be8da6f.gif"></p>
<h4 id="3-2-第二版"><a href="#3-2-第二版" class="headerlink" title="3.2 第二版"></a>3.2 第二版</h4><p>大家都知道，dom节点在触发事件的时候，this指向它本身，本例中则指向<code>oDiv</code>，但是在本例中：我们看一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count &#x3D; 1;</span><br><span class="line">var oDiv &#x3D; document.getElementById(&quot;oDiv&quot;);</span><br><span class="line">function getUserAction() &#123;</span><br><span class="line">    oDiv.innerHTML &#x3D; count++;</span><br><span class="line">    console.log(&#39;this&#39;, this); &#x2F;&#x2F; 此时输出 Window...</span><br><span class="line">&#125;</span><br><span class="line">oDiv.onmousemove &#x3D; debounce(getUserAction, 2000);</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer &#x3D; setTimeout(func, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毕竟经过了一层匿名函数的包裹，this已经指向了window，为了减少影响，我们尝试修正它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this &#x3D; this; &#x2F;&#x2F; 记录当前this</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer &#x3D; setTimeout(function()&#123;</span><br><span class="line">            func.apply(_this); &#x2F;&#x2F;将 func的this改为_this</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-第三版"><a href="#3-3-第三版" class="headerlink" title="3.3 第三版"></a>3.3 第三版</h4><p>解决的this指向问题，我们的函数仍然不够“完美”，JavaScript中，事件处理函数会提供<code>event</code>对象，我们简称为e。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用了 debouce 函数</span><br><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    console.log(e); &#x2F;&#x2F; undefined</span><br><span class="line">    oDiv.innerHTML &#x3D; count++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了保证它的原汁原味，我们再改第三版：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count &#x3D; 1;</span><br><span class="line">var oDiv &#x3D; document.getElementById(&quot;oDiv&quot;);</span><br><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    oDiv.innerHTML &#x3D; count++;</span><br><span class="line">    console.log(&#39;e&#39;, e); &#x2F;&#x2F; MouseEvent</span><br><span class="line">&#125;</span><br><span class="line">oDiv.onmousemove &#x3D; debounce(getUserAction, 2000);</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this &#x3D; this; &#x2F;&#x2F; 记录当前this</span><br><span class="line">        var arg &#x3D; arguments; &#x2F;&#x2F; 记录参数</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">            func.apply(_this, arg); &#x2F;&#x2F;将 func的this改为_this</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，我们在尽可能保留Dom事件原有能力的情况下，给函数加上了防抖效果，它可以解决大部分我们日常开发的防抖问题，但我们需要更“完美”</p>
<h3 id="四、防抖进阶"><a href="#四、防抖进阶" class="headerlink" title="四、防抖进阶"></a>四、防抖进阶</h3><h4 id="4-1-立即执行"><a href="#4-1-立即执行" class="headerlink" title="4.1 立即执行"></a>4.1 立即执行</h4><p>这个需求就是：</p>
<ul>
<li>立即执行</li>
<li>保持<code>n</code>秒空白期</li>
<li>将<code>n</code>秒空白期置后</li>
</ul>
<p>想想这个需求也是很有道理的嘛，那我们加个<code>immediate</code>参数判断是否是立刻执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line">        if (timer) clearTimeout(timer); &#x2F;&#x2F; 常规流程，间隔内触发时清掉重置定时</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果已经执行过，不再执行</span><br><span class="line">            var callNow &#x3D; !timer; &#x2F;&#x2F; 1. callNow 初始值是 true, 同步立即执行；随后 timer 才开始执行</span><br><span class="line">            timer &#x3D; setTimeout(function()&#123;</span><br><span class="line">                timer &#x3D; null; &#x2F;&#x2F; wait 期间，timer 是一个 ID 数字，所以 callNow 为 false，func 在此期间永远不会执行</span><br><span class="line">            &#125;, wait) &#x2F;&#x2F; wait 之后，timer 赋值 null，callNow 为 true，func 又开始立即执行。</span><br><span class="line">            if (callNow) func.apply(_this, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timer &#x3D; setTimeout(function()&#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看下此时他是什么效果：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408487-78c69123-24ec-4893-b442-366d3117eda2.gif"></p>
<h4 id="4-2-添加简单验证"><a href="#4-2-添加简单验证" class="headerlink" title="4.2 添加简单验证"></a>4.2 添加简单验证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    &#x2F;&#x2F; 检查函数</span><br><span class="line">    if (typeof func !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        throw new TypeError(&#39;Expected a function&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 保证wait存在</span><br><span class="line">    wait &#x3D; +wait || 0;</span><br><span class="line">    const debounced &#x3D; function () &#123;</span><br><span class="line">        var _this &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line">        if (timer) clearTimeout(timer); &#x2F;&#x2F; 常规流程，间隔内触发时清掉重置定时</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果已经执行过，不再执行</span><br><span class="line">            var callNow &#x3D; !timer; &#x2F;&#x2F; 如果不存在定时器，则callNow为true</span><br><span class="line">            timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">                timer &#x3D; null; &#x2F;&#x2F; 为了保证之后的时效性，手动添加timer</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            &#x2F;&#x2F; 因为不存在timer，证明是首次执行，所以直接调用</span><br><span class="line">            if (callNow) func.apply(_this, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-添加取消事件方法"><a href="#4-3-添加取消事件方法" class="headerlink" title="4.3 添加取消事件方法"></a>4.3 添加取消事件方法</h4><p>如果你希望能取消被防抖的事件，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    &#x2F;&#x2F; 检查函数</span><br><span class="line">    if (typeof func !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        throw new TypeError(&#39;Expected a function&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 保证wait存在</span><br><span class="line">    wait &#x3D; +wait || 0;</span><br><span class="line">    const debounced &#x3D; function () &#123;</span><br><span class="line">        var _this &#x3D; this;</span><br><span class="line">        var args &#x3D; arguments;</span><br><span class="line">        if (timer) clearTimeout(timer); &#x2F;&#x2F; 常规流程，间隔内触发时清掉重置定时</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果已经执行过，不再执行</span><br><span class="line">            var callNow &#x3D; !timer; &#x2F;&#x2F; 如果不存在定时器，则callNow为true</span><br><span class="line">            timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">                timer &#x3D; null; &#x2F;&#x2F; 为了保证之后的时效性，手动添加timer</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            &#x2F;&#x2F; 因为不存在timer，证明是首次执行，所以直接调用</span><br><span class="line">            if (callNow) func.apply(_this, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const cancel &#x3D; function()&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    const pending &#x3D; function()&#123;</span><br><span class="line">        return timer !&#x3D;&#x3D; undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.cancel &#x3D; cancel;</span><br><span class="line">    debounced.pending &#x3D; pending;</span><br><span class="line">    return debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看看效果：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408427-b468ccd4-99ff-4eee-821a-290d95e04071.gif"></p>
<h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们还是以移动事件举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #wrapper &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 140px;</span><br><span class="line">            background: rgba(0, 0, 0, 0.8);</span><br><span class="line">            color: #fff;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">            font-weight: bold;</span><br><span class="line">            line-height: 140px;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;wrapper&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var count &#x3D; 1;</span><br><span class="line">        function moveAction () &#123;</span><br><span class="line">            oWrapper.innerHTML &#x3D; count++;</span><br><span class="line">        &#125;</span><br><span class="line">        var oWrapper &#x3D; document.querySelector(&#39;#wrapper&#39;);</span><br><span class="line">        oWrapper.onmousemove &#x3D; moveAction;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>它的效果是这样：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551747-de70166f-f851-412c-ba2a-5a116a194f3d.gif"></p>
<h3 id="一、核心和基本实现"><a href="#一、核心和基本实现" class="headerlink" title="一、核心和基本实现"></a>一、核心和基本实现</h3><p>节流的原理很简单：<strong>如果你持续触发某个事件，特定的时间间隔内，只执行一次。</strong></p>
<p><strong>关于节流的实现，有两种主流的实现方式：</strong></p>
<ol>
<li>时间戳思路</li>
<li>定时器思路</li>
</ol>
<h4 id="1-1-时间戳思路"><a href="#1-1-时间戳思路" class="headerlink" title="1.1 时间戳思路"></a>1.1 时间戳思路</h4><p>顾名思义，通过两个时间戳来控制时间间隔，当触发事件的时候：</p>
<ol>
<li>我们取出当前的时间戳 <code>now</code>；</li>
<li>然后减去之前<strong>执行时</strong>的时间戳(首次值为 0 ) <code>prev</code>；</li>
<li>如果大<code>now - prev &gt; wait</code>，证明时间区间维护结束，执行指定事件，更新<code>prev</code>；</li>
</ol>
<p>根据这一思路，我们就可以实现第一版代码了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oWrapper.onmousemove &#x3D; throttle(moveAction, 1000);</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var _this, arg;</span><br><span class="line">    var prev &#x3D; 0; &#x2F;&#x2F; 上一次触发的时间，第一次默认为0</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var now &#x3D; Date.now(); &#x2F;&#x2F; 触发时的时间</span><br><span class="line">        _this &#x3D; this;</span><br><span class="line">        if (now - prev &gt; wait) &#123;</span><br><span class="line">            func.apply(_this, arg); &#x2F;&#x2F; 允许传入参数，并修正this</span><br><span class="line">            prev &#x3D; now; &#x2F;&#x2F; 更新上一次触发的时间</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看看借助它，效果是什么样的：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740552204-2bb5f2b1-3807-4d26-b3eb-d34e798ab60a.gif"></p>
<p>我们可以看到：</p>
<ol>
<li>当鼠标移入的时候，<strong>事件立刻执行</strong></li>
<li>每过 1s 会执行一次，且移动2.5s会执行2次，意味着动作<strong>停止后不会再执行</strong>。</li>
</ol>
<h4 id="1-2-定时器思路"><a href="#1-2-定时器思路" class="headerlink" title="1.2 定时器思路"></a>1.2 定时器思路</h4><p>利用定时器来保证间隔时间内事件的触发次数</p>
<ol>
<li>创建定时器<code>timer</code>，记录当前是否在<strong>周期</strong>内；</li>
<li>判断定时器是否存在，若存在则直接结束，否则执行事件；</li>
<li><code>wait</code>时间之后再次执行，并清掉定时器；</li>
</ol>
<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var _this, arg;</span><br><span class="line">    var timer; &#x2F;&#x2F; 初始化</span><br><span class="line">    return function () &#123;</span><br><span class="line">        _this &#x3D; this; &#x2F;&#x2F; 记录this</span><br><span class="line">        arg &#x3D; arguments; &#x2F;&#x2F; 记录参数数组</span><br><span class="line">        if (timer) return; &#x2F;&#x2F; 时候未到</span><br><span class="line">        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            func.apply(_this, arg); &#x2F;&#x2F; 允许传入参数，并修正this</span><br><span class="line">            timer &#x3D; null;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看看借助它，效果是什么样的：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551861-12bc2cce-f80a-45ff-9913-7798160b3438.gif"></p>
<p>但是，我们可以看到：</p>
<ol>
<li>当鼠标移入的时候，事件不会立刻执行;</li>
<li>鼠标定制后<code>wait</code>间隔后会执行一次</li>
</ol>
<h4 id="1-3-两种思路的区别"><a href="#1-3-两种思路的区别" class="headerlink" title="1.3 两种思路的区别"></a>1.3 两种思路的区别</h4><table>
<thead>
<tr>
<th></th>
<th>时间戳</th>
<th>定时器</th>
</tr>
</thead>
<tbody><tr>
<td>“起点”</td>
<td>立即执行</td>
<td>n 秒后执行</td>
</tr>
<tr>
<td>“终点”</td>
<td>停止后不会执行</td>
<td>停止会再执行一次</td>
</tr>
</tbody></table>
<h3 id="二、节流进阶"><a href="#二、节流进阶" class="headerlink" title="二、节流进阶"></a>二、节流进阶</h3><p>结合两种思想完成一个可以立即执行，且停止触发后再执行一次的节流方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第三版</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous &#x3D; 0;</span><br><span class="line">    var later &#x3D; function() &#123;</span><br><span class="line">        previous &#x3D; +new Date();</span><br><span class="line">        timeout &#x3D; null;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">    &#125;;</span><br><span class="line">    var throttled &#x3D; function() &#123;</span><br><span class="line">        var now &#x3D; +new Date();</span><br><span class="line">        &#x2F;&#x2F;下次触发 func 剩余的时间</span><br><span class="line">        var remaining &#x3D; wait - (now - previous);</span><br><span class="line">        context &#x3D; this;</span><br><span class="line">        args &#x3D; arguments;</span><br><span class="line">         &#x2F;&#x2F; 如果没有剩余的时间了或者你改了系统时间</span><br><span class="line">        if (remaining &lt;&#x3D; 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous &#x3D; now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">        &#125; else if (!timeout) &#123;</span><br><span class="line">            timeout &#x3D; setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果演示如下：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551783-4d2e4584-8e32-4ca2-a1de-c2ab865a882c.gif"></p>
<p>我在看代码的时候，我是反复打印数据才理解为什么会这样做，一起加油～</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>学习之AJAX</title>
    <url>/2019/03/20/%E5%AD%A6%E4%B9%A0%E4%B9%8BAJAX/</url>
    <content><![CDATA[<p>对于AJAX这个玩意儿，一开始学习的时候，根本不知道这是什么，我连AJAX有什么作用，是干什么的都不知道，所以在一开始学习这个的时候是非常蒙B的状态。那么在学习一段时间的AJAX之后，我总结了一些我自己对AJAX的理解，一起共勉。</p>
<p>一、页面访问方式</p>
<p>在学习AJAX之前，我们首先就需要了解页面的访问方式。页面的访问方式有如下两种同步访问和异步访问：</p>
<p>①同步访问：在访问服务器时，只能等待服务器的响应，不能做其他事情。</p>
<p>②异步访问：在向服务器发送请求时，不耽误用户在网页其他操作。相当于在同一时间，用户能做多个事情。</p>
<span id="more"></span>


<p>光从字面上理解同步和异步不算太难，下面我为用图打个比方有助于更加深层次的理解同步和异步：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20170730181503984"></p>
<p>上图反之是同步访问的图解，异步访问我就不再作图了，反之，你想买煎饼和稀饭，你走到卖煎饼的铺子时候，老板说：好的，你的煎饼5分钟后好，你可以5分钟后过来拿。这个时候你就可以在这五分钟去买你要的稀饭，这就是异步访问。</p>
<p>二、什么是AJAX</p>
<p>AJAX的英文全名是：Asynchronous  Javascript  And  Xml</p>
<p> 异步的  JS     和    xml</p>
<p> 其中的本质：使用JS中XMLHttpRequext(xhr)对象异步的向服务器发送请求，服务器响应回来的部分数据而不是原完整的页面，并可以以“无刷新”的效果来更改页面中的局部内容。为了方便理解，作以下用户名验证的例子图助于理解：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20170730183958321"></p>
<p>三、获取ＡＪＡＸ对象　——XMLHttpRequest</p>
<p>在主流浏览器中：new　XMLHttpRequest( );</p>
<p>注意：在IE8以下的浏览器不支持XMLHttpRequest</p>
<p>在IE8以下的浏览器中：</p>
<p>new  ActiveXObject(“Microsoft.XMLHttp”);</p>
<p>tip:如果想测试你使用的浏览器是否支持XMLHttpRequest，可以进行如下操作：</p>
<p>1.打开你的浏览器，例如谷歌、360、火狐、欧朋….;</p>
<p>2.按F12，使用开发者工具，在console一栏中输入：console.log(window.XMLHttpRequest);</p>
<p>3.如果浏览器不支持XMLHttpRequest,以上会打印null。</p>
<p>//创建ajax对象</p>
<p> var  xhr;</p>
<p>   if(window.XMLHttpRequest){</p>
<p>xhr = new  XMLHttpRequest();</p>
<p> }else{</p>
<p>xhr = new ActiveXObject(“Microsoft.XMLHttp”);</p>
<p>}</p>
<p>tip：这段函在编写代码的时候使用的次数很多，通常我们将它封装成函数单独创建一个JS文件，命名为common.js，要使用的时候调用者个js文件就可以了。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>开发小技巧</title>
    <url>/2020/05/01/%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="阻止单击事件冒泡"><a href="#阻止单击事件冒泡" class="headerlink" title="阻止单击事件冒泡"></a>阻止单击事件冒泡</h2><p><code>&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="提交事件不再重载页面"><a href="#提交事件不再重载页面" class="headerlink" title="提交事件不再重载页面"></a>提交事件不再重载页面</h2><p><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code></p>
<h2 id="修饰符可以串联"><a href="#修饰符可以串联" class="headerlink" title="修饰符可以串联"></a>修饰符可以串联</h2><p><code>&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;</code></p>
<span id="more"></span>


<h2 id="只有修饰符"><a href="#只有修饰符" class="headerlink" title="只有修饰符"></a>只有修饰符</h2><p><code>&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</code></p>
<br>
<br>
<br>

<h2 id="Mac谷歌跨域命令"><a href="#Mac谷歌跨域命令" class="headerlink" title="Mac谷歌跨域命令"></a>Mac谷歌跨域命令</h2><p><code>open -n /Applications/Google\ Chrome.app/ --args --disable-web-security  --user-data-dir=/Users/GaoYuan/Documents/MyChromeDevUserData</code></p>
<br>
<br>
<br>

<h2 id="Mac显示隐藏文件命令："><a href="#Mac显示隐藏文件命令：" class="headerlink" title="Mac显示隐藏文件命令："></a>Mac显示隐藏文件命令：</h2><p><strong>显示隐藏文件</strong></p>
<p><code>defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder </code></p>
<p><strong>不显示隐藏文件</strong></p>
<p><code>defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder </code></p>
<br>
<br>

<h2 id="Jison解决JS处理后端返回的Long型数据精度丢失问题"><a href="#Jison解决JS处理后端返回的Long型数据精度丢失问题" class="headerlink" title="Jison解决JS处理后端返回的Long型数据精度丢失问题"></a>Jison解决JS处理后端返回的Long型数据精度丢失问题</h2><p>原因：js是弱类型语言，所有的数字类型统称为Number类型，不区分int、long、double等。</p>
<p><code>git clone git://github.com/zaach/jsonlint.git</code></p>
<p>在src目录下提供了jsonlint.y（grammaFile）和jsonlint.l（lexFile)两个文件。使用这两个文件可以直接生成jsonlint.js。如下修改jsonlint.y：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSONNumber</span><br><span class="line"></span><br><span class="line">    : NUMBER</span><br><span class="line">    </span><br><span class="line">        &#123;$$ &#x3D; yytext &#x3D;&#x3D; String(Number(yytext))? Number(yytext): yytext;&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p> 然后：</p>
<p><code>cd src</code></p>
<p><code>jison jsonlint.y jsonlint.l</code></p>
<h3 id="最后引入至项目"><a href="#最后引入至项目" class="headerlink" title="最后引入至项目"></a>最后引入至项目</h3><p>1.将自定义的 jsonlint.js 放到 static 目录下<br>2.在 index.html 中引入<br><code>&lt;script src=&quot;./static/jsonlint/jsonlint.js&quot;&gt;&lt;/script&gt;</code></p>
<p>3、在我们请求的返回数据中，做一层拦截转换，此处以 axios 的实现方法为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*transformResponse 选项允许我们在数据传送到 &#96;then&#x2F;catch&#96; 方法之前对数据进行改动*&#x2F;</span><br><span class="line">axios.defaults.transformResponse &#x3D; [</span><br><span class="line">  function(data) &#123;</span><br><span class="line">    return jsonlint.parse(data)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>综上，定义JSON转化避免long类型数据溢出，可以实现long类型数据在前端正常显示</p>
<h2 id="Mac给文件夹赋予管理员权限"><a href="#Mac给文件夹赋予管理员权限" class="headerlink" title="Mac给文件夹赋予管理员权限"></a>Mac给文件夹赋予管理员权限</h2><p><code>sudo chown -R gaoyuan ios</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ($request_filename ~* .*index\.html$) &#123;</span><br><span class="line">     add_header Cache-Control &quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>个人笔记</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>用CSS3使你的网页动起来——transform属性</title>
    <url>/2017/08/11/%E7%94%A8CSS3%E4%BD%BF%E4%BD%A0%E7%9A%84%E7%BD%91%E9%A1%B5%E5%8A%A8%E8%B5%B7%E6%9D%A5%E2%80%94%E2%80%94transform%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p><strong>转换</strong></p>
<ol>
<li><p>什么是转换</p>
<pre><code> 改变元素在页面上的大小，位置，形状以及角度的一种方式
 可以向元素应用2D以及3D的转换效果
</code></pre>
</li>
<li><p>转换属性</p>
<pre><code>    (1)转换效果
            属性：transform
            取值：1.none：默认值，即没有任何转换效果
                 2.一个或多个转换函数，如果是多个转换函数，中间用&quot;空格隔开&quot;
    (2)转换的原点
            属性：transform-origin
            取值：
                1.两个值：表示原点在x轴和y轴的位置 
                2.三个值：表示原点在x轴，y轴和z轴的位置
                         可以取数值/百分比/关键字
             
</code></pre>
</li>
</ol>
<p><strong>2D转换</strong></p>
<ol start="3">
<li>位移：改变元素在页面上的位置<br> 属性：transform<br> 取值：<br> 1.translate(x)：x取值为正，向右移动；x取值为负，向左移动<br> 2.translate(x,y)：x同上；y取值为正，下移；y取值为负，向下移动<br> 3.translateX(x)<br> 4.translateY(y)</li>
</ol>
<span id="more"></span>

<ol>
<li>缩放<br>属性：transform<br>取值：<br>1、scale(value)：value表示的是x轴和y轴的缩放倍率<pre><code>                      2、scale(x,y)
                      3、scaleX(x)
                      4、scaleY(y)
</code></pre>
注：x，y的取值   默认为1；放大：大于1的数值；缩小：0-1之间的数字</li>
<li>旋转：改变元素在页面上的角度<pre><code>          属性：transform
          取值：rotate(ndeg)
</code></pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值为正，顺时针旋转<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n取值为负，逆时针旋转<pre><code>          注意： 1、转换原点你会影响旋转效果
                     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、旋转操作时，连同坐标轴一同都跟着转
</code></pre>
</li>
<li>倾斜：改变    元素在页面中的形状<br>属性：transform<br>取值：1、skewX(ndeg)    让元素向横向倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n取值为正，y轴逆时针倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n取值为负，y轴顺时针倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、skewY(ndeg)    让元素向纵向倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n取值为正，x轴顺时针倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n取值为负，x轴逆时针倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、skew(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、skew(x，y)</li>
</ol>
<p><strong>3D转换</strong></p>
<ol>
<li>属性：perspective<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：模拟 人眼睛 到3D转换物体的距离，取值越大，表示离物体越远，取值越小，表示离物体越近<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：以px为单位的数值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：该属性要加在3D转换元素的父元素上</li>
<li>3D旋转<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性：transform<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：rotateX(xdeg)：以x轴为中心轴，旋转元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotateY(ydeg)：以y轴为中心轴，旋转元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotateZ(zdeg)：以z轴为中心轴，旋转元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotate3D(x,y,z,ndeg)：x,y,z取值大于0的话，则该轴参与旋转；x,y,z取值为0的话，则该轴不参与旋转</li>
</ol>
<p><strong>过渡</strong></p>
<ol>
<li>什么是过渡<pre><code>        使得CSS的属性值在一段时间内平缓变化的效果
        过渡能观察到元素的属性值得变化过程
</code></pre>
</li>
<li>过渡四要素（四属性）<br>(1)指定过渡属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：指定那个CSS属性值在变化时需要使用过渡的效果。当指定属性值发生变化时，过渡就会被触发<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语法：transition-property<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值： 1.属性名称<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.none：默认值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.all<br>允许设置过渡的属性：1、颜色属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、取值为数字的属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、转换属性-transform<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、渐变属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、visibility<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、阴影属性<br>(2)指定过渡时长:过渡的效果要在多长时间内完成<br>&nbsp;&nbsp;&nbsp;&nbsp;属性：transition-duration<br>&nbsp;&nbsp;&nbsp;&nbsp;取值：以s或ms为单位的数值<br>&nbsp;&nbsp;&nbsp;&nbsp;默认值为0，意味着不会有过渡效果<br>(3)指定过渡的速度时间曲线函数<pre><code>                属性：transition-timing-function
                取值：
</code></pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、ease  默认值，慢速开始，快速变快，慢速结束<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、linear  匀速<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、ease-in  慢速开始，加速结束<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、ease-out    快速开始，减速结束<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、ease-in-out  慢速开始和结束，中间先加后减<br>(4)指定过渡延迟:当用户激发操作后等待多长时间再显示效果<br>&nbsp;&nbsp;&nbsp;&nbsp;属性：transition-delay<br>&nbsp;&nbsp;&nbsp;&nbsp;取值：以s或ms为单位的数值</li>
</ol>
<p><strong>动画</strong><br>1、什么是动画<br>动画指使元素从一种样式逐渐变化为另一种样式的过程<br>动画是复杂版的过渡效果<br>本质：使用”关键帧”，来定义动画的每一步<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关键帧：包含 运行的时间点以及动作(样式)<br>2、动画的使用步骤<br>(1)声明动画<br>&nbsp;&nbsp;&nbsp;&nbsp;指定动画名称以及涉及到的关键帧们<br>(2)为元素调用动画<br>&nbsp;&nbsp;&nbsp;&nbsp;指定元素使用哪个动画效果<br>3、声明动画<br>&nbsp;&nbsp;&nbsp;&nbsp;样式表中，通过 @keyframes 规则来声明动画</p>
<pre><code>            @keyframes 动画名称&#123;
                    0%&#123;
                        /*动画开始时，元素的样式*/
                        属性：值;
                        属性：值;
                    &#125;
                    50%&#123;
                        /*动画执行到一半时，元素的样式*/
                    &#125;
                    100%&#123;
                        /*动画结束时，元素的样式*/
                    &#125;
            &#125;
</code></pre>
<p>动画声明的浏览器兼容性：<br>&nbsp;&nbsp;&nbsp;&nbsp;@-moz-keyframes动画名{ … }<br>&nbsp;&nbsp;&nbsp;&nbsp;@-webkit-keyframes动画名{ … }<br>&nbsp;&nbsp;&nbsp;&nbsp;@-o-keyframes动画名{ … }<br>4、调用动画<br>&nbsp;&nbsp;&nbsp;&nbsp;(1)animation-name：要调用的动画名称<br>&nbsp;&nbsp;&nbsp;&nbsp;(2)animation-duration：动画完成一个周期需要的时长<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：以s或ms为单位的数值<br>&nbsp;&nbsp;&nbsp;&nbsp;(3)animation-timing-function：指定动画的速度时间曲线函数<br>                        取值：ease、linear、ease-in，ease-out、ease-in-out<br>&nbsp;&nbsp;&nbsp;&nbsp;(4)animation-delay：指定动画的播放延迟<br>&nbsp;&nbsp;&nbsp;&nbsp;(5)animation-iteration-count：指定动画的播放次数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：1.默认值为1，只播放一次<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.自定义数值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.infinite，表示无限次播放<br>&nbsp;&nbsp;&nbsp;&nbsp;(6)animation-direction：指定动画的播放方向<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值： 1、normal：正向播放，从0%<del>100%<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、reverse：逆向播放，从100%</del>0%<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、alternate：轮流播放，基数次数播放时，正向播放，偶数次数播放时，逆向播<br>&nbsp;&nbsp;&nbsp;&nbsp;(7)animation-flill-mode(不属于简写里)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：动画的填充模式，指动画在播放之前或播放之后的显示效果<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：none  默认值，无任何效果<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forwards  当动画播放完成之后，元素将保持在最后一个帧的状态上<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backwards   动画播放前，在延迟时间内，动画将保持在第一帧的状态上<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;both   动画播放前后，分别应用在第一帧和最后一帧的状态上<br>&nbsp;&nbsp;&nbsp;&nbsp;(8)animation-play-state<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：指定动画处于 播放状态 还是 暂停状态<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：  paused     动画暂停<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running    动画播放</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
