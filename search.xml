<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTPS和HTTP原理和区别</title>
    <url>/2021/03/18/HTTPS%E5%92%8CHTTP%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>一、HTTP 和 HTTPS 的基本概念<br>HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。</p>
<p>HTTP 原理：</p>
<p>①  客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。</p>
<p>②  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p>
<p>HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p>​​<img data-src="https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70">                                    </p>
<span id="more"></span>

<p>HTTPS 设计目标：</p>
<p>(1) 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。</p>
<p>(2) 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。</p>
<p>(3) 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。</p>
<p>二、HTTP 与 HTTPS  的区别<br>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p>
<p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p>
<p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
<p>三、HTTPS 相对于 HTTP 的改进<br>双向的身份认证</p>
<p>客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证 。具体过程如下：</p>
<p>客户端发起 SSL 握手消息给服务端要求连接。</p>
<p>服务端将证书发送给客户端。</p>
<p>客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。</p>
<p>服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。</p>
<p>注意：</p>
<p>(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。</p>
<p>(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p>
<p>(3) 客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p>
<p>数据传输的机密性</p>
<p>客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA)，数据签名摘要算法 ( 一般是SHA或者MD5) ，加密传输数据的对称加密算法 ( 一般是DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。</p>
<p>防止重放攻击</p>
<p>SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</p>
<p>可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。</p>
<p>四、HTTPS 的优点<br>1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</p>
<p>2、HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</p>
<p>3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<p>五、HTTPS 的缺点（对比优点）<br>1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。</p>
<p>2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</p>
<p>3、HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</p>
<p>4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</p>
<p>5、成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</p>
<p>6、HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</p>
<p>六、HTTPS 的连接过程</p>
<p>​​<img data-src="https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>图片中的过程是按 8 个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。</p>
<p>① 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p>
<p>② 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p>
<p>③ 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 “发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</p>
<p>④ 用户端随机产生一个用于通讯的 “对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</p>
<p>⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。</p>
<p>⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA  是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p>
<p>⑦ 服务器和客户端用相同的对称加密密钥，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p>
<p>⑧ 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p>
<p>⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p>
<p>⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p>
<p>上述的过程需要弄懂的核心思想<br>客户端解析证书</p>
<p>这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个对称加密密钥，然后用公钥对该密钥进行非对称加密。</p>
<p>传送加密信息</p>
<p>这部分传送的是用公钥加密后的对称加密密钥，目的就是让服务端得到这个密钥，以后客户端和服务端的通信就可以通过这个密钥来进行加密解密了。</p>
<p>服务端解密信息</p>
<p>服务端用非对称加密算法里的私钥解密后，得到了客户端传过来的对称加密算法的私钥，然后把之后传输的内容通过该值进行对称加密。</p>
<p>为什么用非对称加密协商对称加密密钥</p>
<p>对称加密的特点：对称密码体制中只有一种密钥，并且是非公开的。如果要解密就得让对方知道密钥，所以想要保证其安全性就要保证密钥的安全。</p>
<p>非对称加密的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了，这样安全性就大了很多。</p>
<p>非对称加密公钥和私钥的使用方法：(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。</p>
<p>补充：<br>SSL 提供服务<br>(1) 认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>(2) 加密数据以防止数据中途被窃取；</p>
<p>(3) 维护数据的完整性，确保数据在传输过程中不被改变。</p>
<p>SSL 工作流程<br>服务器认证阶段：</p>
<p>(1) 客户端向服务器发送一个开始信息 “Hello” 以便开始一个新的会话连接；</p>
<p>(2) 服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的 “Hello” 信息时将包含生成主密钥所需的信息；</p>
<p>(3) 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</p>
<p>(4) 服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p>
<p>用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p>
<p>SSL 协议提供的安全通道有以下三个特性：</p>
<p>机密性：SSL 协议使用密钥加密通信数据。</p>
<p>可靠性：服务器和客户都会被认证，客户的认证是可选的。</p>
<p>完整性：SSL 协议会对传送的数据进行完整性检查。</p>
<p>服务器证书(server certificates)是 SSL 数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成 Web 服务器的 SSL 安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户提供验证您 Web 站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex笔记</title>
    <url>/2021/03/16/vuex%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Vuex笔记"><a href="#Vuex笔记" class="headerlink" title="Vuex笔记"></a>Vuex笔记</h1><h3 id="Vuex概述"><a href="#Vuex概述" class="headerlink" title="Vuex概述"></a>Vuex概述</h3><h4 id="vuex是什么"><a href="#vuex是什么" class="headerlink" title="vuex是什么"></a>vuex是什么</h4><p>​    vuex是实现组件全局状态（数据）管理的一种机制，可以方便实现组件之间数据的共享<br><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/image-20201221091304337.png"></p>
<span id="more"></span>

<h4 id="使用Vuex统一管理状态的好处"><a href="#使用Vuex统一管理状态的好处" class="headerlink" title="使用Vuex统一管理状态的好处"></a>使用Vuex统一管理状态的好处</h4><ul>
<li>能够在vuex中集中管理共享的数据，易于开发和后期维护</li>
<li>能够高效地实现组件之间的数据共享，提高开发效率</li>
<li>存储在Vuex中的数据都是响应式的，能够实施保持数据与页面的同步</li>
</ul>
<h4 id="什么样的数据适合存储到Vuex中"><a href="#什么样的数据适合存储到Vuex中" class="headerlink" title="什么样的数据适合存储到Vuex中"></a>什么样的数据适合存储到Vuex中</h4><p>​    一般情况下，只有组件之间共享的数据，才有必要存储到vuex中；对于组件中的私有数据，依旧存储在组件自身的data中即可</p>
<h3 id="vuex的基本使用"><a href="#vuex的基本使用" class="headerlink" title="vuex的基本使用"></a>vuex的基本使用</h3><h4 id="安装vuex依赖"><a href="#安装vuex依赖" class="headerlink" title="安装vuex依赖"></a>安装vuex依赖</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">npm</span> install vex --save</span><br></pre></td></tr></table></figure>

<h4 id="导入vuex包"><a href="#导入vuex包" class="headerlink" title="导入vuex包"></a>导入vuex包</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>

<h4 id="创建store对象"><a href="#创建store对象" class="headerlink" title="创建store对象"></a>创建store对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">  <span class="comment">// state中存放的就是全局共享的数据</span></span><br><span class="line">  state: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="将store对象挂载到vue实例中"><a href="#将store对象挂载到vue实例中" class="headerlink" title="将store对象挂载到vue实例中"></a>将store对象挂载到vue实例中</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  reader: <span class="function"><span class="params">h</span> =&gt;</span> h(app),</span><br><span class="line">  router,</span><br><span class="line">  <span class="comment">// 将创建的共享数据对象，挂载到vue实例中</span></span><br><span class="line">  <span class="comment">// 所有的组件，就可以直接从store中获取全局的数据了</span></span><br><span class="line">  store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="核心概念概述"><a href="#核心概念概述" class="headerlink" title="核心概念概述"></a>核心概念概述</h3><blockquote>
<p>vuex中的主要核心概念如下：</p>
<ul>
<li><strong>state</strong></li>
<li><strong>Mutation</strong></li>
<li><strong>Action</strong></li>
<li><strong>Getter</strong></li>
</ul>
</blockquote>
<h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>​    State提供唯一的公共数据源，所有的共享的数据都要统一放到Store的State中进行储存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建store数据源，提供唯一公共数据</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（1）组件访问State中数据的第一种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.全局数据名称</span><br></pre></td></tr></table></figure>

<p>（2）组件访问State中数据的第二种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从vuex中按需导入 mapState函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过刚刚导入的mapState函数，将当前组件需要的全局数据，映射为当前数据的computed计算属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.将全局数据，映射为当前组件的计算属性</span></span><br><span class="line">computed: &#123;</span><br><span class="line">	...mapState([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>Mutation用于变更Store中的数据</p>
<ol>
<li><p>只能通过mutation变更Store数据，不可以直接操作Store中的数据</p>
</li>
<li><p>通过这种方式虽然操作起来稍微繁琐一些，但是可以集中件套所有数据的变化</p>
</li>
</ol>
<h5 id="定义mutations"><a href="#定义mutations" class="headerlink" title="定义mutations"></a>定义mutations</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Mutation</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">	state: &#123;</span><br><span class="line">		count: <span class="number">0</span></span><br><span class="line">	&#125;,</span><br><span class="line">	mutations: &#123;</span><br><span class="line">		<span class="function"><span class="title">add</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//变更状态</span></span><br><span class="line">			state.count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="触发mutations"><a href="#触发mutations" class="headerlink" title="触发mutations"></a>触发mutations</h5><p>（1）触发mutations的第一种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发mutation</span></span><br><span class="line">methods: &#123;</span><br><span class="line">	<span class="function"><span class="title">handle1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//	触发mutation的第一种方式</span></span><br><span class="line">		<span class="built_in">this</span>.$store.commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在触发mutations时传递参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Mutation</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">	state: &#123;</span><br><span class="line">		count: <span class="number">0</span></span><br><span class="line">	&#125;,</span><br><span class="line">	mutations: &#123;</span><br><span class="line">		<span class="function"><span class="title">addN</span>(<span class="params">state, step</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//变更状态</span></span><br><span class="line">			state.count += step</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发mutation</span></span><br><span class="line">methods: &#123;</span><br><span class="line">	<span class="function"><span class="title">handle1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//	触发mutation的第一种方式</span></span><br><span class="line">		<span class="built_in">this</span>.$store.commit(<span class="string">&#x27;addN&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）触发mutations第二种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从vuex中按需导入mapMutations函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过刚才导入的mapMuntations函数，将需要的mutations函数，映射为当前组件的methods方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.将指定的mutations函数，映射为当前组件的methods函数</span></span><br><span class="line">methods: &#123;</span><br><span class="line">	...mapMutations([<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;addN&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><blockquote>
<p>Action用于处理异步任务</p>
</blockquote>
<p>如果通过异步操作变更数据，必须通过Action，而不能使用Mutation，但是在Action中还是要通过出发Mutation的方式间接变更数据。</p>
<h5 id="定义Action"><a href="#定义Action" class="headerlink" title="定义Action"></a>定义Action</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Action</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  	<span class="comment">// ...此处省略其他代码</span></span><br><span class="line">  mutaions: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">			state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">addAsync</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="触发Action"><a href="#触发Action" class="headerlink" title="触发Action"></a>触发Action</h5><p>（1）触发actions的第一种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">	<span class="function"><span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 触发actions的第一种方式</span></span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addAsync&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发actions异步任务时携带参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Action</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  	<span class="comment">// ...此处省略其他代码</span></span><br><span class="line">  mutaions: &#123;</span><br><span class="line">    <span class="function"><span class="title">addN</span>(<span class="params">state,step</span>)</span>&#123;</span><br><span class="line">			state.count += step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">addNAsync</span>(<span class="params">context, step</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;addN&#x27;</span>,step)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发actions</span></span><br><span class="line">methods:&#123;</span><br><span class="line">	<span class="function"><span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addAsync&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）触发actions的第二种方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.从vuex中按需导入mapActions函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过刚才导入的mapActions函数，映射为当前组件的methods函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">	...mapAction([&#39;addAsync&#39;,&#39;addNASync&#39;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h4><p>Getter用于对store中的数据进行加工处理形成新的数据</p>
<ul>
<li><p>Getter可以对Store中已有的数据加工处理之后形成新的数据，类似Vue的计算属性</p>
</li>
<li><p>Store中数据发生变化，Getter的数据也会跟着变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Getter</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    showNum: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`当前最新的数据时【 <span class="subst">$&#123;state.count&#125;</span> 】`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用Getter的第一种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.getters.名称</span><br></pre></td></tr></table></figure>

<p>使用Getter的第二种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters([<span class="string">&#x27;showNum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>开发小技巧</title>
    <url>/2021/03/16/%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="阻止单击事件冒泡"><a href="#阻止单击事件冒泡" class="headerlink" title="阻止单击事件冒泡"></a>阻止单击事件冒泡</h2><p><code>&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</code></p>
<h2 id="提交事件不再重载页面"><a href="#提交事件不再重载页面" class="headerlink" title="提交事件不再重载页面"></a>提交事件不再重载页面</h2><p><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code></p>
<h2 id="修饰符可以串联"><a href="#修饰符可以串联" class="headerlink" title="修饰符可以串联"></a>修饰符可以串联</h2><p><code>&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;</code></p>
<span id="more"></span>


<h2 id="只有修饰符"><a href="#只有修饰符" class="headerlink" title="只有修饰符"></a>只有修饰符</h2><p><code>&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</code></p>
<br>
<br>
<br>

<h2 id="Mac谷歌跨域命令"><a href="#Mac谷歌跨域命令" class="headerlink" title="Mac谷歌跨域命令"></a>Mac谷歌跨域命令</h2><p><code>open -n /Applications/Google\ Chrome.app/ --args --disable-web-security  --user-data-dir=/Users/GaoYuan/Documents/MyChromeDevUserData</code></p>
<br>
<br>
<br>

<h2 id="Mac显示隐藏文件命令："><a href="#Mac显示隐藏文件命令：" class="headerlink" title="Mac显示隐藏文件命令："></a>Mac显示隐藏文件命令：</h2><p><strong>显示隐藏文件</strong></p>
<p><code>defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder </code></p>
<p><strong>不显示隐藏文件</strong></p>
<p><code>defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder </code></p>
<br>
<br>

<h2 id="Jison解决JS处理后端返回的Long型数据精度丢失问题"><a href="#Jison解决JS处理后端返回的Long型数据精度丢失问题" class="headerlink" title="Jison解决JS处理后端返回的Long型数据精度丢失问题"></a>Jison解决JS处理后端返回的Long型数据精度丢失问题</h2><p>原因：js是弱类型语言，所有的数字类型统称为Number类型，不区分int、long、double等。</p>
<p><code>git clone git://github.com/zaach/jsonlint.git</code></p>
<p>在src目录下提供了jsonlint.y（grammaFile）和jsonlint.l（lexFile)两个文件。使用这两个文件可以直接生成jsonlint.js。如下修改jsonlint.y：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSONNumber</span><br><span class="line"></span><br><span class="line">    : NUMBER</span><br><span class="line">    </span><br><span class="line">        &#123;$$ &#x3D; yytext &#x3D;&#x3D; String(Number(yytext))? Number(yytext): yytext;&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p> 然后：</p>
<p><code>cd src</code></p>
<p><code>jison jsonlint.y jsonlint.l</code></p>
<h3 id="最后引入至项目"><a href="#最后引入至项目" class="headerlink" title="最后引入至项目"></a>最后引入至项目</h3><p>1.将自定义的 jsonlint.js 放到 static 目录下<br>2.在 index.html 中引入<br><code>&lt;script src=&quot;./static/jsonlint/jsonlint.js&quot;&gt;&lt;/script&gt;</code></p>
<p>3、在我们请求的返回数据中，做一层拦截转换，此处以 axios 的实现方法为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*transformResponse 选项允许我们在数据传送到 &#96;then&#x2F;catch&#96; 方法之前对数据进行改动*&#x2F;</span><br><span class="line">axios.defaults.transformResponse &#x3D; [</span><br><span class="line">  function(data) &#123;</span><br><span class="line">    return jsonlint.parse(data)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>综上，定义JSON转化避免long类型数据溢出，可以实现long类型数据在前端正常显示</p>
<h2 id="Mac给文件夹赋予管理员权限"><a href="#Mac给文件夹赋予管理员权限" class="headerlink" title="Mac给文件夹赋予管理员权限"></a>Mac给文件夹赋予管理员权限</h2><p><code>sudo chown -R gaoyuan ios</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ($request_filename ~* .*index\.html$) &#123;</span><br><span class="line">     add_header Cache-Control &quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>个人笔记</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>用CSS3使你的网页动起来——transform属性</title>
    <url>/2021/03/18/%E7%94%A8CSS3%E4%BD%BF%E4%BD%A0%E7%9A%84%E7%BD%91%E9%A1%B5%E5%8A%A8%E8%B5%B7%E6%9D%A5%E2%80%94%E2%80%94transform%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p><strong>转换</strong></p>
<ol>
<li><p>什么是转换</p>
<pre><code> 改变元素在页面上的大小，位置，形状以及角度的一种方式
 可以向元素应用2D以及3D的转换效果
</code></pre>
</li>
<li><p>转换属性</p>
<pre><code>    (1)转换效果
            属性：transform
            取值：1.none：默认值，即没有任何转换效果
                 2.一个或多个转换函数，如果是多个转换函数，中间用&quot;空格隔开&quot;
    (2)转换的原点
            属性：transform-origin
            取值：
                1.两个值：表示原点在x轴和y轴的位置 
                2.三个值：表示原点在x轴，y轴和z轴的位置
                         可以取数值/百分比/关键字
             
</code></pre>
</li>
</ol>
<p><strong>2D转换</strong></p>
<ol start="3">
<li>位移：改变元素在页面上的位置<br> 属性：transform<br> 取值：<br> 1.translate(x)：x取值为正，向右移动；x取值为负，向左移动<br> 2.translate(x,y)：x同上；y取值为正，下移；y取值为负，向下移动<br> 3.translateX(x)<br> 4.translateY(y)</li>
</ol>
<span id="more"></span>

<ol>
<li>缩放<br>属性：transform<br>取值：<br>1、scale(value)：value表示的是x轴和y轴的缩放倍率<pre><code>                      2、scale(x,y)
                      3、scaleX(x)
                      4、scaleY(y)
</code></pre>
注：x，y的取值   默认为1；放大：大于1的数值；缩小：0-1之间的数字</li>
<li>旋转：改变元素在页面上的角度<pre><code>          属性：transform
          取值：rotate(ndeg)
</code></pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值为正，顺时针旋转<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n取值为负，逆时针旋转<pre><code>          注意： 1、转换原点你会影响旋转效果
                     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、旋转操作时，连同坐标轴一同都跟着转
</code></pre>
</li>
<li>倾斜：改变    元素在页面中的形状<br>属性：transform<br>取值：1、skewX(ndeg)    让元素向横向倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n取值为正，y轴逆时针倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n取值为负，y轴顺时针倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、skewY(ndeg)    让元素向纵向倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n取值为正，x轴顺时针倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n取值为负，x轴逆时针倾斜<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、skew(x)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、skew(x，y)</li>
</ol>
<p><strong>3D转换</strong></p>
<ol>
<li>属性：perspective<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：模拟 人眼睛 到3D转换物体的距离，取值越大，表示离物体越远，取值越小，表示离物体越近<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：以px为单位的数值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：该属性要加在3D转换元素的父元素上</li>
<li>3D旋转<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性：transform<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：rotateX(xdeg)：以x轴为中心轴，旋转元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotateY(ydeg)：以y轴为中心轴，旋转元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotateZ(zdeg)：以z轴为中心轴，旋转元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rotate3D(x,y,z,ndeg)：x,y,z取值大于0的话，则该轴参与旋转；x,y,z取值为0的话，则该轴不参与旋转</li>
</ol>
<p><strong>过渡</strong></p>
<ol>
<li>什么是过渡<pre><code>        使得CSS的属性值在一段时间内平缓变化的效果
        过渡能观察到元素的属性值得变化过程
</code></pre>
</li>
<li>过渡四要素（四属性）<br>(1)指定过渡属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：指定那个CSS属性值在变化时需要使用过渡的效果。当指定属性值发生变化时，过渡就会被触发<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语法：transition-property<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值： 1.属性名称<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.none：默认值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.all<br>允许设置过渡的属性：1、颜色属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、取值为数字的属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、转换属性-transform<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、渐变属性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、visibility<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、阴影属性<br>(2)指定过渡时长:过渡的效果要在多长时间内完成<br>&nbsp;&nbsp;&nbsp;&nbsp;属性：transition-duration<br>&nbsp;&nbsp;&nbsp;&nbsp;取值：以s或ms为单位的数值<br>&nbsp;&nbsp;&nbsp;&nbsp;默认值为0，意味着不会有过渡效果<br>(3)指定过渡的速度时间曲线函数<pre><code>                属性：transition-timing-function
                取值：
</code></pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、ease  默认值，慢速开始，快速变快，慢速结束<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、linear  匀速<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、ease-in  慢速开始，加速结束<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、ease-out    快速开始，减速结束<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、ease-in-out  慢速开始和结束，中间先加后减<br>(4)指定过渡延迟:当用户激发操作后等待多长时间再显示效果<br>&nbsp;&nbsp;&nbsp;&nbsp;属性：transition-delay<br>&nbsp;&nbsp;&nbsp;&nbsp;取值：以s或ms为单位的数值</li>
</ol>
<p><strong>动画</strong><br>1、什么是动画<br>动画指使元素从一种样式逐渐变化为另一种样式的过程<br>动画是复杂版的过渡效果<br>本质：使用”关键帧”，来定义动画的每一步<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关键帧：包含 运行的时间点以及动作(样式)<br>2、动画的使用步骤<br>(1)声明动画<br>&nbsp;&nbsp;&nbsp;&nbsp;指定动画名称以及涉及到的关键帧们<br>(2)为元素调用动画<br>&nbsp;&nbsp;&nbsp;&nbsp;指定元素使用哪个动画效果<br>3、声明动画<br>&nbsp;&nbsp;&nbsp;&nbsp;样式表中，通过 @keyframes 规则来声明动画</p>
<pre><code>            @keyframes 动画名称&#123;
                    0%&#123;
                        /*动画开始时，元素的样式*/
                        属性：值;
                        属性：值;
                    &#125;
                    50%&#123;
                        /*动画执行到一半时，元素的样式*/
                    &#125;
                    100%&#123;
                        /*动画结束时，元素的样式*/
                    &#125;
            &#125;
</code></pre>
<p>动画声明的浏览器兼容性：<br>&nbsp;&nbsp;&nbsp;&nbsp;@-moz-keyframes动画名{ … }<br>&nbsp;&nbsp;&nbsp;&nbsp;@-webkit-keyframes动画名{ … }<br>&nbsp;&nbsp;&nbsp;&nbsp;@-o-keyframes动画名{ … }<br>4、调用动画<br>&nbsp;&nbsp;&nbsp;&nbsp;(1)animation-name：要调用的动画名称<br>&nbsp;&nbsp;&nbsp;&nbsp;(2)animation-duration：动画完成一个周期需要的时长<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：以s或ms为单位的数值<br>&nbsp;&nbsp;&nbsp;&nbsp;(3)animation-timing-function：指定动画的速度时间曲线函数<br>                        取值：ease、linear、ease-in，ease-out、ease-in-out<br>&nbsp;&nbsp;&nbsp;&nbsp;(4)animation-delay：指定动画的播放延迟<br>&nbsp;&nbsp;&nbsp;&nbsp;(5)animation-iteration-count：指定动画的播放次数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：1.默认值为1，只播放一次<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.自定义数值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.infinite，表示无限次播放<br>&nbsp;&nbsp;&nbsp;&nbsp;(6)animation-direction：指定动画的播放方向<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值： 1、normal：正向播放，从0%<del>100%<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、reverse：逆向播放，从100%</del>0%<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、alternate：轮流播放，基数次数播放时，正向播放，偶数次数播放时，逆向播<br>&nbsp;&nbsp;&nbsp;&nbsp;(7)animation-flill-mode(不属于简写里)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：动画的填充模式，指动画在播放之前或播放之后的显示效果<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：none  默认值，无任何效果<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forwards  当动画播放完成之后，元素将保持在最后一个帧的状态上<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backwards   动画播放前，在延迟时间内，动画将保持在第一帧的状态上<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;both   动画播放前后，分别应用在第一帧和最后一帧的状态上<br>&nbsp;&nbsp;&nbsp;&nbsp;(8)animation-play-state<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：指定动画处于 播放状态 还是 暂停状态<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值：  paused     动画暂停<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running    动画播放</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hbuilder快速打包一个app</title>
    <url>/2021/03/18/%E4%BD%BF%E7%94%A8Hbuilder%E5%BF%AB%E9%80%9F%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AAapp/</url>
    <content><![CDATA[<p>HBuilder提供的打包有云端打包和本地打包两种，云端打包的特点是DCloud官方配置好了原生的打包环境，可以把HTML等文件编译为原生安装包。</p>
<p>优点：速度快，所需要的环境少，加快了开发者速度，不会因为各种JDK，java，Android环境而无法打包生成apk或ipa头疼，大大减少了开发繁琐操作。</p>
<p>方法步骤：</p>
<span id="more"></span>

<p>1.下载HBuilder，注册并登陆。首先打开“文件”-“新建”-“移动APP”，输入“应用名称”，“位置”可以根据需要自己选择即可，“选择模板”建议选择空模板，如下图所示：</p>
<p>​​<img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712163802432"></p>
<p>2.新建完成后， 在项目管理器会显示新建的项目目录，其中css，img，js和index.html这几个文件可删可改可替换。<br>unpackage文件夹是放置app图标和启动界面的图片。</p>
<p>manifest.json文件是移动App的配置文件，用于指定应用的显示名称、图标、应用入口文件地址及需要使用的设备权限等信息，用户可通过HBuilder的可视化界面视图或者源码视图来配置移动App的信息，如下图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712164108624"></p>
<p>3.如果删除了css，img，js文件夹和index.html文件，就把其他自己打包好的的项目文件对应复制到文件夹中，注意html文件中的引用路径需要保持正确，如下图自己拷贝的项目（我的是项目打包后的build文件和index.html文件，其中css/js/img都在build文件夹下）：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712164250660"></p>
<p>4.文件复制完成后，刷新更新下，双击打开manifest.json文件来配置App。</p>
<p>appid：点击云端获取。版本号：根据需要来编辑。页面入口：默认是index.html，根据自己项目需要，更改APP的启动页面。应用描述：自己随便填。应用是否全屏显示：勾上就全屏显示，如下图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712164915305"></p>
<p>5.图标配置：点击页面下方的图标配置，配置APP显示图标。</p>
<p>点击”+”号的正方形方框，选择图标素材的路径找到图标素材，再点击” 自动生成所有图标并替换”按钮，完成图标生成和替换，如下图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712165506582"></p>
<p>生成的图标自动在unpackage文件夹下，如下图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712165618254"></p>
<p>6.在启动图片设置里点击”选择”，找到刚放进来的启动图片，如下图所示：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712165842174"></p>
<p>7.SDK配置：有需要就配置，没有就默认就行。</p>
<p>   模块权限配置：有需要就配置，没有就默认就行。</p>
<p>8.云端打包：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712170045185"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712170127683"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712170219731"></p>
<p>然后等待几分钟，刷新状态，就可以看到制作完成，是否下载？点击下载。然后将apk发送到手机上安装就可以正常运行了！</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180712171021649"></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/2018071217113978"></p>
<p>以下是apk安装后再模拟器上运行效果：</p>
<p><img data-src="https://img-blog.csdn.net/20180712171240702?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDE1NTQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p><img data-src="https://img-blog.csdn.net/20180712171322289?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDE1NTQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p><img data-src="https://img-blog.csdn.net/20180712171518460?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDE1NTQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
]]></content>
      <categories>
        <category>Hbuilder</category>
      </categories>
      <tags>
        <tag>Hbuilder</tag>
      </tags>
  </entry>
</search>
