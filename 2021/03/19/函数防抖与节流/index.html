<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="BmblXLTbEG0oadNT7kCQo-kj5Dt_izzFLYV5KTcssDk"><meta name="msvalidate.01" content="89E58D35F116EFB128D266136B6C2871"><meta name="baidu-site-verification" content="code-do8zfrpF7M"><link rel="alternate" type="application/rss+xml" title="浅岛夏风" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="浅岛夏风" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="浅岛夏风" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="javascript"><link rel="canonical" href="http://example.com/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"><title>函数防抖与节流 - javascript | GaoYuan's Blog = 浅岛夏风 = 生活就像海洋，只有意志将强的人才能到达彼岸</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">函数防抖与节流</h1><div class="meta"><span class="item" title="创建时间：2021-03-19 09:43:56"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-03-19T09:43:56+08:00">2021-03-19</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">GaoYuan's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipev1x5e4j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipevo9j1jj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeyvx1d4j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclwuom7cj20zk0m8dvn.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/javascript/" itemprop="item" rel="index" title="分类于 javascript"><span itemprop="name">javascript</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="高原"><meta itemprop="description" content="生活就像海洋，只有意志将强的人才能到达彼岸, 一枚微不足道的前端攻城狮"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="浅岛夏风"></span><div class="body md" itemprop="articleBody"><h2 id="函数防抖"><a class="markdownIt-Anchor" href="#函数防抖">#</a> 函数防抖</h2><h3 id="一-为什么需要防抖"><a class="markdownIt-Anchor" href="#一-为什么需要防抖">#</a> 一、为什么需要防抖</h3><ul><li>高频的函数操作可能产生不好的影响</li><li>如：resize、scroll、mousedown、mousemove、keyup、keydown……</li></ul><p>为此，我们举个示例代码来了解事件如何频繁的触发：</p><p>我们写一个 index.html 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;title&gt;debounce&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #wrapper &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            line-height: 200px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            color: #fff;</span><br><span class="line">            background-color: #444;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var count = 1;</span><br><span class="line">        var oDiv = document.getElementById(&quot;wrapper&quot;);</span><br><span class="line">        function getUserAction() &#123;</span><br><span class="line">            oDiv.innerHTML = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        oDiv.onmousemove = getUserAction;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><span id="more"></span><p>从左边滑到右边就触发了近 100 次 <code>getUserAction</code> 函数！看如下 Gif：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408456-269506ee-a343-41c8-86b8-e80da9304d8e.gif" alt=""></p><p>因为这个例子很简单，所以浏览器完全反应的过来，但假设：</p><ul><li>它的触发频次极高，1 分钟 2000 次，且涉及到大量的位置计算、DOM 操作等工作，</li><li>存在接口请求，单个函数执行时间较长，但每个函数触发的间隔很近。</li></ul><p>这种在一瞬间（短时间内）对浏览器或服务器造成了过多压力的交互就需要进行优化了，为了解决这个问题，一般有两种解决方案：</p><ul><li>debounce 防抖</li><li>throttle 节流</li></ul><p>他们的目的都是：<strong>降低一个函数的触发频率，以提高性能或避免资源浪费。</strong></p><h3 id="二-防抖的原理"><a class="markdownIt-Anchor" href="#二-防抖的原理">#</a> 二、防抖的原理</h3><p>今天重点讲讲防抖的实现。</p><p>防抖的原理就是：你尽管触发事件，但是我一定在事件触发 <code>n秒无操作后</code> 才执行。举个例子：</p><p>我们规定 <code>3s</code> 为防抖的标准，那么:</p><ol><li>第一次要求执行事件 - 此时倒计时 3s</li><li>倒计时 2s</li><li>倒计时 1s</li><li>0.5s 时事件再次被触发 - 此时倒计时 3s</li><li>…3s 内无事发生</li><li>执行事件，共用了 5.5s</li></ol><h3 id="三-自己实现一个防抖"><a class="markdownIt-Anchor" href="#三-自己实现一个防抖">#</a> 三、自己实现一个防抖</h3><h4 id="31-第一版"><a class="markdownIt-Anchor" href="#31-第一版">#</a> 3.1 第一版</h4><p>我们根据上一节提到的核心思想，实现第一版代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(func, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要使用它，第一节的例子为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oDiv.onmousemove = debounce(getUserAction, 2000);</span><br></pre></td></tr></table></figure><p>此时大家可以再次测试一下，事件持续发生时，只有在完全停止 2s 后，才会触发事件：</p><p>写到这里，作为针对部分高频事件的需求来说，已经结束了。我们来看看他的效果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408554-b0245fd8-1c4d-4085-80da-f91d8be8da6f.gif" alt=""></p><h4 id="32-第二版"><a class="markdownIt-Anchor" href="#32-第二版">#</a> 3.2 第二版</h4><p>大家都知道，dom 节点在触发事件的时候，this 指向它本身，本例中则指向 <code>oDiv</code> ，但是在本例中：我们看一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var count = 1;</span><br><span class="line">var oDiv = document.getElementById(&quot;oDiv&quot;);</span><br><span class="line">function getUserAction() &#123;</span><br><span class="line">    oDiv.innerHTML = count++;</span><br><span class="line">    console.log(&#x27;this&#x27;, this); // 此时输出 Window...</span><br><span class="line">&#125;</span><br><span class="line">oDiv.onmousemove = debounce(getUserAction, 2000);</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(func, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毕竟经过了一层匿名函数的包裹，this 已经指向了 window，为了减少影响，我们尝试修正它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this = this; // 记录当前this</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(function()&#123;</span><br><span class="line">            func.apply(_this); //将 func的this改为_this</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="33-第三版"><a class="markdownIt-Anchor" href="#33-第三版">#</a> 3.3 第三版</h4><p>解决的 this 指向问题，我们的函数仍然不够 “完美”，JavaScript 中，事件处理函数会提供 <code>event</code> 对象，我们简称为 e。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用了 debouce 函数</span><br><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    console.log(e); // undefined</span><br><span class="line">    oDiv.innerHTML = count++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了保证它的原汁原味，我们再改第三版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var count = 1;</span><br><span class="line">var oDiv = document.getElementById(&quot;oDiv&quot;);</span><br><span class="line">function getUserAction(e) &#123;</span><br><span class="line">    oDiv.innerHTML = count++;</span><br><span class="line">    console.log(&#x27;e&#x27;, e); // MouseEvent</span><br><span class="line">&#125;</span><br><span class="line">oDiv.onmousemove = debounce(getUserAction, 2000);</span><br><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this = this; // 记录当前this</span><br><span class="line">        var arg = arguments; // 记录参数</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(function () &#123;</span><br><span class="line">            func.apply(_this, arg); //将 func的this改为_this</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们在尽可能保留 Dom 事件原有能力的情况下，给函数加上了防抖效果，它可以解决大部分我们日常开发的防抖问题，但我们需要更 “完美”</p><h3 id="四-防抖进阶"><a class="markdownIt-Anchor" href="#四-防抖进阶">#</a> 四、防抖进阶</h3><h4 id="41-立即执行"><a class="markdownIt-Anchor" href="#41-立即执行">#</a> 4.1 立即执行</h4><p>这个需求就是：</p><ul><li>立即执行</li><li>保持 <code>n</code> 秒空白期</li><li>将 <code>n</code> 秒空白期置后</li></ul><p>想想这个需求也是很有道理的嘛，那我们加个 <code>immediate</code> 参数判断是否是立刻执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        if (timer) clearTimeout(timer); // 常规流程，间隔内触发时清掉重置定时</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            // 如果已经执行过，不再执行</span><br><span class="line">            var callNow = !timer; // 1. callNow 初始值是 true, 同步立即执行；随后 timer 才开始执行</span><br><span class="line">            timer = setTimeout(function()&#123;</span><br><span class="line">                timer = null; // wait 期间，timer 是一个 ID 数字，所以 callNow 为 false，func 在此期间永远不会执行</span><br><span class="line">            &#125;, wait) // wait 之后，timer 赋值 null，callNow 为 true，func 又开始立即执行。</span><br><span class="line">            if (callNow) func.apply(_this, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timer = setTimeout(function()&#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看下此时他是什么效果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408487-78c69123-24ec-4893-b442-366d3117eda2.gif" alt=""></p><h4 id="42-添加简单验证"><a class="markdownIt-Anchor" href="#42-添加简单验证">#</a> 4.2 添加简单验证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    // 检查函数</span><br><span class="line">    if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class="line">        throw new TypeError(&#x27;Expected a function&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 保证wait存在</span><br><span class="line">    wait = +wait || 0;</span><br><span class="line">    const debounced = function () &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        if (timer) clearTimeout(timer); // 常规流程，间隔内触发时清掉重置定时</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            // 如果已经执行过，不再执行</span><br><span class="line">            var callNow = !timer; // 如果不存在定时器，则callNow为true</span><br><span class="line">            timer = setTimeout(function () &#123;</span><br><span class="line">                timer = null; // 为了保证之后的时效性，手动添加timer</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            // 因为不存在timer，证明是首次执行，所以直接调用</span><br><span class="line">            if (callNow) func.apply(_this, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timer = setTimeout(function () &#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="43-添加取消事件方法"><a class="markdownIt-Anchor" href="#43-添加取消事件方法">#</a> 4.3 添加取消事件方法</h4><p>如果你希望能取消被防抖的事件，我们可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timer;</span><br><span class="line">    // 检查函数</span><br><span class="line">    if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class="line">        throw new TypeError(&#x27;Expected a function&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 保证wait存在</span><br><span class="line">    wait = +wait || 0;</span><br><span class="line">    const debounced = function () &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        if (timer) clearTimeout(timer); // 常规流程，间隔内触发时清掉重置定时</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            // 如果已经执行过，不再执行</span><br><span class="line">            var callNow = !timer; // 如果不存在定时器，则callNow为true</span><br><span class="line">            timer = setTimeout(function () &#123;</span><br><span class="line">                timer = null; // 为了保证之后的时效性，手动添加timer</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            // 因为不存在timer，证明是首次执行，所以直接调用</span><br><span class="line">            if (callNow) func.apply(_this, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timer = setTimeout(function () &#123;</span><br><span class="line">                func.apply(_this, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const cancel = function()&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = null;</span><br><span class="line">    &#125;</span><br><span class="line">    const pending = function()&#123;</span><br><span class="line">        return timer !== undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.cancel = cancel;</span><br><span class="line">    debounced.pending = pending;</span><br><span class="line">    return debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看效果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408427-b468ccd4-99ff-4eee-821a-290d95e04071.gif" alt=""></p><h2 id="函数节流"><a class="markdownIt-Anchor" href="#函数节流">#</a> 函数节流</h2><h3 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h3><p>我们还是以移动事件举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #wrapper &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 140px;</span><br><span class="line">            background: rgba(0, 0, 0, 0.8);</span><br><span class="line">            color: #fff;</span><br><span class="line">            font-size: 30px;</span><br><span class="line">            font-weight: bold;</span><br><span class="line">            line-height: 140px;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var count = 1;</span><br><span class="line">        function moveAction () &#123;</span><br><span class="line">            oWrapper.innerHTML = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        var oWrapper = document.querySelector(&#x27;#wrapper&#x27;);</span><br><span class="line">        oWrapper.onmousemove = moveAction;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>它的效果是这样：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551747-de70166f-f851-412c-ba2a-5a116a194f3d.gif" alt=""></p><h3 id="一-核心和基本实现"><a class="markdownIt-Anchor" href="#一-核心和基本实现">#</a> 一、核心和基本实现</h3><p>节流的原理很简单：<strong>如果你持续触发某个事件，特定的时间间隔内，只执行一次。</strong></p><p><strong>关于节流的实现，有两种主流的实现方式：</strong></p><ol><li>时间戳思路</li><li>定时器思路</li></ol><h4 id="11-时间戳思路"><a class="markdownIt-Anchor" href="#11-时间戳思路">#</a> 1.1 时间戳思路</h4><p>顾名思义，通过两个时间戳来控制时间间隔，当触发事件的时候：</p><ol><li>我们取出当前的时间戳 <code>now</code> ；</li><li>然后减去之前<strong>执行时</strong>的时间戳 (首次值为 0) <code>prev</code> ；</li><li>如果大 <code>now - prev &gt; wait</code> ，证明时间区间维护结束，执行指定事件，更新 <code>prev</code> ；</li></ol><p>根据这一思路，我们就可以实现第一版代码了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">oWrapper.onmousemove = throttle(moveAction, 1000);</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var _this, arg;</span><br><span class="line">    var prev = 0; // 上一次触发的时间，第一次默认为0</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var now = Date.now(); // 触发时的时间</span><br><span class="line">        _this = this;</span><br><span class="line">        if (now - prev &gt; wait) &#123;</span><br><span class="line">            func.apply(_this, arg); // 允许传入参数，并修正this</span><br><span class="line">            prev = now; // 更新上一次触发的时间</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看借助它，效果是什么样的：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740552204-2bb5f2b1-3807-4d26-b3eb-d34e798ab60a.gif" alt=""></p><p>我们可以看到：</p><ol><li>当鼠标移入的时候，<strong>事件立刻执行</strong></li><li>每过 1s 会执行一次，且移动 2.5s 会执行 2 次，意味着动作<strong>停止后不会再执行</strong>。</li></ol><h4 id="12-定时器思路"><a class="markdownIt-Anchor" href="#12-定时器思路">#</a> 1.2 定时器思路</h4><p>利用定时器来保证间隔时间内事件的触发次数</p><ol><li>创建定时器 <code>timer</code> ，记录当前是否在<strong>周期</strong>内；</li><li>判断定时器是否存在，若存在则直接结束，否则执行事件；</li><li><code>wait</code> 时间之后再次执行，并清掉定时器；</li></ol><p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var _this, arg;</span><br><span class="line">    var timer; // 初始化</span><br><span class="line">    return function () &#123;</span><br><span class="line">        _this = this; // 记录this</span><br><span class="line">        arg = arguments; // 记录参数数组</span><br><span class="line">        if (timer) return; // 时候未到</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            func.apply(_this, arg); // 允许传入参数，并修正this</span><br><span class="line">            timer = null;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看借助它，效果是什么样的：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551861-12bc2cce-f80a-45ff-9913-7798160b3438.gif" alt=""></p><p>但是，我们可以看到：</p><ol><li>当鼠标移入的时候，事件不会立刻执行；</li><li>鼠标定制后 <code>wait</code> 间隔后会执行一次</li></ol><h4 id="13-两种思路的区别"><a class="markdownIt-Anchor" href="#13-两种思路的区别">#</a> 1.3 两种思路的区别</h4><table><thead><tr><th></th><th>时间戳</th><th>定时器</th></tr></thead><tbody><tr><td>“起点”</td><td>立即执行</td><td>n 秒后执行</td></tr><tr><td>“终点”</td><td>停止后不会执行</td><td>停止会再执行一次</td></tr></tbody></table><h3 id="二-节流进阶"><a class="markdownIt-Anchor" href="#二-节流进阶">#</a> 二、节流进阶</h3><p>结合两种思想完成一个可以立即执行，且停止触发后再执行一次的节流方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 第三版</span><br><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous = 0;</span><br><span class="line">    var later = function() &#123;</span><br><span class="line">        previous = +new Date();</span><br><span class="line">        timeout = null;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">    &#125;;</span><br><span class="line">    var throttled = function() &#123;</span><br><span class="line">        var now = +new Date();</span><br><span class="line">        //下次触发 func 剩余的时间</span><br><span class="line">        var remaining = wait - (now - previous);</span><br><span class="line">        context = this;</span><br><span class="line">        args = arguments;</span><br><span class="line">         // 如果没有剩余的时间了或者你改了系统时间</span><br><span class="line">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">        &#125; else if (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示如下：</p><p><img data-src="https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551783-4d2e4584-8e32-4ca2-a1de-c2ab865a882c.gif" alt=""></p><p>我在看代码的时候，我是反复打印数据才理解为什么会这样做，一起加油～</p><div class="tags"><a href="/tags/javascript/" rel="tag"><i class="ic i-tag"></i> javascript</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-05-13 16:29:43" itemprop="dateModified" datetime="2021-05-13T16:29:43+08:00">2021-05-13</time> </span><span id="2021/03/19/函数防抖与节流/" class="item leancloud_visitors" data-flag-title="函数防抖与节流" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="高原 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="高原 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>高原 <i class="ic i-at"><em>@</em></i>浅岛夏风</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/" title="函数防抖与节流">http://example.com/2021/03/19/函数防抖与节流/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/03/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%8E%9F%E7%90%86/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeu7txpzj20zk0m81kx.jpg" title="三次握手四次挥手的原理"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> HTTP</span><h3>三次握手四次挥手的原理</h3></a></div><div class="item right"><a href="/2021/03/20/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89this/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclx6phq6j20zk0m8e36.jpg" title="JavaScript基础（一）this"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> JavaScript 专题</span><h3>JavaScript基础（一）this</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96"><span class="toc-number">1.</span> <span class="toc-text">函数防抖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%98%B2%E6%8A%96"><span class="toc-number">1.1.</span> <span class="toc-text">一、为什么需要防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E9%98%B2%E6%8A%96%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">二、防抖的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%B2%E6%8A%96"><span class="toc-number">1.3.</span> <span class="toc-text">三、自己实现一个防抖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E7%AC%AC%E4%B8%80%E7%89%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 第一版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E7%AC%AC%E4%BA%8C%E7%89%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 第二版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-%E7%AC%AC%E4%B8%89%E7%89%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 第三版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E9%98%B2%E6%8A%96%E8%BF%9B%E9%98%B6"><span class="toc-number">1.4.</span> <span class="toc-text">四、防抖进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 立即执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E9%AA%8C%E8%AF%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 添加简单验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-%E6%B7%BB%E5%8A%A0%E5%8F%96%E6%B6%88%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 添加取消事件方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">函数节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">2.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E6%A0%B8%E5%BF%83%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">一、核心和基本实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%97%B6%E9%97%B4%E6%88%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.1 时间戳思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%AE%9A%E6%97%B6%E5%99%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.2.</span> <span class="toc-text">1.2 定时器思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E4%B8%A4%E7%A7%8D%E6%80%9D%E8%B7%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.3.</span> <span class="toc-text">1.3 两种思路的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E8%8A%82%E6%B5%81%E8%BF%9B%E9%98%B6"><span class="toc-number">2.3.</span> <span class="toc-text">二、节流进阶</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/02/11/JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/" rel="bookmark" title="JS实现图片压缩">JS实现图片压缩</a></li><li class="active"><a href="/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/" rel="bookmark" title="函数防抖与节流">函数防抖与节流</a></li><li><a href="/2021/05/12/Javascript%E4%B8%AD%E5%93%AA%E4%B8%80%E7%A7%8D%E5%BE%AA%E7%8E%AF%E6%9C%80%E5%BF%AB%E5%91%A2%EF%BC%9F/" rel="bookmark" title="Javascript中哪一种循环最快呢？">Javascript中哪一种循环最快呢？</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="高原" data-src="/images/avatar.jpg"><p class="name" itemprop="name">高原</p><div class="description" itemprop="description">一枚微不足道的前端攻城狮</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">24</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">13</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dhb3l1YW5pbw==" title="https:&#x2F;&#x2F;github.com&#x2F;gaoyuanio"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmdhb3l1YW45ODQxQDE2My5jb20=" title="mailto:gaoyuan9841@163.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="/friends/" rel="section"><i class="ic i-magic"></i>links</a><ul class="submenu"><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/03/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%8E%9F%E7%90%86/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/03/20/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89this/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" title="分类于 移动端">移动端</a></div><span><a href="/2021/04/25/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94%E2%80%94%E2%80%94%E6%89%8B%E6%B7%98flexible/" title="移动端自适应——手淘flexible">移动端自适应——手淘flexible</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Hbuilder/" title="分类于 Hbuilder">Hbuilder</a></div><span><a href="/2018/07/12/%E4%BD%BF%E7%94%A8Hbuilder%E5%BF%AB%E9%80%9F%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AAapp/" title="使用Hbuilder快速打包一个app">使用Hbuilder快速打包一个app</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/script-topic/" title="分类于 JavaScript 专题">JavaScript 专题</a></div><span><a href="/2021/03/21/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/" title="JavaScript基础（二）从原型到原型链">JavaScript基础（二）从原型到原型链</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/javascript/" title="分类于 javascript">javascript</a></div><span><a href="/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/" title="函数防抖与节流">函数防抖与节流</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue/" title="分类于 Vue 专题">Vue 专题</a></div><span><a href="/2021/02/20/VUE%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%846%E7%A7%8D%E6%96%B9%E5%BC%8F/" title="VUE组件之间通信的6种方式">VUE组件之间通信的6种方式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/HTTP/" title="分类于 HTTP">HTTP</a></div><span><a href="/2020/12/16/HTTPS%E5%92%8CHTTP%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/" title="HTTPS和HTTP原理和区别">HTTPS和HTTP原理和区别</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 note">note</a></div><span><a href="/2021/04/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E6%B1%87/" title="浏览器回流和重汇">浏览器回流和重汇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/script-topic/" title="分类于 JavaScript 专题">JavaScript 专题</a></div><span><a href="/2021/03/20/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89this/" title="JavaScript基础（一）this">JavaScript基础（一）this</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/vue/" title="分类于 Vue 专题">Vue 专题</a></div><span><a href="/2020/11/18/vue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/" title="vue项目打包优化策略">vue项目打包优化策略</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/javascript/" title="分类于 javascript">javascript</a></div><span><a href="/2021/02/11/JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/" title="JS实现图片压缩">JS实现图片压缩</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">高原 @ GaoYuan's Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">93k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:24</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/03/19/函数防抖与节流/",favicon:{show:"(●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":true,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>