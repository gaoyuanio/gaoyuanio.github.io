<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>浅岛夏风 • Posts by &#34;note&#34; tag</title>
        <link>http://example.com</link>
        <description>一枚微不足道的前端攻城狮</description>
        <language>zh-CN</language>
        <pubDate>Fri, 16 Apr 2021 09:20:34 +0800</pubDate>
        <lastBuildDate>Fri, 16 Apr 2021 09:20:34 +0800</lastBuildDate>
        <category>javascript</category>
        <category>HTTP</category>
        <category>vue</category>
        <category>MySQL</category>
        <category>vuex</category>
        <category>webpack</category>
        <category>axios</category>
        <category>Hbuilder</category>
        <category>AJAX</category>
        <category>CSS</category>
        <category>react</category>
        <category>note</category>
        <category>移动端</category>
        <item>
            <guid isPermalink="true">http://example.com/2021/04/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E6%B1%87/</guid>
            <title>浏览器回流和重汇</title>
            <link>http://example.com/2021/04/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E6%B1%87/</link>
            <category>note</category>
            <pubDate>Fri, 16 Apr 2021 09:20:34 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/640&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h2 id=&#34;一-是什么&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一-是什么&#34;&gt;#&lt;/a&gt; 一、是什么&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;HTML&lt;/code&gt;  中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置&lt;/li&gt;
&lt;li&gt;重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的浏览器解析渲染机制如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20210416102029.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树&lt;/li&gt;
&lt;li&gt;将 DOM 树和 CSSOM 树结合，生成渲染树 (Render Tree)&lt;/li&gt;
&lt;li&gt;Layout (回流): 根据生成的渲染树，进行回流 (Layout)，得到节点的几何信息（位置，大小）&lt;/li&gt;
&lt;li&gt;Painting (重绘): 根据渲染树以及回流得到的几何信息，得到节点的绝对像素&lt;/li&gt;
&lt;li&gt;Display: 将像素发送给 GPU，展示在页面上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变&lt;/p&gt;
&lt;p&gt;当我们对  &lt;code&gt;DOM&lt;/code&gt;  的修改引发了  &lt;code&gt;DOM&lt;/code&gt;  几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来&lt;/p&gt;
&lt;p&gt;当我们对  &lt;code&gt;DOM&lt;/code&gt;  的修改导致了样式的变化（ &lt;code&gt;color&lt;/code&gt;  或 &lt;code&gt;background-color&lt;/code&gt; ），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘&lt;/p&gt;
&lt;h2 id=&#34;二-如何触发&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#二-如何触发&#34;&gt;#&lt;/a&gt; 二、如何触发&lt;/h2&gt;
&lt;p&gt;要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的&lt;/p&gt;
&lt;h3 id=&#34;回流触发时机&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#回流触发时机&#34;&gt;#&lt;/a&gt; 回流触发时机&lt;/h3&gt;
&lt;p&gt;回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加或删除可见的 DOM 元素&lt;/li&gt;
&lt;li&gt;元素的位置发生变化&lt;/li&gt;
&lt;li&gt;元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）&lt;/li&gt;
&lt;li&gt;内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代&lt;/li&gt;
&lt;li&gt;页面一开始渲染的时候（这避免不了）&lt;/li&gt;
&lt;li&gt;浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一些容易被忽略的操作：获取一些特定属性的值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight&lt;/p&gt;
&lt;p&gt;❞&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流&lt;/p&gt;
&lt;p&gt;除此还包括 &lt;code&gt;getComputedStyle&lt;/code&gt;  方法，原理是一样的&lt;/p&gt;
&lt;h3 id=&#34;重绘触发时机&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#重绘触发时机&#34;&gt;#&lt;/a&gt; 重绘触发时机&lt;/h3&gt;
&lt;p&gt;触发回流一定会触发重绘&lt;/p&gt;
&lt;p&gt;可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）&lt;/p&gt;
&lt;p&gt;除此之外还有一些其他引起重绘行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;颜色的修改&lt;/li&gt;
&lt;li&gt;文本方向的修改&lt;/li&gt;
&lt;li&gt;阴影的修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;浏览器优化机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#浏览器优化机制&#34;&gt;#&lt;/a&gt; 浏览器优化机制&lt;/h3&gt;
&lt;p&gt;由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列&lt;/p&gt;
&lt;p&gt;当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的 &lt;code&gt;offsetTop&lt;/code&gt;  等方法都会返回最新的数据&lt;/p&gt;
&lt;p&gt;因此浏览器不得不清空队列，触发回流重绘来返回正确的值&lt;/p&gt;
&lt;h2 id=&#34;三-如何减少&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#三-如何减少&#34;&gt;#&lt;/a&gt; 三、如何减少&lt;/h2&gt;
&lt;p&gt;我们了解了如何触发回流和重绘的场景，下面给出避免回流的经验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果想设定元素的样式，通过改变元素的  &lt;code&gt;class&lt;/code&gt;  类名 (尽可能在 DOM 树的最里层)&lt;/li&gt;
&lt;li&gt;避免设置多项内联样式&lt;/li&gt;
&lt;li&gt;应用元素的动画，使用  &lt;code&gt;position&lt;/code&gt;  属性的  &lt;code&gt;fixed&lt;/code&gt;  值或  &lt;code&gt;absolute&lt;/code&gt;  值 (如前文示例所提)&lt;/li&gt;
&lt;li&gt;避免使用  &lt;code&gt;table&lt;/code&gt;  布局， &lt;code&gt;table&lt;/code&gt;  中每个元素的大小以及内容的改动，都会导致整个  &lt;code&gt;table&lt;/code&gt;  的重新计算&lt;/li&gt;
&lt;li&gt;对于那些复杂的动画，对其设置  &lt;code&gt;position: fixed/absolute&lt;/code&gt; ，尽可能地使元素脱离文档流，从而减少对其他元素的影响&lt;/li&gt;
&lt;li&gt;使用 css3 硬件加速，可以让 &lt;code&gt;transform&lt;/code&gt; 、 &lt;code&gt;opacity&lt;/code&gt; 、 &lt;code&gt;filters&lt;/code&gt;  这些动画不会引起回流重绘&lt;/li&gt;
&lt;li&gt;避免使用 CSS 的  &lt;code&gt;JavaScript&lt;/code&gt;  表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在使用  &lt;code&gt;JavaScript&lt;/code&gt;  动态插入多个节点时，可以使用 &lt;code&gt;DocumentFragment&lt;/code&gt; . 创建后一次插入。就能避免多次的渲染性能&lt;/p&gt;
&lt;p&gt;但有时候，我们会无可避免地进行回流或者重绘，我们可以更好使用它们&lt;/p&gt;
&lt;p&gt;例如，多次修改一个把元素布局的时候，我们很可能会如下操作&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;const el = document.getElementById(&amp;#x27;el&amp;#x27;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;for(let i=0;i&amp;lt;10;i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    el.style.top  = el.offsetTop  + 10 + &amp;quot;px&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    el.style.left = el.offsetLeft + 10 + &amp;quot;px&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每次循环都需要获取多次 &lt;code&gt;offset&lt;/code&gt;  属性，比较糟糕，可以使用变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// 缓存offsetLeft与offsetTop的值&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;const el = document.getElementById(&amp;#x27;el&amp;#x27;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;let offLeft = el.offsetLeft, offTop = el.offsetTop&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 在JS层面进行计算&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;for(let i=0;i&amp;lt;10;i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  offLeft += 10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  offTop  += 10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 一次性将计算结果应用到DOM上&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;el.style.left = offLeft + &amp;quot;px&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;el.style.top = offTop  + &amp;quot;px&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们还可避免改变样式，使用类名去合并样式&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;const container = document.getElementById(&amp;#x27;container&amp;#x27;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.width = &amp;#x27;100px&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.height = &amp;#x27;200px&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.border = &amp;#x27;10px solid red&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.color = &amp;#x27;red&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用类名去合并样式&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .basic_style &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        width: 100px;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        height: 200px;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        border: 10px solid red;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        color: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    const container = document.getElementById(&amp;#x27;container&amp;#x27;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    container.classList.add(&amp;#x27;basic_style&amp;#x27;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前者每次单独操作，都去触发一次渲染树更改（新浏览器不会），&lt;/p&gt;
&lt;p&gt;都去触发一次渲染树更改，从而导致相应的回流与重绘过程&lt;/p&gt;
&lt;p&gt;合并之后，等于我们将所有的更改一次性发出&lt;/p&gt;
&lt;p&gt;我们还可以通过通过设置元素属性 &lt;code&gt;display: none&lt;/code&gt; ，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;const container = document.getElementById(&amp;#x27;container&amp;#x27;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.width = &amp;#x27;100px&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.height = &amp;#x27;200px&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.border = &amp;#x27;10px solid red&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.color = &amp;#x27;red&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;离线操作后&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;let container = document.getElementById(&amp;#x27;container&amp;#x27;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.display = &amp;#x27;none&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.width = &amp;#x27;100px&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.height = &amp;#x27;200px&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.border = &amp;#x27;10px solid red&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.color = &amp;#x27;red&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;...（省略了许多类似的后续操作）&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;container.style.display = &amp;#x27;block&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#&#34;&gt;#&lt;/a&gt; &lt;/h2&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2020/05/01/%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid>
            <title>开发小技巧</title>
            <link>http://example.com/2020/05/01/%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</link>
            <category>note</category>
            <pubDate>Fri, 01 May 2020 21:55:23 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;阻止单击事件冒泡&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#阻止单击事件冒泡&#34;&gt;#&lt;/a&gt; 阻止单击事件冒泡&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a v-on:click.stop=&amp;quot;doThis&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;提交事件不再重载页面&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#提交事件不再重载页面&#34;&gt;#&lt;/a&gt; 提交事件不再重载页面&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;form v-on:submit.prevent=&amp;quot;onSubmit&amp;quot;&amp;gt;&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;修饰符可以串联&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#修饰符可以串联&#34;&gt;#&lt;/a&gt; 修饰符可以串联&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a v-on:click.stop.prevent=&amp;quot;doThat&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h2 id=&#34;只有修饰符&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#只有修饰符&#34;&gt;#&lt;/a&gt; 只有修饰符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;form v-on:submit.prevent&amp;gt;&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;mac谷歌跨域命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mac谷歌跨域命令&#34;&gt;#&lt;/a&gt; Mac 谷歌跨域命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;open -n /Applications/Google\ Chrome.app/ --args --disable-web-security  --user-data-dir=/Users/GaoYuan/Documents/MyChromeDevUserData&lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;mac显示隐藏文件命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mac显示隐藏文件命令&#34;&gt;#&lt;/a&gt; Mac 显示隐藏文件命令：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;显示隐藏文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles Yes &amp;amp;&amp;amp; killall Finder &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不显示隐藏文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles No &amp;amp;&amp;amp; killall Finder &lt;/code&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id=&#34;jison解决js处理后端返回的long型数据精度丢失问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#jison解决js处理后端返回的long型数据精度丢失问题&#34;&gt;#&lt;/a&gt; Jison 解决 JS 处理后端返回的 Long 型数据精度丢失问题&lt;/h2&gt;
&lt;p&gt;原因：js 是弱类型语言，所有的数字类型统称为 Number 类型，不区分 int、long、double 等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone git://github.com/zaach/jsonlint.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 src 目录下提供了 jsonlint.y（grammaFile）和 jsonlint.l（lexFile) 两个文件。使用这两个文件可以直接生成 jsonlint.js。如下修改 jsonlint.y：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;JSONNumber&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    : NUMBER&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#123;$$ = yytext == String(Number(yytext))? Number(yytext): yytext;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd src&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;jison jsonlint.y jsonlint.l&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;最后引入至项目&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#最后引入至项目&#34;&gt;#&lt;/a&gt; 最后引入至项目&lt;/h3&gt;
&lt;p&gt;1. 将自定义的 jsonlint.js 放到 static 目录下&lt;br&gt;
 2. 在 index.html 中引入&lt;br&gt;
 &lt;code&gt;&amp;lt;script src=&amp;quot;./static/jsonlint/jsonlint.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3、在我们请求的返回数据中，做一层拦截转换，此处以 axios 的实现方法为例：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;/*transformResponse 选项允许我们在数据传送到 `then/catch` 方法之前对数据进行改动*/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;axios.defaults.transformResponse = [&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  function(data) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    return jsonlint.parse(data)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;综上，定义 JSON 转化避免 long 类型数据溢出，可以实现 long 类型数据在前端正常显示&lt;/p&gt;
&lt;h2 id=&#34;mac给文件夹赋予管理员权限&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mac给文件夹赋予管理员权限&#34;&gt;#&lt;/a&gt; Mac 给文件夹赋予管理员权限&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sudo chown -R gaoyuan ios&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;if ($request_filename ~* .*index\.html$) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;     add_header Cache-Control &amp;quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt; ]]></description>
        </item>
    </channel>
</rss>
