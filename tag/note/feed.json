{
    "version": "https://jsonfeed.org/version/1",
    "title": "浅岛夏风 • All posts by \"note\" tag",
    "description": "一枚微不足道的前端攻城狮",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/04/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E6%B1%87/",
            "url": "http://example.com/2021/04/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E6%B1%87/",
            "title": "浏览器回流和重汇",
            "date_published": "2021-04-16T01:20:34.000Z",
            "content_html": "<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/640\" alt=\"\"></p>\n<span id=\"more\"></span>\n<h2 id=\"一-是什么\"><a class=\"markdownIt-Anchor\" href=\"#一-是什么\">#</a> 一、是什么</h2>\n<p>在 <code>HTML</code>  中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘：</p>\n<ul>\n<li>回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置</li>\n<li>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</li>\n</ul>\n<p>具体的浏览器解析渲染机制如下所示：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20210416102029.png\" alt=\"\"></p>\n<ul>\n<li>解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树</li>\n<li>将 DOM 树和 CSSOM 树结合，生成渲染树 (Render Tree)</li>\n<li>Layout (回流): 根据生成的渲染树，进行回流 (Layout)，得到节点的几何信息（位置，大小）</li>\n<li>Painting (重绘): 根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>\n<li>Display: 将像素发送给 GPU，展示在页面上</li>\n</ul>\n<p>在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变</p>\n<p>当我们对  <code>DOM</code>  的修改引发了  <code>DOM</code>  几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来</p>\n<p>当我们对  <code>DOM</code>  的修改导致了样式的变化（ <code>color</code>  或 <code>background-color</code> ），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘</p>\n<h2 id=\"二-如何触发\"><a class=\"markdownIt-Anchor\" href=\"#二-如何触发\">#</a> 二、如何触发</h2>\n<p>要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的</p>\n<h3 id=\"回流触发时机\"><a class=\"markdownIt-Anchor\" href=\"#回流触发时机\">#</a> 回流触发时机</h3>\n<p>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：</p>\n<ul>\n<li>添加或删除可见的 DOM 元素</li>\n<li>元素的位置发生变化</li>\n<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>\n<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li>\n<li>页面一开始渲染的时候（这避免不了）</li>\n<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>\n</ul>\n<p>还有一些容易被忽略的操作：获取一些特定属性的值</p>\n<blockquote>\n<p>❝</p>\n<p>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</p>\n<p>❞</p>\n</blockquote>\n<p>这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流</p>\n<p>除此还包括 <code>getComputedStyle</code>  方法，原理是一样的</p>\n<h3 id=\"重绘触发时机\"><a class=\"markdownIt-Anchor\" href=\"#重绘触发时机\">#</a> 重绘触发时机</h3>\n<p>触发回流一定会触发重绘</p>\n<p>可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）</p>\n<p>除此之外还有一些其他引起重绘行为：</p>\n<ul>\n<li>颜色的修改</li>\n<li>文本方向的修改</li>\n<li>阴影的修改</li>\n</ul>\n<h3 id=\"浏览器优化机制\"><a class=\"markdownIt-Anchor\" href=\"#浏览器优化机制\">#</a> 浏览器优化机制</h3>\n<p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列</p>\n<p>当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的 <code>offsetTop</code>  等方法都会返回最新的数据</p>\n<p>因此浏览器不得不清空队列，触发回流重绘来返回正确的值</p>\n<h2 id=\"三-如何减少\"><a class=\"markdownIt-Anchor\" href=\"#三-如何减少\">#</a> 三、如何减少</h2>\n<p>我们了解了如何触发回流和重绘的场景，下面给出避免回流的经验：</p>\n<ul>\n<li>如果想设定元素的样式，通过改变元素的  <code>class</code>  类名 (尽可能在 DOM 树的最里层)</li>\n<li>避免设置多项内联样式</li>\n<li>应用元素的动画，使用  <code>position</code>  属性的  <code>fixed</code>  值或  <code>absolute</code>  值 (如前文示例所提)</li>\n<li>避免使用  <code>table</code>  布局， <code>table</code>  中每个元素的大小以及内容的改动，都会导致整个  <code>table</code>  的重新计算</li>\n<li>对于那些复杂的动画，对其设置  <code>position: fixed/absolute</code> ，尽可能地使元素脱离文档流，从而减少对其他元素的影响</li>\n<li>使用 css3 硬件加速，可以让 <code>transform</code> 、 <code>opacity</code> 、 <code>filters</code>  这些动画不会引起回流重绘</li>\n<li>避免使用 CSS 的  <code>JavaScript</code>  表达式</li>\n</ul>\n<p>在使用  <code>JavaScript</code>  动态插入多个节点时，可以使用 <code>DocumentFragment</code> . 创建后一次插入。就能避免多次的渲染性能</p>\n<p>但有时候，我们会无可避免地进行回流或者重绘，我们可以更好使用它们</p>\n<p>例如，多次修改一个把元素布局的时候，我们很可能会如下操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const el = document.getElementById(&#x27;el&#x27;)</span><br><span class=\"line\">for(let i=0;i&lt;10;i++) &#123;</span><br><span class=\"line\">    el.style.top  = el.offsetTop  + 10 + &quot;px&quot;;</span><br><span class=\"line\">    el.style.left = el.offsetLeft + 10 + &quot;px&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次循环都需要获取多次 <code>offset</code>  属性，比较糟糕，可以使用变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 缓存offsetLeft与offsetTop的值</span><br><span class=\"line\">const el = document.getElementById(&#x27;el&#x27;)</span><br><span class=\"line\">let offLeft = el.offsetLeft, offTop = el.offsetTop</span><br><span class=\"line\"></span><br><span class=\"line\">// 在JS层面进行计算</span><br><span class=\"line\">for(let i=0;i&lt;10;i++) &#123;</span><br><span class=\"line\">  offLeft += 10</span><br><span class=\"line\">  offTop  += 10</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 一次性将计算结果应用到DOM上</span><br><span class=\"line\">el.style.left = offLeft + &quot;px&quot;</span><br><span class=\"line\">el.style.top = offTop  + &quot;px&quot;</span><br></pre></td></tr></table></figure>\n<p>我们还可避免改变样式，使用类名去合并样式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const container = document.getElementById(&#x27;container&#x27;)</span><br><span class=\"line\">container.style.width = &#x27;100px&#x27;</span><br><span class=\"line\">container.style.height = &#x27;200px&#x27;</span><br><span class=\"line\">container.style.border = &#x27;10px solid red&#x27;</span><br><span class=\"line\">container.style.color = &#x27;red&#x27;</span><br></pre></td></tr></table></figure>\n<p>使用类名去合并样式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .basic_style &#123;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 200px;</span><br><span class=\"line\">        border: 10px solid red;</span><br><span class=\"line\">        color: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    const container = document.getElementById(&#x27;container&#x27;)</span><br><span class=\"line\">    container.classList.add(&#x27;basic_style&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>前者每次单独操作，都去触发一次渲染树更改（新浏览器不会），</p>\n<p>都去触发一次渲染树更改，从而导致相应的回流与重绘过程</p>\n<p>合并之后，等于我们将所有的更改一次性发出</p>\n<p>我们还可以通过通过设置元素属性 <code>display: none</code> ，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const container = document.getElementById(&#x27;container&#x27;)</span><br><span class=\"line\">container.style.width = &#x27;100px&#x27;</span><br><span class=\"line\">container.style.height = &#x27;200px&#x27;</span><br><span class=\"line\">container.style.border = &#x27;10px solid red&#x27;</span><br><span class=\"line\">container.style.color = &#x27;red&#x27;</span><br></pre></td></tr></table></figure>\n<p>离线操作后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let container = document.getElementById(&#x27;container&#x27;)</span><br><span class=\"line\">container.style.display = &#x27;none&#x27;</span><br><span class=\"line\">container.style.width = &#x27;100px&#x27;</span><br><span class=\"line\">container.style.height = &#x27;200px&#x27;</span><br><span class=\"line\">container.style.border = &#x27;10px solid red&#x27;</span><br><span class=\"line\">container.style.color = &#x27;red&#x27;</span><br><span class=\"line\">...（省略了许多类似的后续操作）</span><br><span class=\"line\">container.style.display = &#x27;block&#x27;</span><br></pre></td></tr></table></figure>\n<h2 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h2>\n",
            "tags": [
                "note"
            ]
        },
        {
            "id": "http://example.com/2020/05/01/%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/",
            "url": "http://example.com/2020/05/01/%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/",
            "title": "开发小技巧",
            "date_published": "2020-05-01T13:55:23.000Z",
            "content_html": "<h2 id=\"阻止单击事件冒泡\"><a class=\"markdownIt-Anchor\" href=\"#阻止单击事件冒泡\">#</a> 阻止单击事件冒泡</h2>\n<p><code>&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</code></p>\n<h2 id=\"提交事件不再重载页面\"><a class=\"markdownIt-Anchor\" href=\"#提交事件不再重载页面\">#</a> 提交事件不再重载页面</h2>\n<p><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code></p>\n<h2 id=\"修饰符可以串联\"><a class=\"markdownIt-Anchor\" href=\"#修饰符可以串联\">#</a> 修饰符可以串联</h2>\n<p><code>&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;</code></p>\n<span id=\"more\"></span>\n<h2 id=\"只有修饰符\"><a class=\"markdownIt-Anchor\" href=\"#只有修饰符\">#</a> 只有修饰符</h2>\n<p><code>&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</code></p>\n<br>\n<br>\n<br>\n<h2 id=\"mac谷歌跨域命令\"><a class=\"markdownIt-Anchor\" href=\"#mac谷歌跨域命令\">#</a> Mac 谷歌跨域命令</h2>\n<p><code>open -n /Applications/Google\\ Chrome.app/ --args --disable-web-security  --user-data-dir=/Users/GaoYuan/Documents/MyChromeDevUserData</code></p>\n<br>\n<br>\n<br>\n<h2 id=\"mac显示隐藏文件命令\"><a class=\"markdownIt-Anchor\" href=\"#mac显示隐藏文件命令\">#</a> Mac 显示隐藏文件命令：</h2>\n<p><strong>显示隐藏文件</strong></p>\n<p><code>defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder </code></p>\n<p><strong>不显示隐藏文件</strong></p>\n<p><code>defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder </code></p>\n<br>\n<br>\n<h2 id=\"jison解决js处理后端返回的long型数据精度丢失问题\"><a class=\"markdownIt-Anchor\" href=\"#jison解决js处理后端返回的long型数据精度丢失问题\">#</a> Jison 解决 JS 处理后端返回的 Long 型数据精度丢失问题</h2>\n<p>原因：js 是弱类型语言，所有的数字类型统称为 Number 类型，不区分 int、long、double 等。</p>\n<p><code>git clone git://github.com/zaach/jsonlint.git</code></p>\n<p>在 src 目录下提供了 jsonlint.y（grammaFile）和 jsonlint.l（lexFile) 两个文件。使用这两个文件可以直接生成 jsonlint.js。如下修改 jsonlint.y：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSONNumber</span><br><span class=\"line\"></span><br><span class=\"line\">    : NUMBER</span><br><span class=\"line\">    </span><br><span class=\"line\">        &#123;$$ = yytext == String(Number(yytext))? Number(yytext): yytext;&#125;</span><br><span class=\"line\">    ;</span><br></pre></td></tr></table></figure>\n<p>然后：</p>\n<p><code>cd src</code></p>\n<p><code>jison jsonlint.y jsonlint.l</code></p>\n<h3 id=\"最后引入至项目\"><a class=\"markdownIt-Anchor\" href=\"#最后引入至项目\">#</a> 最后引入至项目</h3>\n<p>1. 将自定义的 jsonlint.js 放到 static 目录下<br>\n 2. 在 index.html 中引入<br>\n <code>&lt;script src=&quot;./static/jsonlint/jsonlint.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>3、在我们请求的返回数据中，做一层拦截转换，此处以 axios 的实现方法为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*transformResponse 选项允许我们在数据传送到 `then/catch` 方法之前对数据进行改动*/</span><br><span class=\"line\">axios.defaults.transformResponse = [</span><br><span class=\"line\">  function(data) &#123;</span><br><span class=\"line\">    return jsonlint.parse(data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>综上，定义 JSON 转化避免 long 类型数据溢出，可以实现 long 类型数据在前端正常显示</p>\n<h2 id=\"mac给文件夹赋予管理员权限\"><a class=\"markdownIt-Anchor\" href=\"#mac给文件夹赋予管理员权限\">#</a> Mac 给文件夹赋予管理员权限</h2>\n<p><code>sudo chown -R gaoyuan ios</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ($request_filename ~* .*index\\.html$) &#123;</span><br><span class=\"line\">     add_header Cache-Control &quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "note"
            ]
        }
    ]
}