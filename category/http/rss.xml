<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>浅岛夏风 • Posts by &#34;http&#34; category</title>
        <link>http://example.com</link>
        <description>一枚微不足道的前端攻城狮</description>
        <language>zh-CN</language>
        <pubDate>Mon, 01 Mar 2021 22:32:01 +0800</pubDate>
        <lastBuildDate>Mon, 01 Mar 2021 22:32:01 +0800</lastBuildDate>
        <category>javascript</category>
        <category>HTTP</category>
        <category>vue</category>
        <category>MySQL</category>
        <category>vuex</category>
        <category>webpack</category>
        <category>axios</category>
        <category>Hbuilder</category>
        <category>AJAX</category>
        <category>CSS</category>
        <category>react</category>
        <category>note</category>
        <category>移动端</category>
        <item>
            <guid isPermalink="true">http://example.com/2021/03/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%8E%9F%E7%90%86/</guid>
            <title>三次握手四次挥手的原理</title>
            <link>http://example.com/2021/03/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%8E%9F%E7%90%86/</link>
            <category>HTTP</category>
            <pubDate>Mon, 01 Mar 2021 22:32:01 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;三次握手&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#三次握手&#34;&gt;#&lt;/a&gt; 三次握手&lt;/h2&gt;
&lt;p&gt;握手的过程：&lt;/p&gt;
&lt;p&gt;1、第一次握手：客户端给服务器发送一个 SYN 报文。&lt;/p&gt;
&lt;p&gt;2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。&lt;/p&gt;
&lt;p&gt;3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。&lt;/p&gt;
&lt;p&gt;4、服务器收到 ACK 报文之后，三次握手建立完成。&lt;/p&gt;
&lt;p&gt;作用是为了确认双方的接收与发送能力是否正常。&lt;/p&gt;
   &lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;&lt;strong&gt;这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。&lt;br&gt;
第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。&lt;br&gt;
第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，需要三次握手才能确认双方的接收与发送能力是否正常。&lt;/p&gt;
&lt;p&gt;这样回答其实也是可以的，但我觉得，这个过程的我们应该要描述的更&lt;strong&gt;详细一点&lt;/strong&gt;，因为三次握手的过程中，双方是&lt;strong&gt;由很多状态的改变的&lt;/strong&gt;，而这些状态，也是面试官可能会问的点。所以我觉得在回答三次握手的时候，我们应该要描述的详细一点，而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;刚开始客户端处于 closed 的状态，服务端处于 listen 状态&lt;/strong&gt;。然后&lt;br&gt;
 1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 &lt;strong&gt;ISN（c）&lt;/strong&gt;。此时客户端处于 &lt;strong&gt;SYN_Send&lt;/strong&gt; 状态。&lt;/p&gt;
&lt;p&gt;2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN (s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 &lt;strong&gt;SYN_REVD&lt;/strong&gt; 的状态。&lt;/p&gt;
&lt;p&gt;3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 &lt;strong&gt;establised&lt;/strong&gt; 状态。&lt;/p&gt;
&lt;p&gt;4、服务器收到 ACK 报文之后，也处于 &lt;strong&gt;establised 状态&lt;/strong&gt;，此时，双方以建立起了链接。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/2019060815530363.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-三次握手的作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-三次握手的作用&#34;&gt;#&lt;/a&gt; 1、三次握手的作用&lt;/h3&gt;
&lt;p&gt;三次握手的作用也是有好多的，多记住几个，保证不亏。例如：&lt;br&gt;
1、确认双方的接受能力、发送能力是否正常。&lt;br&gt;
2、指定自己的初始化序列号，为后面的可靠传送做准备。&lt;br&gt;
3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。&lt;/p&gt;
&lt;h3 id=&#34;2-isn是固定的吗&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-isn是固定的吗&#34;&gt;#&lt;/a&gt; 2、（ISN）是固定的吗？&lt;/h3&gt;
&lt;p&gt;三次握手的一个重要功能是客户端和服务端交换 ISN (Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-什么是半连接队列&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-什么是半连接队列&#34;&gt;#&lt;/a&gt; 3、什么是半连接队列&lt;/h3&gt;
&lt;p&gt;服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里在补充一点关于 SYN-ACK 重传次数的问题：　服务器发送完 SYN－ACK 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, …&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;4-三次握手过程中可以携带数据吗&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4-三次握手过程中可以携带数据吗&#34;&gt;#&lt;/a&gt; 4、三次握手过程中可以携带数据吗&lt;/h3&gt;
&lt;p&gt;很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。&lt;/p&gt;
&lt;p&gt;为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。&lt;br&gt;
而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。&lt;/p&gt;
&lt;h2 id=&#34;四次挥手&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#四次挥手&#34;&gt;#&lt;/a&gt; 四次挥手&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;四次挥手也一样，千万不要对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。然后结束，最好是说的详细一点，例如想下面这样就差不多了，要把每个阶段的状态记好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：&lt;/p&gt;
&lt;p&gt;1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于&lt;strong&gt; FIN_WAIT1&lt;/strong&gt; 状态。&lt;/p&gt;
&lt;p&gt;2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 &lt;strong&gt;CLOSE_WAIT&lt;/strong&gt; 状态。&lt;/p&gt;
&lt;p&gt;3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 &lt;strong&gt;LAST_ACK&lt;/strong&gt; 的状态。&lt;/p&gt;
&lt;p&gt;4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 &lt;strong&gt;TIME_WAIT&lt;/strong&gt; 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态&lt;/p&gt;
&lt;p&gt;5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20190608160051238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtaXNwb3NzaWJsZQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里特别需要主要的就是 TIME_WAIT 这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。&lt;/p&gt;
&lt;p&gt;至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里我给出每个状态所包含的含义，有兴趣的可以看看。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;LISTEN - 侦听来自远方TCP端口的连接请求； &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;SYN-SENT -在发送连接请求后等待匹配的连接请求； &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;FIN-WAIT-2 - 从远程TCP等待连接中断请求；&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;CLOSE-WAIT - 等待从本地用户发来的连接中断请求； &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;CLOSING -等待远程TCP对连接中断的确认； &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;CLOSED - 没有任何连接状态；&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;最后，在放张三次握手与四次挥手的图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20190608160404569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RyZWFtaXNwb3NzaWJsZQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2020/12/16/HTTPS%E5%92%8CHTTP%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/</guid>
            <title>HTTPS和HTTP原理和区别</title>
            <link>http://example.com/2020/12/16/HTTPS%E5%92%8CHTTP%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/</link>
            <category>HTTP</category>
            <pubDate>Wed, 16 Dec 2020 22:08:28 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;一、HTTP 和 HTTPS 的基本概念&lt;br&gt;
 HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。&lt;/p&gt;
&lt;p&gt;HTTP 原理：&lt;/p&gt;
&lt;p&gt;①  客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是 80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。&lt;/p&gt;
&lt;p&gt;②  服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;HTTPS：是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如 TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。&lt;/p&gt;
&lt;p&gt;​​&lt;img data-src=&#34;https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;HTTPS 设计目标：&lt;/p&gt;
&lt;p&gt;(1) 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。&lt;/p&gt;
&lt;p&gt;(2) 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。&lt;/p&gt;
&lt;p&gt;(3) 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。&lt;/p&gt;
&lt;p&gt;二、HTTP 与 HTTPS  的区别&lt;br&gt;
 1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是 http，而网易邮箱是 https 。)&lt;/p&gt;
&lt;p&gt;2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。&lt;/p&gt;
&lt;p&gt;3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。&lt;/p&gt;
&lt;p&gt;4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)&lt;/p&gt;
&lt;p&gt;三、HTTPS 相对于 HTTP 的改进&lt;br&gt;
双向的身份认证&lt;/p&gt;
&lt;p&gt;客户端和服务端在传输数据之前，会通过基于 X.509 证书对双方进行身份认证 。具体过程如下：&lt;/p&gt;
&lt;p&gt;客户端发起 SSL 握手消息给服务端要求连接。&lt;/p&gt;
&lt;p&gt;服务端将证书发送给客户端。&lt;/p&gt;
&lt;p&gt;客户端检查服务端证书，确认是否由自己信任的证书签发机构签发 (客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。&lt;/p&gt;
&lt;p&gt;服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。&lt;/p&gt;
&lt;p&gt;(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。&lt;/p&gt;
&lt;p&gt;(3) 客户端内置的是 CA 的根证书 (Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。&lt;/p&gt;
&lt;p&gt;数据传输的机密性&lt;/p&gt;
&lt;p&gt;客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端，其中包含自己支持的非对成加密的密钥交换算法 (一般是 RSA)，数据签名摘要算法 ( 一般是 SHA 或者 MD5) ，加密传输数据的对称加密算法 ( 一般是 DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。&lt;/p&gt;
&lt;p&gt;防止重放攻击&lt;/p&gt;
&lt;p&gt;SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。&lt;/p&gt;
&lt;p&gt;可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。&lt;/p&gt;
&lt;p&gt;四、HTTPS 的优点&lt;br&gt;
 1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。&lt;/p&gt;
&lt;p&gt;2、HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。&lt;/p&gt;
&lt;p&gt;3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。&lt;/p&gt;
&lt;p&gt;五、HTTPS 的缺点（对比优点）&lt;br&gt;
1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。&lt;/p&gt;
&lt;p&gt;2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。&lt;/p&gt;
&lt;p&gt;3、HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。&lt;/p&gt;
&lt;p&gt;4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。&lt;/p&gt;
&lt;p&gt;5、成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。&lt;/p&gt;
&lt;p&gt;6、HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。&lt;/p&gt;
&lt;p&gt;六、HTTPS 的连接过程&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20180709141944471&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图片中的过程是按 8 个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。&lt;/p&gt;
&lt;p&gt;① 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。&lt;/p&gt;
&lt;p&gt;② 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。&lt;/p&gt;
&lt;p&gt;③ 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 “发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。&lt;/p&gt;
&lt;p&gt;④ 用户端随机产生一个用于通讯的 “对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的 “预主密码” 传给服务器。&lt;/p&gt;
&lt;p&gt;⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。&lt;/p&gt;
&lt;p&gt;⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA  是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。&lt;/p&gt;
&lt;p&gt;⑦ 服务器和客户端用相同的对称加密密钥，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。&lt;/p&gt;
&lt;p&gt;⑧ 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。&lt;/p&gt;
&lt;p&gt;⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。&lt;/p&gt;
&lt;p&gt;⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。&lt;/p&gt;
&lt;p&gt;上述的过程需要弄懂的核心思想&lt;br&gt;
客户端解析证书&lt;/p&gt;
&lt;p&gt;这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个对称加密密钥，然后用公钥对该密钥进行非对称加密。&lt;/p&gt;
&lt;p&gt;传送加密信息&lt;/p&gt;
&lt;p&gt;这部分传送的是用公钥加密后的对称加密密钥，目的就是让服务端得到这个密钥，以后客户端和服务端的通信就可以通过这个密钥来进行加密解密了。&lt;/p&gt;
&lt;p&gt;服务端解密信息&lt;/p&gt;
&lt;p&gt;服务端用非对称加密算法里的私钥解密后，得到了客户端传过来的对称加密算法的私钥，然后把之后传输的内容通过该值进行对称加密。&lt;/p&gt;
&lt;p&gt;为什么用非对称加密协商对称加密密钥&lt;/p&gt;
&lt;p&gt;对称加密的特点：对称密码体制中只有一种密钥，并且是非公开的。如果要解密就得让对方知道密钥，所以想要保证其安全性就要保证密钥的安全。&lt;/p&gt;
&lt;p&gt;非对称加密的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了，这样安全性就大了很多。&lt;/p&gt;
&lt;p&gt;非对称加密公钥和私钥的使用方法：(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。&lt;/p&gt;
&lt;p&gt;补充：&lt;br&gt;
SSL 提供服务&lt;br&gt;
 (1) 认证用户和服务器，确保数据发送到正确的客户机和服务器；&lt;/p&gt;
&lt;p&gt;(2) 加密数据以防止数据中途被窃取；&lt;/p&gt;
&lt;p&gt;(3) 维护数据的完整性，确保数据在传输过程中不被改变。&lt;/p&gt;
&lt;p&gt;SSL 工作流程&lt;br&gt;
服务器认证阶段：&lt;/p&gt;
&lt;p&gt;(1) 客户端向服务器发送一个开始信息 “Hello” 以便开始一个新的会话连接；&lt;/p&gt;
&lt;p&gt;(2) 服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的 “Hello” 信息时将包含生成主密钥所需的信息；&lt;/p&gt;
&lt;p&gt;(3) 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；&lt;/p&gt;
&lt;p&gt;(4) 服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。&lt;/p&gt;
&lt;p&gt;用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。&lt;/p&gt;
&lt;p&gt;SSL 协议提供的安全通道有以下三个特性：&lt;/p&gt;
&lt;p&gt;机密性：SSL 协议使用密钥加密通信数据。&lt;/p&gt;
&lt;p&gt;可靠性：服务器和客户都会被认证，客户的认证是可选的。&lt;/p&gt;
&lt;p&gt;完整性：SSL 协议会对传送的数据进行完整性检查。&lt;/p&gt;
&lt;p&gt;服务器证书 (server certificates) 是 SSL 数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成 Web 服务器的 SSL 安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户提供验证您 Web 站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2019/03/20/%E5%AD%A6%E4%B9%A0%E4%B9%8BAJAX/</guid>
            <title>学习之AJAX</title>
            <link>http://example.com/2019/03/20/%E5%AD%A6%E4%B9%A0%E4%B9%8BAJAX/</link>
            <category>AJAX</category>
            <pubDate>Wed, 20 Mar 2019 23:13:48 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;对于 AJAX 这个玩意儿，一开始学习的时候，根本不知道这是什么，我连 AJAX 有什么作用，是干什么的都不知道，所以在一开始学习这个的时候是非常蒙 B 的状态。那么在学习一段时间的 AJAX 之后，我总结了一些我自己对 AJAX 的理解，一起共勉。&lt;/p&gt;
&lt;p&gt;一、页面访问方式&lt;/p&gt;
&lt;p&gt;在学习 AJAX 之前，我们首先就需要了解页面的访问方式。页面的访问方式有如下两种同步访问和异步访问：&lt;/p&gt;
&lt;p&gt;①同步访问：在访问服务器时，只能等待服务器的响应，不能做其他事情。&lt;/p&gt;
&lt;p&gt;②异步访问：在向服务器发送请求时，不耽误用户在网页其他操作。相当于在同一时间，用户能做多个事情。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;光从字面上理解同步和异步不算太难，下面我为用图打个比方有助于更加深层次的理解同步和异步：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20170730181503984&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图反之是同步访问的图解，异步访问我就不再作图了，反之，你想买煎饼和稀饭，你走到卖煎饼的铺子时候，老板说：好的，你的煎饼 5 分钟后好，你可以 5 分钟后过来拿。这个时候你就可以在这五分钟去买你要的稀饭，这就是异步访问。&lt;/p&gt;
&lt;p&gt;二、什么是 AJAX&lt;/p&gt;
&lt;p&gt;AJAX 的英文全名是：Asynchronous  Javascript  And  Xml&lt;/p&gt;
&lt;p&gt;异步的  JS     和    xml&lt;/p&gt;
&lt;p&gt;其中的本质：使用 JS 中 XMLHttpRequext (xhr) 对象异步的向服务器发送请求，服务器响应回来的部分数据而不是原完整的页面，并可以以 “无刷新” 的效果来更改页面中的局部内容。为了方便理解，作以下用户名验证的例子图助于理解：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/20170730183958321&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;三、获取ＡＪＡＸ对象　——XMLHttpRequest&lt;/p&gt;
&lt;p&gt;在主流浏览器中：new　XMLHttpRequest ( );&lt;/p&gt;
&lt;p&gt;注意：在 IE8 以下的浏览器不支持 XMLHttpRequest&lt;/p&gt;
&lt;p&gt;在 IE8 以下的浏览器中：&lt;/p&gt;
&lt;p&gt;new  ActiveXObject(“Microsoft.XMLHttp”);&lt;/p&gt;
&lt;p&gt;tip: 如果想测试你使用的浏览器是否支持 XMLHttpRequest，可以进行如下操作：&lt;/p&gt;
&lt;p&gt;1. 打开你的浏览器，例如谷歌、360、火狐、欧朋…;&lt;/p&gt;
&lt;p&gt;2. 按 F12，使用开发者工具，在 console 一栏中输入：console.log (window.XMLHttpRequest);&lt;/p&gt;
&lt;p&gt;3. 如果浏览器不支持 XMLHttpRequest, 以上会打印 null。&lt;/p&gt;
&lt;p&gt;// 创建 ajax 对象&lt;/p&gt;
&lt;p&gt;var  xhr;&lt;/p&gt;
&lt;p&gt;if(window.XMLHttpRequest){&lt;/p&gt;
&lt;p&gt;xhr = new  XMLHttpRequest();&lt;/p&gt;
&lt;p&gt;}else{&lt;/p&gt;
&lt;p&gt;xhr = new ActiveXObject(“Microsoft.XMLHttp”);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;tip：这段函在编写代码的时候使用的次数很多，通常我们将它封装成函数单独创建一个 JS 文件，命名为 common.js，要使用的时候调用者个 js 文件就可以了。&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
