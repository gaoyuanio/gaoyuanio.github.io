{
    "version": "https://jsonfeed.org/version/1",
    "title": "浅岛夏风 • All posts by \"javascript\" category",
    "description": "一枚微不足道的前端攻城狮",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/03/31/JavaScript%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/",
            "url": "http://example.com/2021/03/31/JavaScript%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/",
            "title": "JavaScript专题（一）变量与函数提升",
            "date_published": "2021-03-31T03:13:22.000Z",
            "content_html": "<h2 id=\"一-有趣的现象\"><a class=\"markdownIt-Anchor\" href=\"#一-有趣的现象\">#</a> 一、有趣的现象</h2>\n<p>按照大家的常识，JavaScript 代码在执行是一定是自上而下的，你需要输出一个字符串，当然需要提前声明一个 <code>保存string类型的变量</code> 。如果深奥的道理我都能懂，于是我阅读了下面的代码。</p>\n<h3 id=\"11-我以为的开局\"><a class=\"markdownIt-Anchor\" href=\"#11-我以为的开局\">#</a> 1.1 我以为的开局</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;123&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n<p>我们调换一下代码的位置在再看：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p><strong>我好像找到规律了！！！</strong></p>\n<p>当我看完了前两段代码并且进行了 “深度思考” 后，我好像找到规律了，那就是：在当前代码块后函数中，在变量声明和初始化 <code>之前</code> 使用变量，会拿不到正确的值。</p>\n<h3 id=\"12-实际上是这样的\"><a class=\"markdownIt-Anchor\" href=\"#12-实际上是这样的\">#</a> 1.2 实际上是这样的</h3>\n<p>带着上面的 “结论” 我来到了这里</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> val = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val); <span class=\"comment\">// 高原</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>果然如此！，在<strong>变量声明和初始化之后</strong>耶稣也阻挡不了我拿到 val 的值，我说的！！！</p>\n<p>当我看到下面一段代码时，我已经产生了动摇，此事必要蹊跷。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> val = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(val); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> val = <span class=\"string\">&#x27;测试&#x27;</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这… 我怂了，是什么原因导致这样的现象发生的呢？Js 又是如果处理的呢？</p>\n<h2 id=\"二-js的预解析\"><a class=\"markdownIt-Anchor\" href=\"#二-js的预解析\">#</a> 二、Js 的预解析</h2>\n<p>在当前的作用域内，无论在哪里变量声明，在幕后，都会进行一次看不见的移动。</p>\n<p>注意：<strong>仅声明被 “移动”</strong>。即声明和赋值在某些时候被动分开了。而这次看不见的移动实际上就是 <code>Js在编译阶段的解析</code> 。</p>\n<p>来看一段《你知不知道的 Js》中经典的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = <span class=\"string\">&#x27;高原&#x27;</span>; <span class=\"comment\">// 未添加关键字（未声明），name为全局变量，，即window.name = &#x27;高原&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name; <span class=\"comment\">// 再次声明name，此时name未进行初始化，它的值是undefined吗？</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// ？</span></span><br></pre></td></tr></table></figure>\n<p>结果是成功打印 “高原”，这样<strong>看不见的移动</strong>就发生在 Js 预解析（编译）之中。</p>\n<h3 id=\"21-核心预解析\"><a class=\"markdownIt-Anchor\" href=\"#21-核心预解析\">#</a> 2.1 核心：预解析</h3>\n<p>为了搞明白这个核心问题，我们需要回顾一下，引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。</p>\n<p>因此，发生这样的事情，包括 <code>变量</code> 和 <code>函数</code> 在内的所有声明都会在任何代码被执行前首先被处理。当你看到 <code>var a = 2</code> ；时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明：var a；和 a = 2;。</p>\n<ul>\n<li>第一个定义声明是在编译阶段进行的。</li>\n<li>第二个赋值声明会被留在原地等待执行阶段。</li>\n</ul>\n<p>即代码是这样写的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们看到的代码：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>但 Js 会将它解析成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明(Declaration)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name; <span class=\"comment\">// 声明但未初始化，所以分配 undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化(Initialization)</span></span><br><span class=\"line\">name = <span class=\"string\">&#x27;高原&#x27;</span>; <span class=\"comment\">// 初始化（赋值）</span></span><br></pre></td></tr></table></figure>\n<p>所以本小结的一段代码应该这样分析：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name; <span class=\"comment\">// 声明name提到作用域顶部，并被分配了一个undefined</span></span><br><span class=\"line\">name = <span class=\"string\">&#x27;高原&#x27;</span>; <span class=\"comment\">// 进行初始化操作</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// &#x27;高原&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"22-注意只有声明被提升了\"><a class=\"markdownIt-Anchor\" href=\"#22-注意只有声明被提升了\">#</a> 2.2 注意：只有声明被提升了</h3>\n<p><strong>只有声明会被提升，而赋值和其他代码逻辑会在执行到代码的位置时才会生效</strong>。所以会有下面的问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数被提升了，自然可以正常执行，但变量仅仅是声明被提升了。</p>\n<h3 id=\"23-每个作用域都会进行提升操作\"><a class=\"markdownIt-Anchor\" href=\"#23-每个作用域都会进行提升操作\">#</a> 2.3 每个作用域都会进行提升操作</h3>\n<p>还是上面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际它在编译时是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name; <span class=\"comment\">// 声明</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    name = <span class=\"string\">&#x27;高原&#x27;</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 函数执行</span></span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200716134005198.jpg\" alt=\"img\"></p>\n<h2 id=\"三-提升之间的优先级\"><a class=\"markdownIt-Anchor\" href=\"#三-提升之间的优先级\">#</a> 三、提升之间的优先级</h2>\n<p>既然我们知道了 <code>变量</code> 和 <code>函数</code> 会被提升，他们之间又是如何判断优先级的呢？</p>\n<h3 id=\"31-函数会被首先提升然后才是变量\"><a class=\"markdownIt-Anchor\" href=\"#31-函数会被首先提升然后才是变量\">#</a> 3.1 函数会被首先提升，然后才是变量</h3>\n<p>我们分析下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;高原&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;小李&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本着函数优先提升的原则，他会被解析成这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;高原&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 高原</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;小李&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意， <code>var foo</code>  因为是一个重复声明，且优先级 <code>低于函数声明</code> 所以它被忽略掉了。</p>\n<h3 id=\"32-函数字面量不会进行函数提升\"><a class=\"markdownIt-Anchor\" href=\"#32-函数字面量不会进行函数提升\">#</a> 3.2 函数字面量不会进行函数提升</h3>\n<p>最直观的例子，就是在函数字面量前调用该函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// TypeError: foo is not a function</span></span><br></pre></td></tr></table></figure>\n<p>这段程序中：</p>\n<ol>\n<li>变量标识符 <code>foo()</code>  被提升并分配给所在作用域（在这里是全局作用域），因此 foo ()<strong> 不会导致 ReferenceError</strong>。</li>\n<li>然后就是执行 foo，foo 此时并没有赋值（注意变量被提升了）。由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。</li>\n</ol>\n<h2 id=\"四-es6和小结\"><a class=\"markdownIt-Anchor\" href=\"#四-es6和小结\">#</a> 四、ES6 和小结</h2>\n<p>ES6 新增了两个命令 <code>let</code>  和 <code>const</code> ，用来声明变量，有关它们完整的概念我会在《ES6 基础系列》中总结，提起它们，是因为<strong>变量提升在它们身上不会存在</strong>。</p>\n<h3 id=\"41-变量提升是可以规避的\"><a class=\"markdownIt-Anchor\" href=\"#41-变量提升是可以规避的\">#</a> 4.1 变量提升是可以规避的</h3>\n<p>let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let 的情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，变量 foo 用 var 命令声明，会发生变量提升，即脚本开始运行时，变量 foo 已经存在了，但是没有值，所以会输出 undefined。变量 bar 用 let 命令声明，不会发生变量提升。这表示在声明它之前，变量 bar 是不存在的，这时如果用到它，就会抛出一个错误。</p>\n<p>在变量提升上，const 和 let 一样，只在声明所在的块级作用域内有效，也不会变量提升</p>\n<h3 id=\"42-小结\"><a class=\"markdownIt-Anchor\" href=\"#42-小结\">#</a> 4.2 小结</h3>\n<ol>\n<li>变量提升：函数声明和变量声明总是会被解释器悄悄地被 &quot;提升&quot; 到方法体的最顶部，但变量的初始化不会提升；</li>\n<li>函数提升：函数声明可以被看作是函数的整体被提升到了代码的顶部，但函数字面量表达式并不会引发函数提升；</li>\n<li>函数提升优先与变量提升；</li>\n<li>let 和 const 可以有效的规避变量提升</li>\n</ol>\n<p>最后提炼一下《你不知道的 JS》中的一段话：<strong>JavaScript 引擎并不总是按照代码的顺序来进行解析。在编译阶段，无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理，这个过程被称为提升。声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</strong></p>\n",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://example.com/2021/03/26/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
            "url": "http://example.com/2021/03/26/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
            "title": "JavaScript基础（六）基本数据类型",
            "date_published": "2021-03-26T03:20:16.000Z",
            "content_html": "<h2 id=\"一-类型\"><a class=\"markdownIt-Anchor\" href=\"#一-类型\">#</a> 一、类型</h2>\n<p>可能许多习惯了 C++、C# 这类静态语言（强类型）语言的小伙伴们在编写 Js 代码时，会很不习惯，因为相对于静态语言来说，Js 甚至没有类型的” 概念 “。</p>\n<p>而且 Js 中吐槽较多的恰恰就包含类型转换，在我们日常写代码时总是遇到或显示或隐示的类型转换，比如：</p>\n<p>你要获取数字 <code>123</code>  的个位十位百位，你会怎么做？</p>\n<ul>\n<li>toSrting () 后通过下标获取？</li>\n<li>取整取余？</li>\n</ul>\n<p>使用类型转换形式多样。有些方式简明易懂，也很安全，然而稍不留神，就会出现意想不到的结果。</p>\n<p>为了学习和掌握类型转换，现在先让我们来深入了解一下值和类型。</p>\n<span id=\"more\"></span>\n<h3 id=\"内置类型\"><a class=\"markdownIt-Anchor\" href=\"#内置类型\">#</a> 内置类型</h3>\n<p>JavaScript 拥有<strong>动态类型</strong>，这意味着相同的变量可用作不同的类型：类型是值的内部特征，它定义了值的行为，以使其区别于其他值。</p>\n<p><strong>JavaScript 中的内置类型:</strong></p>\n<ul>\n<li>null</li>\n<li>undefined</li>\n<li>布尔值（boolean）</li>\n<li>数字（number）</li>\n<li>字符串（string）</li>\n<li>对象（Object）</li>\n<li>symbol（ES6 新增）</li>\n</ul>\n<p>对于 null 和 undefined 大家一定不陌生，我们会在第三节简单的分析他们之前的区别。</p>\n<h2 id=\"二-数据类型分类\"><a class=\"markdownIt-Anchor\" href=\"#二-数据类型分类\">#</a> 二、数据类型分类</h2>\n<p>除了<strong>对象</strong>，其他几个都是<strong>基本类型</strong>，这是因为声明变量时不同的内存分配而决定的：</p>\n<h3 id=\"21-基本类型\"><a class=\"markdownIt-Anchor\" href=\"#21-基本类型\">#</a> 2.1 基本类型</h3>\n<p>JavaScript 中共有 6 种基本数据类型： <code>Undefined</code> 、 <code>Null</code> 、 <code>Boolean</code> 、 <code>Number</code> 、 <code>String</code> 、 <code>Symbol</code> 。</p>\n<p><code>基本类型</code> 存储在 <code>栈（stack）中</code> ，也就是说：</p>\n<ul>\n<li>它们的值<strong>直接存储在变量访问的位置</strong>。</li>\n<li>这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 –  <code>栈</code> 中。</li>\n<li>这样存储便于迅速查寻变量的值。</li>\n<li>基本类型的值是按值访问的，且基本类型的值是不可变的。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;123hello321&quot;</span>;</span><br><span class=\"line\">str.toUpperCase();     <span class=\"comment\">// 123HELLO321</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str);      <span class=\"comment\">// 123hello321</span></span><br></pre></td></tr></table></figure>\n<p><strong>基本类型的比较是它们的值的比较：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a == b);    <span class=\"comment\">// == 只进行值的比较</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b);   <span class=\"comment\">// === 不仅进行值得比较，还要进行数据类型的比较</span></span><br></pre></td></tr></table></figure>\n<p>有关符号运算，优先级的问题，我觉得应该将它放在 Js 专题系列，单独讨论它们才能比较透彻，这里就不过多解释了。</p>\n<p>来看下面的代码，我们用图示来分析它</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a,b</span><br><span class=\"line\">a = <span class=\"number\">100</span>;</span><br><span class=\"line\">b = a;</span><br><span class=\"line\">a = <span class=\"string\">&#x27;字符串&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200707105321216.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"22-引用类型\"><a class=\"markdownIt-Anchor\" href=\"#22-引用类型\">#</a> 2.2 引用类型</h3>\n<p><code>引用类型</code> 存储在 <code>堆（heap）</code> 中的对象，也就是说:</p>\n<ul>\n<li>存储在变量处的值是一个指针（point），指向存储对象的内存地址。</li>\n<li>引用类型的值是按引用访问的，且引用类型的值是 <code>可变</code> 的。</li>\n<li>变量存储的是可以打开保存数据的房间的 <code>钥匙</code></li>\n<li><code>存储钥匙地址</code> 的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</li>\n</ul>\n<p>除过上面的 6 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，有：</p>\n<ul>\n<li>Object</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Function</li>\n<li>…</li>\n</ul>\n<p><strong>引用类型的比较是引用的比较：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;&#125;;    <span class=\"comment\">// 新建一个空对象 obj1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;&#125;;    <span class=\"comment\">// 新建一个空对象 obj2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 == obj2);    <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1 === obj2);   <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>因为 obj1 和 obj2 分别引用的是存放在堆内存中的 2 个不同的对象，故变量 obj1 和 obj2 的值（引用地址）也是不一样的！</p>\n<p>来看下面的代码，我们用图示来分析它</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;高原&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b;</span><br><span class=\"line\">b = a;</span><br><span class=\"line\">a.name = <span class=\"string\">&quot;gaoyuan&quot;</span>;</span><br><span class=\"line\">b.age = <span class=\"number\">23</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;高原&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">23</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200707114641540.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"23-小结\"><a class=\"markdownIt-Anchor\" href=\"#23-小结\">#</a> 2.3 小结</h3>\n<p><strong>基本类型</strong></p>\n<ul>\n<li>栈内存中包括了变量的标识符和变量的值</li>\n</ul>\n<p><strong>引用类型</strong></p>\n<ul>\n<li>栈内存中保存了变量标识符和指向堆内存中该对象的指针</li>\n<li>堆内存中保存了对象的内容</li>\n<li></li>\n</ul>\n<h2 id=\"三-常见问题\"><a class=\"markdownIt-Anchor\" href=\"#三-常见问题\">#</a> 三、常见问题</h2>\n<h3 id=\"31-javascript中的变量是没有类型的\"><a class=\"markdownIt-Anchor\" href=\"#31-javascript中的变量是没有类型的\">#</a> 3.1 JavaScript 中的变量是没有类型的</h3>\n<p>来看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>; <span class=\"comment\">// 严格地说 变量a没有类型，它所保存的 100是数字类型的</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a === <span class=\"string\">&#x27;number&#x27;</span>; <span class=\"comment\">// 其实检测是=&gt;typeof 100</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"string\">&#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a === <span class=\"string\">&#x27;string&#x27;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>变量a</code>  可以随时持有任何类型的 <code>值</code> 。换个角度来理解就是，JavaScript 不做 “类型强制”；也就是说，语言引擎不要求变量总是持有与其初始值同类型的值。</p>\n<h3 id=\"32-typeof检测不总是对的\"><a class=\"markdownIt-Anchor\" href=\"#32-typeof检测不总是对的\">#</a> 3.2 typeof 检测不总是对的</h3>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200706185843137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>需要注意的点：</p>\n<p><strong>number</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本数学API和属性</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Math</span>.LN2 === <span class=\"string\">&#x27;number&#x27;</span>; <span class=\"comment\">// true  Math的属性</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">Infinity</span> === <span class=\"string\">&#x27;number&#x27;</span>; <span class=\"comment\">// true 无穷</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">NaN</span> === <span class=\"string\">&#x27;number&#x27;</span>; <span class=\"comment\">// true 特殊的数字类型，not a number</span></span><br><span class=\"line\"><span class=\"comment\">// 被强转称数字的其他数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Number</span>(<span class=\"string\">&#x27;str&#x27;</span>) === <span class=\"string\">&#x27;number&#x27;</span>; <span class=\"comment\">// Number(&#x27;str&#x27;) =&gt; NaN =&gt; number</span></span><br></pre></td></tr></table></figure>\n<p><strong>string</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> (<span class=\"keyword\">typeof</span> <span class=\"number\">1</span>) === <span class=\"string\">&#x27;string&#x27;</span>; <span class=\"comment\">// typeof always returns a string</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">String</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;string&#x27;</span>; <span class=\"comment\">// 强转成字符串</span></span><br></pre></td></tr></table></figure>\n<p><strong>布尔值</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;boolean&#x27;</span>; <span class=\"comment\">// 强制类型转换</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> !!(<span class=\"number\">1</span>) === <span class=\"string\">&#x27;boolean&#x27;</span>; <span class=\"comment\">// two calls of the ! (logical NOT) operator are equivalent to Boolean()</span></span><br></pre></td></tr></table></figure>\n<p><strong>Symble</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span>() === <span class=\"string\">&#x27;symbol&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span>(<span class=\"string\">&#x27;foo&#x27;</span>) === <span class=\"string\">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><strong>undefined</strong></p>\n<p>一个没有被赋值的变量的数据类型是 <code>undefined</code>  (如果方法或者是语句中操作的变量没有被赋值，则会返回 undefined) —— MDN</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> === <span class=\"string\">&#x27;undefined&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>object</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;高原&#x27;</span> &#125; === <span class=\"string\">&#x27;object&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>null</strong></p>\n<p>值得我们注意恰恰是这个 <code>null</code> ,typeof 对它的处理返回的是 <code>object</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> === <span class=\"string\">&#x27;object&#x27;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><strong>function</strong></p>\n<p>typeof 检测函数返回的也是 object，这是因为从规范上看 <code>function</code>  实际上是 <code>object</code>  的一个子类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Functions</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125; === <span class=\"string\">&#x27;function&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;&#125; === <span class=\"string\">&#x27;function&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>那么你还知道其他检测数据类型的方式吗？</p>\n<h3 id=\"33-null和undefined\"><a class=\"markdownIt-Anchor\" href=\"#33-null和undefined\">#</a> 3.3 null 和 undefined</h3>\n<ul>\n<li>\n<p>null：特指对象的值未设置。它是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JavaScript 基本类型</span><br></pre></td></tr></table></figure>\n<p>之一。</p>\n<ul>\n<li>它不是全局对象的一个属性；</li>\n<li>在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。</li>\n</ul>\n</li>\n<li>\n<p>undefined：表示声明但未被赋值的变量类型</p>\n<ul>\n<li>你可以使用 <code>undefined</code>  和严格相等或不相等操作符来决定一个变量是否拥有值。</li>\n</ul>\n</li>\n</ul>\n<p><strong>他们的区别：</strong></p>\n<p>当检测 null 或 undefined 时，注意相等  <code>==</code>  与 <code>===</code>  两个操作符的区别 ，前者会执行类型转换：</p>\n<ul>\n<li>typeof 检测时两者的返回值不同</li>\n<li>代表的含义不同</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>        <span class=\"comment\">// &quot;object&quot; (因为一些以前的原因而不是&#x27;null&#x27;)</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>   <span class=\"comment\">// &quot;undefined&quot;</span></span><br><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">undefined</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"literal\">null</span>  == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> === <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">!<span class=\"literal\">null</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"number\">1</span> + <span class=\"literal\">null</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"number\">1</span> + <span class=\"literal\">undefined</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://example.com/2021/03/25/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E9%97%AD%E5%8C%85/",
            "url": "http://example.com/2021/03/25/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E9%97%AD%E5%8C%85/",
            "title": "JavaScript基础（五）闭包",
            "date_published": "2021-03-25T02:54:14.000Z",
            "content_html": "<h2 id=\"一-什么是闭包\"><a class=\"markdownIt-Anchor\" href=\"#一-什么是闭包\">#</a> 一、什么是闭包</h2>\n<p>顾名思义，遇见问题先问为什么是我们一贯的思维方式，我们尝试回答一下：</p>\n<ol>\n<li>闭包就是函数内部的子函数 ——  <code>等于没说</code></li>\n<li>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。—— <code>靠谱</code></li>\n<li>闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁 —— <code>靠谱</code></li>\n<li>函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）—— <code>很靠谱</code></li>\n</ol>\n<p>我们试着用代码来描述一下上面的回答，看看你最<strong>中意</strong>哪一个～</p>\n<span id=\"more\"></span>\n<h3 id=\"11-闭包是函数内部的子函数\"><a class=\"markdownIt-Anchor\" href=\"#11-闭包是函数内部的子函数\">#</a> 1.1 闭包是函数内部的子函数</h3>\n<p>先看这段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>基于词法作用域的查找规则， <code>bar函数</code> 可以成功的打印 <code>a</code>  变量，并且它也是 <code>foo</code>  的子函数，但严格来说它并没有清晰的表达出闭包这一概念，说它表达的是<strong>嵌套函数可以访问声明于大外部作用域的变量</strong>更准确一些。</p>\n<h3 id=\"12-闭包就是能够读取其他函数内部变量的函数在本质上是函数内部和函数外部链接的桥梁\"><a class=\"markdownIt-Anchor\" href=\"#12-闭包就是能够读取其他函数内部变量的函数在本质上是函数内部和函数外部链接的桥梁\">#</a> 1.2 闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁</h3>\n<p>再来看下面的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = foo();</span><br><span class=\"line\">res(); <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>结果一致，这是因为此时 <code>res</code>  是执行 <code>foo</code>  函数时返回的 <code>bar</code>  引用，bar 函数得以保存了它饿词法环境。</p>\n<h3 id=\"13-函数和对其周围状态词法环境的引用捆绑在一起构成闭包closure\"><a class=\"markdownIt-Anchor\" href=\"#13-函数和对其周围状态词法环境的引用捆绑在一起构成闭包closure\">#</a> 1.3 函数和对其周围状态（词法环境）的引用捆绑在一起构成闭包（closure）</h3>\n<p>我们来看下面代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// gaoyuan</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">//gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>foo 的上下文被静态的保存了下来，而且是在该函数创建的时候就保存了。下面我们来验证一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// gaoyuan</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;老王&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    func()</span><br><span class=\"line\">&#125;)(foo); <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>这里我们就可以理解 —— 函数被创建后就形成了闭包，他们保存了上层上下文的作用域链，并且保存在 <code>[[scope]]</code>  中，如果你对 <code>[[scope]]</code>  的概念已经模糊了，不妨花几分钟看看《JavaScript 中的执行上下文》这篇文章。</p>\n<h3 id=\"14-总结\"><a class=\"markdownIt-Anchor\" href=\"#14-总结\">#</a> 1.4 总结</h3>\n<p><strong>注意：闭包是函数内部的返回的子函数这句话本身没错</strong>，但要看从什么角度出发：</p>\n<p>ECMAScript 中，闭包指的是：</p>\n<ol>\n<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>\n<li>从实践角度：以下函数才算是闭包：\n<ul>\n<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>\n<li>在代码中引用了自由变量</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结：</strong></p>\n<ul>\n<li>闭包代码块创建该代码块的上下文中数据的结合</li>\n<li>闭包就是能够读取其他函数内部变量的函数，在本质上是函数内部和函数外部链接的桥梁</li>\n<li>不同的角度对闭包的解释不同的</li>\n</ul>\n<p>注意：这些并不是闭包的全部，就好像当你被问到 —— 闭包是什么的时候，你的上述回答并不能结束这个话题，往往会引申出更多的话题。</p>\n<h2 id=\"二-尝试分析闭包\"><a class=\"markdownIt-Anchor\" href=\"#二-尝试分析闭包\">#</a> 二、尝试分析闭包</h2>\n<p>还是那段经典代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;global scope&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;local scope&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = checkscope();</span><br><span class=\"line\">foo(); <span class=\"comment\">// local scope</span></span><br></pre></td></tr></table></figure>\n<p>首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。</p>\n<ol>\n<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li>\n<li>全局执行上下文初始化</li>\n<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li>\n<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this 等</li>\n<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li>\n<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li>\n<li>f 执行上下文初始化，创建变量对象、作用域链、this 等</li>\n<li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li>\n</ol>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200628152924827.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>当  <code>f</code>  函数执行的时候， <code>checkscope</code>  函数上下文已经被销毁了啊 (即从执行上下文栈中被弹出)，怎么还会读取到  <code>checkscope</code>  作用域下的  <code>scope</code>  值呢？</p>\n<p>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：</p>\n<p>因为这个作用域链：</p>\n<ul>\n<li><code>f 函数</code> 依然可以读取到  <code>checkscopeContext.AO</code>  的值；</li>\n<li>当  <code>f 函数</code> 引用了  <code>checkscopeContext.AO</code>  中的值的时候，即使  <code>checkscopeContext</code>  被销毁了，JavaScript 依然会让  <code>checkscopeContext.AO</code>  活在内存中；</li>\n<li><code>f 函数</code> 依然可以通过  <code>f 函数</code> 的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</li>\n</ul>\n<p>多么浪漫的思想 —— 只要你需要我，那我我本应该被销毁，你也能找到我～</p>\n<h2 id=\"三-经典问题\"><a class=\"markdownIt-Anchor\" href=\"#三-经典问题\">#</a> 三、经典问题</h2>\n<h3 id=\"31-多个对象引用同一个scope你遇到过吗\"><a class=\"markdownIt-Anchor\" href=\"#31-多个对象引用同一个scope你遇到过吗\">#</a> 3.1 多个对象引用同一个 [[Scope]]，你遇到过吗？</h3>\n<p>直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> child1;</span><br><span class=\"line\"><span class=\"keyword\">var</span> child2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    child1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(++x)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    child2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(--x)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">parent();</span><br><span class=\"line\">child1(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">child1(); <span class=\"comment\">// 3</span></span><br><span class=\"line\">child2(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>大家可能不理解， <code>child1</code>  和 <code>child</code>  他们两个函数在创建后都保存了上层上下文，万万没想到，<strong>同一个上下文创建的闭包是共用一个 <code>[[scope]]</code>  属性的</strong>，某个闭包对其中 [[Scope]] 的变量做修改会影响到其他闭包对其变量的读取。</p>\n<h3 id=\"32-闭包轻松解决的经典问题\"><a class=\"markdownIt-Anchor\" href=\"#32-闭包轻松解决的经典问题\">#</a> 3.2 闭包轻松解决的经典问题</h3>\n<p>大家一定对下面这段代码很眼熟：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">    arr[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr[<span class=\"number\">0</span>](); <span class=\"comment\">// 10</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>](); <span class=\"comment\">// 10</span></span><br><span class=\"line\">arr[<span class=\"number\">2</span>](); <span class=\"comment\">// 10</span></span><br><span class=\"line\">arr[<span class=\"number\">3</span>](); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<p>我们这么解释它：<strong>同一个上下文中创建的闭包是共用一个 [[Scope]] 属性的</strong>。</p>\n<p>因此上层上下文中的变量 <code>i</code>  是可以很容易就被改变的。</p>\n<p>arr [0],arr [1]…arr [9] 他们共用一个 [[scope]]，最终执行的时候结果当然一样。</p>\n<p><strong>如何利用闭包来解决这个问题呢？</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">    arr[i] = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr[<span class=\"number\">0</span>](); <span class=\"comment\">// 0</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>](); <span class=\"comment\">// 1</span></span><br><span class=\"line\">arr[<span class=\"number\">2</span>](); <span class=\"comment\">// 2</span></span><br><span class=\"line\">arr[<span class=\"number\">3</span>](); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>我们通过立即执行匿名函数的方式隔离了作用域，当执行 arr [0] 函数的时候，arr [0] 函数的作用域链发生了改变：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr[<span class=\"number\">0</span>]Context = &#123;</span><br><span class=\"line\">    <span class=\"attr\">Scope</span>: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>匿名函数执行上下文的 AO 为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">匿名函数Context = &#123;</span><br><span class=\"line\">    <span class=\"attr\">AO</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">arguments</span>: &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"attr\">length</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">i</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到，这时函数的 <code>[[Scope]]</code>  属性就有了真正想要的值了，为了达到这样的目的，我们不得不在 <code>[[Scope]]</code>  中创建额外的变量对象。要注意的是，在返回的函数中，如果要获取 <code>i</code>  的值，那么该值还是会是 10。</p>\n<h3 id=\"33-总结\"><a class=\"markdownIt-Anchor\" href=\"#33-总结\">#</a> 3.3 总结</h3>\n<ul>\n<li>函数内的所有内部函数都共享一个父作用域，因此创建的闭包是共用的。</li>\n<li>利用闭包隔离作用域的特性可以解决共享作用域的问题</li>\n</ul>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=1200653736,2067630829&amp;fm=26&amp;gp=0.jpeg\" alt=\"\"></p>\n",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://example.com/2021/03/24/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/",
            "url": "http://example.com/2021/03/24/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/",
            "title": "JavaScript基础（四）立即调用函数",
            "date_published": "2021-03-24T01:37:26.000Z",
            "content_html": "<blockquote>\n<p>本篇文章，主要讲解的立即执行函数或自执行匿名函数的含义、用法、以及使用它的主要场景。系列的前面几篇文章主要讲解了作用域、原型，本篇文章一样起到了承上启下的作用，如果您感兴趣，不妨去看看哦～</p>\n</blockquote>\n<h2 id=\"一-了解立即调用函数表达式\"><a class=\"markdownIt-Anchor\" href=\"#一-了解立即调用函数表达式\">#</a> 一、了解立即调用函数表达式</h2>\n<h3 id=\"11-思维导图\"><a class=\"markdownIt-Anchor\" href=\"#11-思维导图\">#</a> 1.1 思维导图</h3>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200622113604893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<span id=\"more\"></span>\n<h3 id=\"12-什么是立即调用\"><a class=\"markdownIt-Anchor\" href=\"#12-什么是立即调用\">#</a> 1.2 什么是立即调用？</h3>\n<p>在详细了解这个之前，我们来谈了解一下 “自执行” 这个叫法，本文对这个功能的叫法也不一定完全对，每个人对他的理解都不一样，我们在这里用 <code>立即调用</code> ～</p>\n<p>立即调用：</p>\n<ul>\n<li>顾名思义，该表达式一被 <code>创建就立即执行</code> 。</li>\n<li>是一个在定义时就会立即执行的  <code>JavaScript 函数</code> 。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;x + x = &#x27;</span>, x + x);</span><br><span class=\"line\">&#125;)(<span class=\"number\">5</span>) <span class=\"comment\">// x + x = 10</span></span><br></pre></td></tr></table></figure>\n<p>这是一个被称为  <code>自执行匿名函数</code>  的设计模式，主要包含两部分:</p>\n<ol>\n<li>第一部分是包围在 圆括号运算符  <code>()</code>  里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</li>\n<li>第二部分再一次使用  <code>()</code>  创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</li>\n</ol>\n<h3 id=\"13-核心问题\"><a class=\"markdownIt-Anchor\" href=\"#13-核心问题\">#</a> 1.3 核心问题</h3>\n<p><strong>当你声明一个函数的时候，通过在后面加括号就可以实现立即执行吗？</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;(); <span class=\"comment\">// gaoyuan 成功了！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...是不是意味着后面加个括弧都可以自动执行？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;&#x27;</span>gaoyuan);</span><br><span class=\"line\">&#125;(); <span class=\"comment\">// Uncaught SyntaxError: Function statements require a function name</span></span><br><span class=\"line\"><span class=\"comment\">// 什么？还需要一个函数名？不是叫 自执行匿名函数吗？</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我加上了函数名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;(); <span class=\"comment\">// Uncaught SyntaxError: Unexpected token &#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>很显然，例子中的第二条和第三条确实报错了，而且报错内容不一样，那么问题出现在哪呢？</p>\n<h2 id=\"二-立即调用函数表达式报错了\"><a class=\"markdownIt-Anchor\" href=\"#二-立即调用函数表达式报错了\">#</a> 二、立即调用函数表达式报错了？</h2>\n<p>有时，我们定义函数之后，立即调用该函数，这时不能在函数的定义后面直接加圆括号，这会产生语法错误。产生语法错误的原因是， <code>function</code>  这个关键字，既可以当做语句，也可以当做表达式，比如下边：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语句</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了避免解析上的歧义，JS 引擎规定，如果 function 出现在行首，一律解析成语句。因此 JS 引擎看到行首是 function 关键字以后，认为这一段都是函数定义，不应该以 <code>括号结尾</code> ，在它看来 <code>括号</code> 只是分组操作符。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面这个function在语法上是没问题的，但是依然只是一个语句</span></span><br><span class=\"line\"><span class=\"comment\">// 加上括号()以后依然会报错，因为分组操作符需要包含表达式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">/* code */</span> &#125;(); <span class=\"comment\">// SyntaxError: Unexpected token )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是如果你在括弧()里传入一个表达式，将不会有异常抛出</span></span><br><span class=\"line\"><span class=\"comment\">// 但是foo函数依然不会执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">/* code */</span> &#125;( <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">/* code */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">( <span class=\"number\">1</span> );</span><br></pre></td></tr></table></figure>\n<h2 id=\"三-使用立即调用函数的正确姿势\"><a class=\"markdownIt-Anchor\" href=\"#三-使用立即调用函数的正确姿势\">#</a> 三、使用立即调用函数的正确姿势</h2>\n<p>要解决上述问题，非常简单。</p>\n<p>我们只需要用 <code>大括弧</code> 将代码的代码全部括住就行了，因为 JavaScript 里 <code>括弧()</code>  里面不能包含语句，所以在这一点上，解析器在解析 function 关键字的时候，会将相应的代码解析成 function 表达式，而不是 function 声明。</p>\n<h3 id=\"31-常见使用姿势\"><a class=\"markdownIt-Anchor\" href=\"#31-常见使用姿势\">#</a> 3.1 常见使用姿势</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面2个括弧()都会立即执行</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* code */</span> &#125; ()); <span class=\"comment\">// 推荐使用这个</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/* code */</span> &#125;)(); <span class=\"comment\">// 但是这个也是可以用的</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"32-不常见的使用姿势一\"><a class=\"markdownIt-Anchor\" href=\"#32-不常见的使用姿势一\">#</a> 3.2 不常见的使用姿势（一）</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的</span></span><br><span class=\"line\"><span class=\"comment\">// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>)</span><br><span class=\"line\">&#125;(); <span class=\"comment\">// gaoyuan</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>)</span><br><span class=\"line\">&#125;(); <span class=\"comment\">// gaoyuan</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>) &#125;(); <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"33-不常见的使用姿势二\"><a class=\"markdownIt-Anchor\" href=\"#33-不常见的使用姿势二\">#</a> 3.3 不常见的使用姿势（二）</h3>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果你不在意返回值，或者不怕难以阅读</span></span><br><span class=\"line\"><span class=\"comment\">// 你甚至可以在function前面加一元操作符号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//转bool</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res1 = !<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;res1:&#x27;</span>, res1); <span class=\"comment\">// gaoyuan true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转数字</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res2 = +<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;res2:&#x27;</span>, res2); <span class=\"comment\">// gaoyuan NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按位非</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> res3 = ～<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;res3:&#x27;</span>, res3); <span class=\"comment\">// gaoyuan NaN</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"34-不常见的使用姿势三\"><a class=\"markdownIt-Anchor\" href=\"#34-不常见的使用姿势三\">#</a> 3.4 不常见的使用姿势（三）</h3>\n<p>还有一个情况，使用 new 和 void 关键字，不过不太常见罢了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;();</span><br></pre></td></tr></table></figure>\n<h2 id=\"四-常见使用场景\"><a class=\"markdownIt-Anchor\" href=\"#四-常见使用场景\">#</a> 四、常见使用场景</h2>\n<h3 id=\"41-隔离作用域\"><a class=\"markdownIt-Anchor\" href=\"#41-隔离作用域\">#</a> 4.1 隔离作用域</h3>\n<p>IIFE 最常见的功能，就是隔离作用域，在 ES6 之前 JS 原生也没有块级作用域的概念，所以需要函数作用域来模拟。</p>\n<p>举例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currentTime = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> year  = time.getFullYear()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> month = time.getMonth()+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> date  = time.getDate();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hour  = time.getHours();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> min   = time.getMinutes();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> year + <span class=\"string\">&#x27;-&#x27;</span> + month + <span class=\"string\">&#x27;-&#x27;</span> + date + <span class=\"string\">&#x27; &#x27;</span> + hour + <span class=\"string\">&#x27;:&#x27;</span> + min;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>你仍然可以在其他地方声明同名变量～</p>\n<h3 id=\"42-惰性函数\"><a class=\"markdownIt-Anchor\" href=\"#42-惰性函数\">#</a> 4.2 惰性函数</h3>\n<p>DOM 事件添加中，为了兼容现代浏览器和 IE 浏览器，我们需要对浏览器环境进行一次判断：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> addEvent = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.addEventListener) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, el, fn</span>) </span>&#123;</span><br><span class=\"line\">            el.addEventListener(type, fn, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.attachEvent) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, el, fn</span>) </span>&#123;</span><br><span class=\"line\">            el.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + type, fn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"43-用闭包保存状态\"><a class=\"markdownIt-Anchor\" href=\"#43-用闭包保存状态\">#</a> 4.3 用闭包保存状态</h3>\n<p>这里我仅举个例子，为我的下一篇文章 ——《JavaScript 中的闭包》卖个关子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elems = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; elems.length; i++) &#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">lockedInIndex</span>) </span>&#123;</span><br><span class=\"line\">        elems[i].addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            e.preventDefault();</span><br><span class=\"line\">            alert(<span class=\"string\">&#x27;I am link #&#x27;</span> + lockedInIndex);</span><br><span class=\"line\">        &#125;, <span class=\"string\">&#x27;false&#x27;</span>);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意\"><a class=\"markdownIt-Anchor\" href=\"#注意\">#</a> 注意</h3>\n<p>当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Barry&quot;</span>;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// 无法从外部访问变量 name</span></span><br><span class=\"line\">name <span class=\"comment\">// 抛出错误：&quot;Uncaught ReferenceError: name is not defined&quot;</span></span><br></pre></td></tr></table></figure>\n<p>将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Barry&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// IIFE 执行后返回的结果：</span></span><br><span class=\"line\">result; <span class=\"comment\">// &quot;Barry&quot;</span></span><br></pre></td></tr></table></figure>",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://example.com/2021/03/23/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F/",
            "url": "http://example.com/2021/03/23/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%9C%E7%94%A8%E5%9F%9F/",
            "title": "JavaScript基础（三）作用域",
            "date_published": "2021-03-23T03:00:57.000Z",
            "content_html": "<blockquote>\n<p>作用域的篇幅不会太长，作为自己对 Js 总结的第三篇文章，主要是承上启下。 之后会涉及到执行上下文，闭包等相关专题，为了避免内容过多，作用域这一部分单独总结。</p>\n</blockquote>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/%E4%B8%8B%E8%BD%BD.jpeg\" style=\"zoom:67%;\" />\n<span id=\"more\"></span>\n<h2 id=\"一-作用域的定义\"><a class=\"markdownIt-Anchor\" href=\"#一-作用域的定义\">#</a> 一、作用域的定义</h2>\n<p><strong>一张导图概括本节内容</strong> <img data-src=\"https://img-blog.csdnimg.cn/20200609102448438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"> <strong>1.1 常见的解释</strong></p>\n<ol>\n<li>一段程序代码中所用到的<strong>名字</strong>并不总是有效，而限定它的可用性的范围就是这个名字的作用域；</li>\n<li>作用域规定了<strong>如何查找变量</strong>，也就是确定当前执行代码对变量的访问权限；</li>\n<li>通俗的讲作用域就是<strong>一套规则</strong>，用于确定在何处以及如何查找<strong>某个变量</strong>的规则</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// a is not defined a变量并不是任何地方都可以被找到的</span></span><br></pre></td></tr></table></figure>\n<p><strong>1.2 JavaScript 中作用域工作模型</strong></p>\n<p>JavaScript 采用是词法作用域 (lexical scoping)，也就是静态作用域：</p>\n<ul>\n<li>函数的作用域在函数定义的时候就决定了</li>\n</ul>\n<p>与之对应的还有一个动态作用域：</p>\n<ul>\n<li>函数的作用域是在函数调用的时候才决定的；</li>\n</ul>\n<p><strong>1.3 全局变量和局部变量</strong></p>\n<p>根据定义变量的方式又可以分为：</p>\n<p>局部变量：只能在函数中访问，该函数外不可访问；</p>\n<ul>\n<li>定义在函数中的变量</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;高原&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// ？</span></span><br><span class=\"line\">fn(); <span class=\"comment\">// ？</span></span><br></pre></td></tr></table></figure>\n<p>全局：任何地方都能访问到的对象拥有全局作用域。</p>\n<ul>\n<li>函数外定义的变量</li>\n<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a1-&#x27;</span>,a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\ta = <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a2-&#x27;</span>,a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a3-&#x27;</span>,a);</span><br><span class=\"line\">fn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a4-&#x27;</span>,a);</span><br></pre></td></tr></table></figure>\n<p>注意：在 ES6 之后又提出了块级作用域，它们之间的区别我们之后再来讨论。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=2659298556,3987226078&amp;fm=26&amp;gp=0.jpeg\" alt=\"\"></p>\n<h2 id=\"二-理解作用域\"><a class=\"markdownIt-Anchor\" href=\"#二-理解作用域\">#</a> 二、理解作用域</h2>\n<p>根据第一节的描述，我们一一验证一下</p>\n<p><strong>2.1 理解词法作用域</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n<p>我们结合定义去分析：</p>\n<ul>\n<li>执行 <code>bar</code>  函数，函数内部形成了局部作用域；</li>\n<li>声明 value 变量，并赋值 2</li>\n<li>执行 <code>foo</code>  函数，函数 foo 的作用域内没有 <code>value</code>  这个变量，它会向外查找</li>\n<li>根据词法作用域的规则，函数定义时， <code>foo</code>  的外部作用域为全局作用域</li>\n<li>打印<strong>结果是 1</strong></li>\n</ul>\n<p>如果是动态作用域的话：结果<strong>就是 2</strong>，不知道你是否想明白了？</p>\n<p><strong>2.2 全局变量</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;全局变量&#x27;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(str+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">childFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(str+<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(str+<span class=\"number\">3</span>);</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t\tfn();</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tchildFn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func();</span><br><span class=\"line\"><span class=\"comment\">// 全局变量1</span></span><br><span class=\"line\"><span class=\"comment\">// 全局变量2</span></span><br><span class=\"line\"><span class=\"comment\">// 全局变量3</span></span><br></pre></td></tr></table></figure>\n<p>再来分析下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\ta = <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a1-&#x27;</span>,a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a2-&#x27;</span>,a);</span><br><span class=\"line\">fn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a3-&#x27;</span>,a);</span><br><span class=\"line\"><span class=\"comment\">// a2- 100 // 在当前作用域下查找变量a =&gt; 100</span></span><br><span class=\"line\"><span class=\"comment\">// a1- 1000 // 函数执行时，全局变量a已经被重新赋值</span></span><br><span class=\"line\"><span class=\"comment\">// a3- 1000 // 全局变量a =&gt; 1000</span></span><br></pre></td></tr></table></figure>\n<p><strong>2.3 局部作用域</strong></p>\n<p>局部作用域一般只在固定的代码片段内可访问到，最常见的就是以函数为单位的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name=<span class=\"string\">&quot;高原&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">childFn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    childFn(); <span class=\"comment\">// 高原</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name); <span class=\"comment\">// name is not defined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"三-作用域链\"><a class=\"markdownIt-Anchor\" href=\"#三-作用域链\">#</a> 三、作用域链</h2>\n<p><strong>3.1 当查找变量的时候都发生了什么？</strong></p>\n<ul>\n<li>会先从当前<strong>上下文的变量对象</strong>中查找；</li>\n<li>如果没有找到，就会从父级 (词法层面上的父级)<strong> 执行上下文</strong>的变量对象中查找；</li>\n<li>一直找到全局上下文的变量对象，也就是全局对象；</li>\n<li>作用域链的顶端就是全局对象；</li>\n</ul>\n<p>这样<strong>由多个执行上下文的变量对象构成的链表就叫做作用域链</strong>，从某种意义上很类似原型和原型链。</p>\n<p><strong>3.2 作用域链和原型继承查找时的区别：</strong></p>\n<ul>\n<li>查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回 <code>undefined</code></li>\n<li>查找的属性在作用域链中不存在的话就会抛出 <code>ReferenceError</code> 。</li>\n</ul>\n<p><strong>3.3 作用域嵌套</strong></p>\n<p>既然每一个函数就可以形成一个作用域（ <code>词法作用域</code>  ||  <code>块级作用域</code> ），那么当然也会存在多个作用域嵌套的情况，他们遵循这样的查询规则：</p>\n<ul>\n<li>内部作用域有权访问外部作用域；</li>\n<li>外部作用域无法访问内部作用域；（真是是这样吗？）</li>\n<li>兄弟作用域不可互相访问；</li>\n</ul>\n<p>在《你不知道的 Js》中，希望读者可以将作用域的嵌套和作用域链想象成这样：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2020060915193493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"四-思考与总结\"><a class=\"markdownIt-Anchor\" href=\"#四-思考与总结\">#</a> 四、思考与总结</h2>\n<p><strong>4.1 总结</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200609160809565.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><strong>4.2 思考</strong></p>\n<p>最后，让我们看一个《JavaScript 权威指南》中的两段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;global scope&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;local scope&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(); <span class=\"comment\">// 注意</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope1();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;global scope&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkscope2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> scope = <span class=\"string\">&quot;local scope&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope2()();</span><br></pre></td></tr></table></figure>\n<p>两段代码的结果都是 &quot;local scope&quot;，书中的回答是：JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f () 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f ()，这种绑定在执行 f () 时依然有效。</p>\n<p>但是它们内部经历的事情是一样的吗？</p>\n",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://example.com/2021/03/21/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/",
            "url": "http://example.com/2021/03/21/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE/",
            "title": "JavaScript基础（二）从原型到原型链",
            "date_published": "2021-03-21T02:09:04.000Z",
            "content_html": "<blockquote>\n<p>本文主要从构造函数 -&gt; 原型（隐式原型 + 显示原型）-&gt; 原型链的顺序，渐进式讲解，希望对你有所做帮助，共勉～</p>\n</blockquote>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h2>\n<p>又到了回忆过去的时候了，知识就是这样，原型和原型链在我之前的实习生涯中用到的很少 —— 几乎没有（噗！我菜我摊牌了），但是它和 this 指向问题一样，是初级、中级前端开发在面试时永远绕不开的话题。是不是大家每次看面经的时候都会去搜索原型相关的知识点？</p>\n<p>你看这知识，总是在考的时候，才能知道它的重要，就好像曾经有一段贼拉真挚的面试题摆在我面前… 话题拉回来，今天我们就收了这个<strong>孽障</strong>！</p>\n<img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/src=http___img.wxcha.com_file_201711_22_e1655873d2.jpg&refer=http___img.wxcha.jpeg\" style=\"zoom:50%;\" />\n<span id=\"more\"></span>\n<h2 id=\"一-构造函数\"><a class=\"markdownIt-Anchor\" href=\"#一-构造函数\">#</a> 一、构造函数</h2>\n<h3 id=\"11-什么是构造函数\"><a class=\"markdownIt-Anchor\" href=\"#11-什么是构造函数\">#</a> 1.1 什么是构造函数？</h3>\n<p>构造函数本身就是一个函数，与普通函数没有任何区别，不过<strong>为了规范一般将其首字母大写</strong>。构造函数和普通函数的区别在于，使用<strong> new</strong> 生成实例的函数就是构造函数，直接调用的就是普通函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name) <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，Person 就是一个构造函数。</p>\n<h3 id=\"12-constructor\"><a class=\"markdownIt-Anchor\" href=\"#12-constructor\">#</a> 1.2 constructor？</h3>\n<p><code>constructor</code>  返回创建实例对象时构造函数的引用。此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200604185358168.png\" alt=\"被构造出来的person的\"> 可以看到实例对象的 constructor 指向了它的构造函数，而它和原型的关系我们在之后会链接到一起。</p>\n<h3 id=\"13-都有哪些数据类型或者函数拥有constructor呢\"><a class=\"markdownIt-Anchor\" href=\"#13-都有哪些数据类型或者函数拥有constructor呢\">#</a> 1.3 都有哪些数据类型或者函数拥有 <code>constructor</code>  呢？</h3>\n<p>在 JavaScript 中，每个具有<strong>原型</strong>的对象都会自动获得 constructor 属性。除了： <code>arguments</code> 、 <code>Enumerator</code> 、 <code>Error</code> 、 <code>Global</code> 、 <code>Math</code> 、 <code>RegExp</code>  等一些特殊对象之外，其他所有的 JavaScript 内置对象都具备 constructor 属性。例如： <code>Array</code> 、 <code>Boolean</code> 、 <code>Date</code> 、 <code>Function</code> 、 <code>Number</code> 、 <code>Object</code> 、 <code>String</code>  等。所有主流浏览器均支持该属性。打开控制台我们可以验证一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;str&#x27;</span>.constructor) <span class=\"comment\">// ƒ String() &#123; [native code] &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;str&#x27;</span>.constructor === <span class=\"built_in\">String</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].constructor) <span class=\"comment\">// ƒ Array() &#123; [native code] &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].constructor === <span class=\"built_in\">Array</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数字</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.constructor) <span class=\"comment\">// ƒ Number() &#123; [native code] &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.constructor === <span class=\"built_in\">Number</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Date</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().constructor) <span class=\"comment\">// ƒ Date() &#123; [native code] &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 注意！！！不要混淆哦</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime().constructor) <span class=\"comment\">// ƒ Number() &#123; [native code] &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Boolean</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>.constructor) <span class=\"comment\">// ƒ Boolean() &#123; [native code] &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>.constructor === <span class=\"built_in\">Boolean</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;gaoyuan&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(show.constructor) <span class=\"comment\">// ƒ Function() &#123; [native code] &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义构造函数，无返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.constructor) <span class=\"comment\">// ƒ Person()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;gaoyuan&#x27;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = Person()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1.constructor) <span class=\"comment\">// ƒ Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"14-模拟实现一个new\"><a class=\"markdownIt-Anchor\" href=\"#14-模拟实现一个new\">#</a> 1.4 模拟实现一个 new</h3>\n<p>既然构造函数与普通函数的区别仅仅在于调用方式上，我们就应该了解 new。</p>\n<ul>\n<li>当调用 <code>new</code>  运算符时，该函数总会返回一个对象；</li>\n<li>通常情况下，构造器里的 this 就指向返回的这个对象；</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通常情况下</span><br><span class=\"line\"><span class=\"keyword\">var</span> MyClass = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\">obj.name; <span class=\"comment\">// gaoyuan</span></span><br><span class=\"line\"></span><br><span class=\"line\">特殊情况</span><br><span class=\"line\"><span class=\"keyword\">var</span> MyClass = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">name</span>: <span class=\"string\">&#x27;老王&#x27;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\">obj.name <span class=\"comment\">// 老王</span></span><br></pre></td></tr></table></figure>\n<p>我们利用  <code>__proto__</code> （隐式原型，下文会提到）属性来模拟一下 new 调用构造函数的过程：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objectNew = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从object.prototype上克隆一个空的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 取得外部传入的构造器，这里是Person</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> Constructor = [].shift.call( <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">    <span class=\"comment\">// 更新，指向正确的原型</span></span><br><span class=\"line\">    obj.__proto__ = Constructor.prototype; <span class=\"comment\">//知识点，要考、要考、要考</span></span><br><span class=\"line\">    <span class=\"comment\">// 借用外部传入的构造器给obj设置属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = Constructor.apply(obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 确保构造器总是返回一个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> ref === <span class=\"string\">&#x27;object&#x27;</span> ? ret : obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=1200653736,2067630829&fm=26&gp=0.jpeg\" style=\"zoom: 67%;\" />\n<h2 id=\"二-原型\"><a class=\"markdownIt-Anchor\" href=\"#二-原型\">#</a> 二、原型</h2>\n<h3 id=\"21-prototype显式原型\"><a class=\"markdownIt-Anchor\" href=\"#21-prototype显式原型\">#</a> 2.1 prototype (显式原型)</h3>\n<p>JavaScript 是一种基于原型的语言 (prototype-based language)，在设计的时候模仿了 Java 的两套类型机制： <code>基本类型</code>  和  <code>对象类型</code> 。可见原型很重要！</p>\n<p>每个对象都拥有一个原型对象，类是以函数的形式来定义的。prototype 表示该函数的原型，也表示一个类的成员的集合。看下图： <img data-src=\"https://img-blog.csdnimg.cn/20200605140618427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"> 可以发现 Person 函数自己的原型都有什么：</p>\n<ul>\n<li><code>constructor</code>  (Person.prototype.constructor =&gt; Person)</li>\n<li><code>__proto__</code>  （我们称它为隐式原型）</li>\n</ul>\n<p>此时我们得到了第一张表示构造函数和实例原型之间的关系图：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTEucG5n?x-oss-process=image/format,png\" alt=\"构造函数和实例原型的关系图\"></p>\n<p>那么我们该怎么表示实例与构造函数原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p>\n<h3 id=\"22-proto隐式原型\"><a class=\"markdownIt-Anchor\" href=\"#22-proto隐式原型\">#</a> 2.2 <strong>proto</strong> (隐式原型)</h3>\n<p>这是每一个 JavaScript 对象 (除了 null) 都具有的一个属性，叫 <code>__proto__</code> ，这是一个访问器属性（即 getter 函数和 setter 函数），通过它可以访问到对象的内部 <code>[[Prototype]]</code>  (一个对象或 null)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.__proto__ === Person.prototype); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>于是我们更新下关系图：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTIucG5n?x-oss-process=image/format,png\" alt=\"实例与实例原型的关系图\"></p>\n<p><strong>小结：</strong> 每个引用类型的隐式原型都指向它的构造函数的显式原型</p>\n<h3 id=\"23-constructor\"><a class=\"markdownIt-Anchor\" href=\"#23-constructor\">#</a> 2.3 constructor</h3>\n<p>前文提到了 <code>constructor</code> ，它与原型的关系也可以添加到这张图里，更新下关系图：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTMucG5n?x-oss-process=image/format,png\" alt=\"实例原型与构造函数的关系图\"> 根据上图的关系，下面这段的结果，大家就一目了然了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.__proto__ == Person.prototype) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor == Person) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(person) === Person.prototype) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>接下来我们要继续思考实例和原型的关系：</p>\n<h2 id=\"三-实例与原型\"><a class=\"markdownIt-Anchor\" href=\"#三-实例与原型\">#</a> 三、实例与原型</h2>\n<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。这样一个查找过程</p>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">&#x27;老王&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person.name = <span class=\"string\">&#x27;余光&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name) <span class=\"comment\">// 余光</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> person.name;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name) <span class=\"comment\">// 老王</span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 <span class=\"exturl\" data-url=\"aHR0cDovL3BlcnNvbi5uYW1l\">person.name</span> 的时候，结果自然为 余光（is me）。</p>\n<p><strong>描述：</strong></p>\n<p>但是当我们删除了 person 的 name 属性后，再次读取 <span class=\"exturl\" data-url=\"aHR0cDovL3BlcnNvbi5uYW1l\">person.name</span>，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 老王（这…）</p>\n<p><strong>总结：</strong></p>\n<ul>\n<li>尝试遍历 <code>实例a</code>  中的所有属性，但没有找到目标属性；</li>\n<li>查找 <code>name</code>  属性的这个请求被委托给该 <code>实例a</code>  的构造器 ( <code>A</code> ) 的原型，它被 <code>a.__proto__</code>  记录着并且指向 A.prototype；</li>\n<li>A.prototype 存在目标属性，返回他的值；</li>\n</ul>\n<p>但是万一还没有找到呢？原型的原型又是什么呢？</p>\n<h2 id=\"四-原型的原型\"><a class=\"markdownIt-Anchor\" href=\"#四-原型的原型\">#</a> 四、原型的原型</h2>\n<p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">obj.name = <span class=\"string\">&#x27;余光&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.name) <span class=\"comment\">// 余光</span></span><br></pre></td></tr></table></figure>\n<p>其实原型对象就是通过 <code>Object</code>  构造函数生成的，结合之前所讲，实例的  <code>__proto__</code>  指向构造函数的  <code>prototype</code>  ，可以理解成， <code>Object.prototype()</code>  是所有对象的根对象，所以我们再次更新下关系图：</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTQucG5n?x-oss-process=image/format,png\" alt=\"原型的原型关系图\"></p>\n<h2 id=\"五-原型链\"><a class=\"markdownIt-Anchor\" href=\"#五-原型链\">#</a> 五、原型链</h2>\n<p>每个对象拥有一个原型对象，通过  <code>__proto__</code>  指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向  <code>null</code> 。<strong>这种关系被称为原型链</strong> (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。</p>\n<p>这个链条存在着终点，是因为：Object.prototype 的原型是 ——null，引用阮一峰老师的 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTQvMDMvdW5kZWZpbmVkLXZzLW51bGwuaHRtbA==\">《undefined 与 null 的区别》 (opens new window)</span> 就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null 表示“没有对象”，即该处不应该有值。这句话也意味着 Object.prototype 没有原型</span><br></pre></td></tr></table></figure>\n<p>我们最后更新一次关系图，蓝色线条就可以表示原型链这种关系。</p>\n<p><img data-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dlYmJqOTcvc3VtbWFyeS9tYXN0ZXIvSW1hZ2VzL3Byb3RvdHlwZTUucG5n?x-oss-process=image/format,png\" alt=\"原型链示意图\"></p>\n<h3 id=\"补充易错点\"><a class=\"markdownIt-Anchor\" href=\"#补充易错点\">#</a> 补充，易错点</h3>\n<p><strong>1.constructor</strong> 首先是 constructor 属性，我们看个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.constructor === Person); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性，当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>\n<p><strong>2. <code>__proto__</code> </strong></p>\n<p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf (obj)。</p>\n<p><strong>3. 真的是继承吗？</strong></p>\n<p>最后是关于继承，前面我们讲到 “每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是：</p>\n<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，<strong>委托</strong>的说法反而更准确些。</p>\n<h2 id=\"六-总结\"><a class=\"markdownIt-Anchor\" href=\"#六-总结\">#</a> 六、总结</h2>\n<ul>\n<li>使用<strong> new</strong> 生成实例的函数就是构造函数，直接调用的就是普通函数；</li>\n<li>每个对象都拥有一个原型对象；</li>\n<li>每个引用类型的隐式原型都指向它的构造函数的显式原型；</li>\n<li>Object.prototype 是所有对象的根对象；</li>\n<li>原型链存在终点，不会无限查找下去；</li>\n</ul>\n",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://example.com/2021/03/20/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89this/",
            "url": "http://example.com/2021/03/20/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89this/",
            "title": "JavaScript基础（一）this",
            "date_published": "2021-03-20T01:55:37.000Z",
            "content_html": "<h3 id=\"一-this的指向\"><a class=\"markdownIt-Anchor\" href=\"#一-this的指向\">#</a> 一、this 的指向</h3>\n<p>百度、谷歌上输入 “this 的指向” 关键字，大几千条文章肯定是有的，总不至于为了全方面、无死角的掌握它就要将所有的文章都看一遍吧？所以不如梳理出一个稳固的框架，我们一起来填充它。</p>\n<h4 id=\"思维导图\"><a class=\"markdownIt-Anchor\" href=\"#思维导图\">#</a> 思维导图</h4>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200602110330766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<span id=\"more\"></span>\n<ul>\n<li>this 总是（非严格模式下）指向一个对象，而具体指向哪个对象是在运行时基于函数的 <code>执行环境</code> 动态绑定的，而非函数被声明时的环境；</li>\n<li>除了不常用的 with 和 eval 的情况，具体到实际应用中，this 指向大概可以分为四种：\n<ul>\n<li>作为对象的方法调用；</li>\n<li>作为普通函数调用；</li>\n<li>构造器调用；</li>\n<li>call 或 apply 调用；</li>\n<li>箭头函数中，this 指向函数上层作用域的 this；</li>\n</ul>\n</li>\n<li><strong>构造器</strong>和<strong>普通函数</strong>的区别在于 <code>被调用的方式</code> ；</li>\n<li>A,call (B) =&gt; 可以理解成在 B 的作用域内调用了 A 方法；</li>\n</ul>\n<h4 id=\"11-作为对象的方法调用\"><a class=\"markdownIt-Anchor\" href=\"#11-作为对象的方法调用\">#</a> 1.1 作为对象的方法调用</h4>\n<p>当函数作为对象的方法被调用时， <code>this指向该对象</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">&#x27;gaoyuan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span> === obj);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getName(); <span class=\"comment\">// true gaoyuan</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"12-作为普通函数调用\"><a class=\"markdownIt-Anchor\" href=\"#12-作为普通函数调用\">#</a> 1.2 作为普通函数调用</h4>\n<p>当函数不作为对象的属性被调用，而是以普通函数的方式，this 总是指向全局对象（在浏览器中，通常是 Window 对象）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getName(); <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>或者下面这段迷惑性的代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.name = <span class=\"string\">&#x27;老王&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;gaoyuan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getNew = obj.getName;</span><br><span class=\"line\">getNew(); <span class=\"comment\">// 老王</span></span><br></pre></td></tr></table></figure>\n<p>而在 ES5 的严格模式下，this 被规定为不会指向全局对象，而是 <code>undefined</code></p>\n<h4 id=\"13-构造器调用\"><a class=\"markdownIt-Anchor\" href=\"#13-构造器调用\">#</a> 1.3 构造器调用</h4>\n<p>除了一些内置函数，大部分 Js 中的函数都可以成为构造器，它们与普通函数没什么不同</p>\n<p><strong>构造器</strong>和<strong>普通函数</strong>的区别在于 <code>被调用的方式</code> ： 当 new 运算符调用函数时，总是返回一个对象，this 通常也指向这个对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyClass = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"string\">&#x27;gaoyuan&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> MyClass()</span><br><span class=\"line\">obj.name; <span class=\"comment\">// gaoyuan</span></span><br></pre></td></tr></table></figure>\n<p>但是，如果显式的返回了一个 object 对象，那么此次运算结果最终会返回这个对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyClass = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myClass = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;myClass.name:&#x27;</span>, myClass.name); <span class=\"comment\">// &#123; name: 2&#125;</span></span><br></pre></td></tr></table></figure>\n<p>只要构造器不显示的返回任何数据，或者返回非对象类型的数据，就不会造成上述问题。</p>\n<h4 id=\"14-call或apply调用\"><a class=\"markdownIt-Anchor\" href=\"#14-call或apply调用\">#</a> 1.4 call 或 apply 调用</h4>\n<p>跟普通的函数调用相比，用 call 和 apply 可以动态的改变函数的 this</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num = <span class=\"string\">&#x27;&#x27;</span></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name + num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 可以理解成在 obj2的作用域下调用了 obj1.getName()函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.getName()); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.getName.call(obj2, <span class=\"number\">2</span>)); <span class=\"comment\">// 2 + 2 = 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1.getName.apply(obj2, [<span class=\"number\">2</span>])); <span class=\"comment\">// 2 + 2 = 4</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"15-箭头函数\"><a class=\"markdownIt-Anchor\" href=\"#15-箭头函数\">#</a> 1.5 箭头函数</h4>\n<p>箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this。因此，在下面的代码中，传递给 setInterval 的函数内的 this 与封闭函数中的 this 值相同：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.name = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getName()</span><br></pre></td></tr></table></figure>\n<h4 id=\"16-常见的坑\"><a class=\"markdownIt-Anchor\" href=\"#16-常见的坑\">#</a> 1.6 常见的坑</h4>\n<p>就像标题一样，有的时候 <code>this</code>  会指向 undefined</p>\n<p><strong>情况一</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">obj.getName();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName2 = obj.getName;</span><br><span class=\"line\">getName2()</span><br></pre></td></tr></table></figure>\n<p>这个时候，getName2 () 作为普通函数被调用时，this 指向全局对象 ——window。</p>\n<p><strong>情况二</strong></p>\n<p>当我们希望自己封装 Dom 方法，来精简代码时：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getDomById = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementById(id);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">getDomById(<span class=\"string\">&#x27;div1&#x27;</span>) <span class=\"comment\">//dom节点</span></span><br></pre></td></tr></table></figure>\n<p>那么我们看看这么写行不行？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getDomById = <span class=\"built_in\">document</span>.getElementById</span><br><span class=\"line\">getDomById(<span class=\"string\">&#x27;div1&#x27;</span>) <span class=\"comment\">// Uncaught TypeError: Illegal invocation(非法调用)</span></span><br></pre></td></tr></table></figure>\n<p>这是因为:</p>\n<ul>\n<li>当我们去调用 <code>document</code>  对象的方法时，方法内的 this 指向 <code>document</code> 。</li>\n<li>当我们用 getId 应用 document 内的方法，再以普通函数的方式调用，函数内容的 this 就指向了全局对象。</li>\n</ul>\n<p><strong>利用 call 和 apply 修正情况二</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.getElementById = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.call(<span class=\"built_in\">document</span>, ...arguments)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)(<span class=\"built_in\">document</span>.getElementById)</span><br><span class=\"line\"><span class=\"comment\">// 利用立即执行函数将document保存在作用域中</span></span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=2299180848,518697654&amp;fm=26&amp;gp=0.jpeg\" alt=\"\"></p>\n<h3 id=\"二-call和apply\"><a class=\"markdownIt-Anchor\" href=\"#二-call和apply\">#</a> 二、call 和 apply</h3>\n<p>不要因为它的 “强大” 而对它产生抗拒，了解并熟悉它是我们必须要做的，共勉！</p>\n<h4 id=\"思维导图-2\"><a class=\"markdownIt-Anchor\" href=\"#思维导图-2\">#</a> 思维导图</h4>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200602153648211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"1call和apply区别\"><a class=\"markdownIt-Anchor\" href=\"#1call和apply区别\">#</a> 1.call 和 apply 区别</h4>\n<p>先来看区别，是因为它们<strong>几乎</strong>没有区别，下文代码实例 call 和 apply 都可以轻易的切换。</p>\n<p>当它们被设计出来时要做到的事情一摸一样，唯一的区别就在于 <code>传参的格式不一样</code></p>\n<ul>\n<li>apply 接受两个参数\n<ul>\n<li>第一个参数指定了函数体内 this 对象的指向</li>\n<li>第二个参数为一个带下标的参数集合（可以是数组或者类数组）</li>\n</ul>\n</li>\n<li>call 接受的参数不固定\n<ul>\n<li>第一个参数指定了函数体内 this 对象的指向</li>\n<li>第二个参数及以后为函数调用的参数</li>\n</ul>\n</li>\n</ul>\n<p>因为在所有（非箭头）函数中都可以通过 <code>arguments</code>  对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，它本身就是一个类数组，我们 apply 在实际使用中更常见一些。</p>\n<p>call 是包装在 apply 上面的语法糖，如果我们明确的知道参数数量，并且希望展示它们，可以使用 call。</p>\n<p>当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会默认指向宿主对象，在浏览器中则是 <code>window</code> 。</p>\n<p><strong>借用其他对象的方法</strong></p>\n<p>我们可以直接传 null 来代替任意对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])</span><br></pre></td></tr></table></figure>\n<h4 id=\"2call和apply能做什么\"><a class=\"markdownIt-Anchor\" href=\"#2call和apply能做什么\">#</a> 2.call 和 apply 能做什么？</h4>\n<p>使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数 —— 来时<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vY2FsbA==\"> MDN (opens new window)</span></p>\n<ul>\n<li>调用构造函数来 <code>实现继承</code> ；</li>\n<li>调用函数并且指定上下文的  <code>this</code> ;</li>\n<li>调用函数并且不指定第一个参数；</li>\n</ul>\n<p><strong>1. 调用构造函数来实现继承</strong></p>\n<p>通过 “借用” 的方式来达到继承的效果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Product</span>(<span class=\"params\">name, price</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.price = price;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span>(<span class=\"params\">name, price</span>) </span>&#123;</span><br><span class=\"line\">\tProduct.call(<span class=\"built_in\">this</span>, name, price); <span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.category = food;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> hotDog = <span class=\"keyword\">new</span> Food(<span class=\"string\">&#x27;hotDog&#x27;</span>, <span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>2. 调用函数并且指定上下文的  <code>this</code> </strong></p>\n<p>此时 this 被指向了 obj</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.id + <span class=\"string\">&#x27;:&#x27;</span> + <span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;gaoyuan&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">showName.call(obj)</span><br></pre></td></tr></table></figure>\n<p><strong>3. 使用 call 单纯的调用某个函数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/u=826503588,4160798134&amp;fm=15&amp;gp=0.jpeg\" alt=\"\"></p>\n<h3 id=\"三-模拟实现一个call\"><a class=\"markdownIt-Anchor\" href=\"#三-模拟实现一个call\">#</a> 三、模拟实现一个 call</h3>\n<p>先来看一下 call 帮我们需要做什么？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">value</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">show.call(foo); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>就像解方程，要在已知条件中寻找突破哦口：</p>\n<ul>\n<li><code>call</code>  使得 this 的指向变了，指向了 foo;</li>\n<li><code>show</code>  函数被执行了；</li>\n<li>传入的参数应为  <code>this</code>  + 参数列表；</li>\n</ul>\n<p><strong>第一版代码</strong></p>\n<p>上面提到的 3 点，仅仅完成了一点，且传入的参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.setCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>); <span class=\"comment\">// 此时this指向show</span></span><br><span class=\"line\">    obj.func = <span class=\"built_in\">this</span>; <span class=\"comment\">// 将函数变成对象的内部属性</span></span><br><span class=\"line\">    obj.func(obj.value) <span class=\"comment\">// 指定函数</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> obj.func <span class=\"comment\">// 删除函数，当做什么都没发生～</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">show.setCall(foo)</span><br></pre></td></tr></table></figure>\n<p><strong>第二版代码</strong></p>\n<p>为了解决参数的问题，我们要能获取到参数，并且正确的传入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a + b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.setCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    obj.fn = <span class=\"built_in\">this</span>; <span class=\"comment\">// 将函数变成对象的内部属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++)&#123;</span><br><span class=\"line\">        args.push(<span class=\"string\">&#x27;arguments[&#x27;</span> + i + <span class=\"string\">&#x27;]&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">eval</span>(<span class=\"string\">&#x27;obj.fn(&#x27;</span> + args + <span class=\"string\">&#x27;)&#x27;</span>); <span class=\"comment\">// 传入参数</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> obj.fn; <span class=\"comment\">// 删除函数，当做什么都没发生～</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">show.setCall(foo, <span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 1 3</span></span><br></pre></td></tr></table></figure>\n<p>此时，我们就可以做到，传入多个参数的情况下使用 call 了，但是如果你仅想用某个方法呢？</p>\n<p><strong>第三版代码</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.setCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = obj || <span class=\"built_in\">window</span>;</span><br><span class=\"line\">  obj.fn = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>, len = <span class=\"built_in\">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">    args.push(<span class=\"string\">&#x27;arguments[&#x27;</span> + i + <span class=\"string\">&#x27;]&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"built_in\">eval</span>(<span class=\"string\">&#x27;obj.fn(&#x27;</span> + args +<span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> obj.fn;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 测试一下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">value</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.value);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"built_in\">this</span>.value,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: name,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: age</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar.setCall(<span class=\"literal\">null</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar.setCall(obj, <span class=\"string\">&#x27;kevin&#x27;</span>, <span class=\"number\">18</span>));</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-bind\"><a class=\"markdownIt-Anchor\" href=\"#四-bind\">#</a> 四、bind</h3>\n<p>提到了<strong> call</strong> 和<strong> apply</strong>，就绕不开<strong> bind ()</strong>，来看一下 MDN 上对 **bind ()** 的解释：</p>\n<p>bind () 方法创建一个新的函数，在 bind () 被调用时，这个新函数的 this 被指定为 bind () 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>\n<p>我们用 Js 来模拟一个 bind 方法，以便加深我们的认识</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"built_in\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _this.apply(func, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func.bind(obj)</span><br></pre></td></tr></table></figure>\n<p>这样看上去，bind 总会帮我们返回同样的 <code>this</code>  值，还是挺坚挺的哦～</p>\n",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://example.com/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/",
            "url": "http://example.com/2021/03/19/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/",
            "title": "函数防抖与节流",
            "date_published": "2021-03-19T01:43:56.000Z",
            "content_html": "<h2 id=\"函数防抖\"><a class=\"markdownIt-Anchor\" href=\"#函数防抖\">#</a> 函数防抖</h2>\n<h3 id=\"一-为什么需要防抖\"><a class=\"markdownIt-Anchor\" href=\"#一-为什么需要防抖\">#</a> 一、为什么需要防抖</h3>\n<ul>\n<li>高频的函数操作可能产生不好的影响</li>\n<li>如：resize、scroll、mousedown、mousemove、keyup、keydown……</li>\n</ul>\n<p>为此，我们举个示例代码来了解事件如何频繁的触发：</p>\n<p>我们写一个 index.html 文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">    &lt;title&gt;debounce&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        #wrapper &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 200px;</span><br><span class=\"line\">            line-height: 200px;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">            color: #fff;</span><br><span class=\"line\">            background-color: #444;</span><br><span class=\"line\">            font-size: 30px;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        var count = 1;</span><br><span class=\"line\">        var oDiv = document.getElementById(&quot;wrapper&quot;);</span><br><span class=\"line\">        function getUserAction() &#123;</span><br><span class=\"line\">            oDiv.innerHTML = count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        oDiv.onmousemove = getUserAction;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>从左边滑到右边就触发了近 100 次 <code>getUserAction</code>  函数！看如下 Gif：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408456-269506ee-a343-41c8-86b8-e80da9304d8e.gif\" alt=\"\"></p>\n<p>因为这个例子很简单，所以浏览器完全反应的过来，但假设：</p>\n<ul>\n<li>它的触发频次极高，1 分钟 2000 次，且涉及到大量的位置计算、DOM 操作等工作，</li>\n<li>存在接口请求，单个函数执行时间较长，但每个函数触发的间隔很近。</li>\n</ul>\n<p>这种在一瞬间（短时间内）对浏览器或服务器造成了过多压力的交互就需要进行优化了，为了解决这个问题，一般有两种解决方案：</p>\n<ul>\n<li>debounce 防抖</li>\n<li>throttle 节流</li>\n</ul>\n<p>他们的目的都是：<strong>降低一个函数的触发频率，以提高性能或避免资源浪费。</strong></p>\n<h3 id=\"二-防抖的原理\"><a class=\"markdownIt-Anchor\" href=\"#二-防抖的原理\">#</a> 二、防抖的原理</h3>\n<p>今天重点讲讲防抖的实现。</p>\n<p>防抖的原理就是：你尽管触发事件，但是我一定在事件触发 <code>n秒无操作后</code> 才执行。举个例子：</p>\n<p>我们规定 <code>3s</code>  为防抖的标准，那么:</p>\n<ol>\n<li>第一次要求执行事件 - 此时倒计时 3s</li>\n<li>倒计时 2s</li>\n<li>倒计时 1s</li>\n<li>0.5s 时事件再次被触发 - 此时倒计时 3s</li>\n<li>…3s 内无事发生</li>\n<li>执行事件，共用了 5.5s</li>\n</ol>\n<h3 id=\"三-自己实现一个防抖\"><a class=\"markdownIt-Anchor\" href=\"#三-自己实现一个防抖\">#</a> 三、自己实现一个防抖</h3>\n<h4 id=\"31-第一版\"><a class=\"markdownIt-Anchor\" href=\"#31-第一版\">#</a> 3.1 第一版</h4>\n<p>我们根据上一节提到的核心思想，实现第一版代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">        timer = setTimeout(func, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们要使用它，第一节的例子为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oDiv.onmousemove = debounce(getUserAction, 2000);</span><br></pre></td></tr></table></figure>\n<p>此时大家可以再次测试一下，事件持续发生时，只有在完全停止 2s 后，才会触发事件：</p>\n<p>写到这里，作为针对部分高频事件的需求来说，已经结束了。我们来看看他的效果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408554-b0245fd8-1c4d-4085-80da-f91d8be8da6f.gif\" alt=\"\"></p>\n<h4 id=\"32-第二版\"><a class=\"markdownIt-Anchor\" href=\"#32-第二版\">#</a> 3.2 第二版</h4>\n<p>大家都知道，dom 节点在触发事件的时候，this 指向它本身，本例中则指向 <code>oDiv</code> ，但是在本例中：我们看一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var count = 1;</span><br><span class=\"line\">var oDiv = document.getElementById(&quot;oDiv&quot;);</span><br><span class=\"line\">function getUserAction() &#123;</span><br><span class=\"line\">    oDiv.innerHTML = count++;</span><br><span class=\"line\">    console.log(&#x27;this&#x27;, this); // 此时输出 Window...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">oDiv.onmousemove = debounce(getUserAction, 2000);</span><br><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">        timer = setTimeout(func, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>毕竟经过了一层匿名函数的包裹，this 已经指向了 window，为了减少影响，我们尝试修正它</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        var _this = this; // 记录当前this</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">        timer = setTimeout(function()&#123;</span><br><span class=\"line\">            func.apply(_this); //将 func的this改为_this</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"33-第三版\"><a class=\"markdownIt-Anchor\" href=\"#33-第三版\">#</a> 3.3 第三版</h4>\n<p>解决的 this 指向问题，我们的函数仍然不够 “完美”，JavaScript 中，事件处理函数会提供 <code>event</code>  对象，我们简称为 e。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用了 debouce 函数</span><br><span class=\"line\">function getUserAction(e) &#123;</span><br><span class=\"line\">    console.log(e); // undefined</span><br><span class=\"line\">    oDiv.innerHTML = count++;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了保证它的原汁原味，我们再改第三版：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var count = 1;</span><br><span class=\"line\">var oDiv = document.getElementById(&quot;oDiv&quot;);</span><br><span class=\"line\">function getUserAction(e) &#123;</span><br><span class=\"line\">    oDiv.innerHTML = count++;</span><br><span class=\"line\">    console.log(&#x27;e&#x27;, e); // MouseEvent</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">oDiv.onmousemove = debounce(getUserAction, 2000);</span><br><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        var _this = this; // 记录当前this</span><br><span class=\"line\">        var arg = arguments; // 记录参数</span><br><span class=\"line\">        clearTimeout(timer)</span><br><span class=\"line\">        timer = setTimeout(function () &#123;</span><br><span class=\"line\">            func.apply(_this, arg); //将 func的this改为_this</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此为止，我们在尽可能保留 Dom 事件原有能力的情况下，给函数加上了防抖效果，它可以解决大部分我们日常开发的防抖问题，但我们需要更 “完美”</p>\n<h3 id=\"四-防抖进阶\"><a class=\"markdownIt-Anchor\" href=\"#四-防抖进阶\">#</a> 四、防抖进阶</h3>\n<h4 id=\"41-立即执行\"><a class=\"markdownIt-Anchor\" href=\"#41-立即执行\">#</a> 4.1 立即执行</h4>\n<p>这个需求就是：</p>\n<ul>\n<li>立即执行</li>\n<li>保持 <code>n</code>  秒空白期</li>\n<li>将 <code>n</code>  秒空白期置后</li>\n</ul>\n<p>想想这个需求也是很有道理的嘛，那我们加个 <code>immediate</code>  参数判断是否是立刻执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, immediate) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        var _this = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        if (timer) clearTimeout(timer); // 常规流程，间隔内触发时清掉重置定时</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 如果已经执行过，不再执行</span><br><span class=\"line\">            var callNow = !timer; // 1. callNow 初始值是 true, 同步立即执行；随后 timer 才开始执行</span><br><span class=\"line\">            timer = setTimeout(function()&#123;</span><br><span class=\"line\">                timer = null; // wait 期间，timer 是一个 ID 数字，所以 callNow 为 false，func 在此期间永远不会执行</span><br><span class=\"line\">            &#125;, wait) // wait 之后，timer 赋值 null，callNow 为 true，func 又开始立即执行。</span><br><span class=\"line\">            if (callNow) func.apply(_this, args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            timer = setTimeout(function()&#123;</span><br><span class=\"line\">                func.apply(_this, args)</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看下此时他是什么效果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408487-78c69123-24ec-4893-b442-366d3117eda2.gif\" alt=\"\"></p>\n<h4 id=\"42-添加简单验证\"><a class=\"markdownIt-Anchor\" href=\"#42-添加简单验证\">#</a> 4.2 添加简单验证</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, immediate) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    // 检查函数</span><br><span class=\"line\">    if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class=\"line\">        throw new TypeError(&#x27;Expected a function&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 保证wait存在</span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\">    const debounced = function () &#123;</span><br><span class=\"line\">        var _this = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        if (timer) clearTimeout(timer); // 常规流程，间隔内触发时清掉重置定时</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 如果已经执行过，不再执行</span><br><span class=\"line\">            var callNow = !timer; // 如果不存在定时器，则callNow为true</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                timer = null; // 为了保证之后的时效性，手动添加timer</span><br><span class=\"line\">            &#125;, wait)</span><br><span class=\"line\">            // 因为不存在timer，证明是首次执行，所以直接调用</span><br><span class=\"line\">            if (callNow) func.apply(_this, args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(_this, args)</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return debounced</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"43-添加取消事件方法\"><a class=\"markdownIt-Anchor\" href=\"#43-添加取消事件方法\">#</a> 4.3 添加取消事件方法</h4>\n<p>如果你希望能取消被防抖的事件，我们可以这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, immediate) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    // 检查函数</span><br><span class=\"line\">    if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class=\"line\">        throw new TypeError(&#x27;Expected a function&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 保证wait存在</span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\">    const debounced = function () &#123;</span><br><span class=\"line\">        var _this = this;</span><br><span class=\"line\">        var args = arguments;</span><br><span class=\"line\">        if (timer) clearTimeout(timer); // 常规流程，间隔内触发时清掉重置定时</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 如果已经执行过，不再执行</span><br><span class=\"line\">            var callNow = !timer; // 如果不存在定时器，则callNow为true</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                timer = null; // 为了保证之后的时效性，手动添加timer</span><br><span class=\"line\">            &#125;, wait)</span><br><span class=\"line\">            // 因为不存在timer，证明是首次执行，所以直接调用</span><br><span class=\"line\">            if (callNow) func.apply(_this, args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(_this, args)</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const cancel = function()&#123;</span><br><span class=\"line\">        clearTimeout(timer);</span><br><span class=\"line\">        timer = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const pending = function()&#123;</span><br><span class=\"line\">        return timer !== undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    debounced.pending = pending;</span><br><span class=\"line\">    return debounced</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再来看看效果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740408427-b468ccd4-99ff-4eee-821a-290d95e04071.gif\" alt=\"\"></p>\n<h2 id=\"函数节流\"><a class=\"markdownIt-Anchor\" href=\"#函数节流\">#</a> 函数节流</h2>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>我们还是以移动事件举例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        #wrapper &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 140px;</span><br><span class=\"line\">            background: rgba(0, 0, 0, 0.8);</span><br><span class=\"line\">            color: #fff;</span><br><span class=\"line\">            font-size: 30px;</span><br><span class=\"line\">            font-weight: bold;</span><br><span class=\"line\">            line-height: 140px;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        var count = 1;</span><br><span class=\"line\">        function moveAction () &#123;</span><br><span class=\"line\">            oWrapper.innerHTML = count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        var oWrapper = document.querySelector(&#x27;#wrapper&#x27;);</span><br><span class=\"line\">        oWrapper.onmousemove = moveAction;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>它的效果是这样：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551747-de70166f-f851-412c-ba2a-5a116a194f3d.gif\" alt=\"\"></p>\n<h3 id=\"一-核心和基本实现\"><a class=\"markdownIt-Anchor\" href=\"#一-核心和基本实现\">#</a> 一、核心和基本实现</h3>\n<p>节流的原理很简单：<strong>如果你持续触发某个事件，特定的时间间隔内，只执行一次。</strong></p>\n<p><strong>关于节流的实现，有两种主流的实现方式：</strong></p>\n<ol>\n<li>时间戳思路</li>\n<li>定时器思路</li>\n</ol>\n<h4 id=\"11-时间戳思路\"><a class=\"markdownIt-Anchor\" href=\"#11-时间戳思路\">#</a> 1.1 时间戳思路</h4>\n<p>顾名思义，通过两个时间戳来控制时间间隔，当触发事件的时候：</p>\n<ol>\n<li>我们取出当前的时间戳  <code>now</code> ；</li>\n<li>然后减去之前<strong>执行时</strong>的时间戳 (首次值为 0)  <code>prev</code> ；</li>\n<li>如果大 <code>now - prev &gt; wait</code> ，证明时间区间维护结束，执行指定事件，更新 <code>prev</code> ；</li>\n</ol>\n<p>根据这一思路，我们就可以实现第一版代码了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oWrapper.onmousemove = throttle(moveAction, 1000);</span><br><span class=\"line\">function throttle(func, wait) &#123;</span><br><span class=\"line\">    var _this, arg;</span><br><span class=\"line\">    var prev = 0; // 上一次触发的时间，第一次默认为0</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        var now = Date.now(); // 触发时的时间</span><br><span class=\"line\">        _this = this;</span><br><span class=\"line\">        if (now - prev &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(_this, arg); // 允许传入参数，并修正this</span><br><span class=\"line\">            prev = now; // 更新上一次触发的时间</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来看看借助它，效果是什么样的：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740552204-2bb5f2b1-3807-4d26-b3eb-d34e798ab60a.gif\" alt=\"\"></p>\n<p>我们可以看到：</p>\n<ol>\n<li>当鼠标移入的时候，<strong>事件立刻执行</strong></li>\n<li>每过 1s 会执行一次，且移动 2.5s 会执行 2 次，意味着动作<strong>停止后不会再执行</strong>。</li>\n</ol>\n<h4 id=\"12-定时器思路\"><a class=\"markdownIt-Anchor\" href=\"#12-定时器思路\">#</a> 1.2 定时器思路</h4>\n<p>利用定时器来保证间隔时间内事件的触发次数</p>\n<ol>\n<li>创建定时器 <code>timer</code> ，记录当前是否在<strong>周期</strong>内；</li>\n<li>判断定时器是否存在，若存在则直接结束，否则执行事件；</li>\n<li><code>wait</code>  时间之后再次执行，并清掉定时器；</li>\n</ol>\n<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait) &#123;</span><br><span class=\"line\">    var _this, arg;</span><br><span class=\"line\">    var timer; // 初始化</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        _this = this; // 记录this</span><br><span class=\"line\">        arg = arguments; // 记录参数数组</span><br><span class=\"line\">        if (timer) return; // 时候未到</span><br><span class=\"line\">        timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            func.apply(_this, arg); // 允许传入参数，并修正this</span><br><span class=\"line\">            timer = null;</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>来看看借助它，效果是什么样的：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551861-12bc2cce-f80a-45ff-9913-7798160b3438.gif\" alt=\"\"></p>\n<p>但是，我们可以看到：</p>\n<ol>\n<li>当鼠标移入的时候，事件不会立刻执行；</li>\n<li>鼠标定制后 <code>wait</code>  间隔后会执行一次</li>\n</ol>\n<h4 id=\"13-两种思路的区别\"><a class=\"markdownIt-Anchor\" href=\"#13-两种思路的区别\">#</a> 1.3 两种思路的区别</h4>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>时间戳</th>\n<th>定时器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>“起点”</td>\n<td>立即执行</td>\n<td>n 秒后执行</td>\n</tr>\n<tr>\n<td>“终点”</td>\n<td>停止后不会执行</td>\n<td>停止会再执行一次</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"二-节流进阶\"><a class=\"markdownIt-Anchor\" href=\"#二-节流进阶\">#</a> 二、节流进阶</h3>\n<p>结合两种思想完成一个可以立即执行，且停止触发后再执行一次的节流方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第三版</span><br><span class=\"line\">function throttle(func, wait) &#123;</span><br><span class=\"line\">    var timeout, context, args, result;</span><br><span class=\"line\">    var previous = 0;</span><br><span class=\"line\">    var later = function() &#123;</span><br><span class=\"line\">        previous = +new Date();</span><br><span class=\"line\">        timeout = null;</span><br><span class=\"line\">        func.apply(context, args)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    var throttled = function() &#123;</span><br><span class=\"line\">        var now = +new Date();</span><br><span class=\"line\">        //下次触发 func 剩余的时间</span><br><span class=\"line\">        var remaining = wait - (now - previous);</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        args = arguments;</span><br><span class=\"line\">         // 如果没有剩余的时间了或者你改了系统时间</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            timeout = setTimeout(later, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果演示如下：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1614740551783-4d2e4584-8e32-4ca2-a1de-c2ab865a882c.gif\" alt=\"\"></p>\n<p>我在看代码的时候，我是反复打印数据才理解为什么会这样做，一起加油～</p>\n",
            "tags": [
                "javascript"
            ]
        },
        {
            "id": "http://example.com/2021/02/11/JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/",
            "url": "http://example.com/2021/02/11/JS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/",
            "title": "JS实现图片压缩",
            "date_published": "2021-02-11T01:19:04.000Z",
            "content_html": "<blockquote>\n<p>说起图片压缩，大家想到的或者平时用到的很多工具都可以实现，例如，客户端类的有图片压缩工具 PPDuck3， JS 实现类的有插件 compression.js ，亦或是在线处理类的 OSS 上传，文件上传后，在访问文件时中也有图片的压缩配置选项，那能不能使用 JS 实现的图片压缩代码呢？当然可以，那我们先来理一下思路。</p>\n</blockquote>\n<h2 id=\"压缩思路\"><a class=\"markdownIt-Anchor\" href=\"#压缩思路\">#</a> 压缩思路</h2>\n<p>涉及到 JS 的图片压缩，我的想法是需要用到 Canvas 的绘图能力，通过调整图片的分辨率或者绘图质量来达到图片压缩的效果，实现思路如下：</p>\n<ul>\n<li>获取上传 Input 中的图片对象 File</li>\n<li>将图片转换成 base64 格式</li>\n<li>base64 编码的图片通过 Canvas 转换压缩，这里会用到的 Canvas 的 drawImage 以及 toDataURL 这两个 Api，一个调节图片的分辨率的，一个是调节图片压缩质量并且输出的，后续会有详细介绍</li>\n<li>转换后的图片生成对应的新图片，然后输出</li>\n<li></li>\n</ul>\n<h2 id=\"优缺点介绍\"><a class=\"markdownIt-Anchor\" href=\"#优缺点介绍\">#</a> 优缺点介绍</h2>\n<p>不过 Canvas 压缩的方式也有着自己的优缺点：</p>\n<ul>\n<li>优点：实现简单，参数可以配置化，自定义图片的尺寸，指定区域裁剪等等。</li>\n<li>缺点：只有 jpeg 、webp 支持原图尺寸下图片质量的调整来达到压缩图片的效果，其他图片格式，仅能通过调节尺寸来实现</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;input type=&quot;file&quot; id=&quot;input-img&quot; @change=&quot;compress&quot; /&gt;</span><br><span class=\"line\">    &lt;a :download=&quot;fileName&quot; :href=&quot;compressImg&quot; &gt;普通下载&lt;/a&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;downloadImg&quot;&gt;兼容 IE 下载&lt;/button&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;img :src=&quot;compressImg&quot; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;export default &#123;</span><br><span class=\"line\">  name: &#x27;compress&#x27;,</span><br><span class=\"line\">  data: function() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      compressImg: null,</span><br><span class=\"line\">      fileName: null,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  components: &#123;&#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    compress() &#123;</span><br><span class=\"line\">      // 获取文件对象</span><br><span class=\"line\">      const fileObj = document.querySelector(&#x27;#input-img&#x27;).files[0];</span><br><span class=\"line\">      // 获取文件名称，后续下载重命名</span><br><span class=\"line\">      this.fileName = `$&#123;new Date().getTime()&#125;-$&#123;fileObj.name&#125;`;</span><br><span class=\"line\">      // 获取文件后缀名</span><br><span class=\"line\">      const fileNames = fileObj.name.split(&#x27;.&#x27;);</span><br><span class=\"line\">      const type = fileNames[fileNames.length-1];</span><br><span class=\"line\">      // 压缩图片</span><br><span class=\"line\">      this.handleCompressImage(fileObj, type);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleCompressImage(img, type) &#123;</span><br><span class=\"line\">      const vm = this;</span><br><span class=\"line\">      let reader = new FileReader();</span><br><span class=\"line\">      // 读取文件</span><br><span class=\"line\">      reader.readAsDataURL(img);</span><br><span class=\"line\">      reader.onload = function(e) &#123;</span><br><span class=\"line\">        let image = new Image(); //新建一个img标签</span><br><span class=\"line\">        image.src = e.target.result;</span><br><span class=\"line\">        image.onload = function() &#123;</span><br><span class=\"line\">          let canvas = document.createElement(&#x27;canvas&#x27;);</span><br><span class=\"line\">          let context = canvas.getContext(&#x27;2d&#x27;);</span><br><span class=\"line\">          // 定义 canvas 大小，也就是压缩后下载的图片大小</span><br><span class=\"line\">          let imageWidth = image.width; //压缩后图片的大小</span><br><span class=\"line\">          let imageHeight = image.height;</span><br><span class=\"line\">          canvas.width = imageWidth;</span><br><span class=\"line\">          canvas.height = imageHeight;</span><br><span class=\"line\">          </span><br><span class=\"line\">          // 图片不压缩，全部加载展示</span><br><span class=\"line\">          context.drawImage(image, 0, 0);</span><br><span class=\"line\">          // 图片按压缩尺寸载入</span><br><span class=\"line\">          // let imageWidth = 500; //压缩后图片的大小</span><br><span class=\"line\">          // let imageHeight = 200;</span><br><span class=\"line\">          // context.drawImage(image, 0, 0, 500, 200);</span><br><span class=\"line\">          // 图片去截取指定位置载入</span><br><span class=\"line\">          // context.drawImage(image,100, 100, 100, 100, 0, 0, imageWidth, imageHeight);</span><br><span class=\"line\">          vm.compressImg = canvas.toDataURL(`image/$&#123;type&#125;`);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // base64 图片转 blob 后下载</span><br><span class=\"line\">    downloadImg() &#123;</span><br><span class=\"line\">      let parts = this.compressImg.split(&#x27;;base64,&#x27;);</span><br><span class=\"line\">      let contentType = parts[0].split(&#x27;:&#x27;)[1];</span><br><span class=\"line\">      let raw = window.atob(parts[1]);</span><br><span class=\"line\">      let rawLength = raw.length;</span><br><span class=\"line\">      let uInt8Array = new Uint8Array(rawLength);</span><br><span class=\"line\">      for(let i = 0; i &lt; rawLength; ++i) &#123;</span><br><span class=\"line\">        uInt8Array[i] = raw.charCodeAt(i);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      const blob = new Blob([uInt8Array], &#123;type: contentType&#125;);</span><br><span class=\"line\">      this.compressImg = URL.createObjectURL(blob);</span><br><span class=\"line\">      if (window.navigator.msSaveOrOpenBlob) &#123;</span><br><span class=\"line\">        // 兼容 ie 的下载方式</span><br><span class=\"line\">        window.navigator.msSaveOrOpenBlob(blob, this.fileName);</span><br><span class=\"line\">      &#125;else&#123;</span><br><span class=\"line\">        const a = document.createElement(&#x27;a&#x27;);</span><br><span class=\"line\">        a.href = this.compressImg;</span><br><span class=\"line\">        a.setAttribute(&#x27;download&#x27;, this.fileName);</span><br><span class=\"line\">        a.click();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现步骤\"><a class=\"markdownIt-Anchor\" href=\"#实现步骤\">#</a> 实现步骤</h2>\n<blockquote>\n<p>上面的代码是可以直接拿来看效果的，不喜欢用 Vue 的也可以把代码稍微调整一下，下面开始具体分解一下代码的实现思路</p>\n</blockquote>\n<h3 id=\"步骤一input-上传-file-处理\"><a class=\"markdownIt-Anchor\" href=\"#步骤一input-上传-file-处理\">#</a> 步骤一：Input 上传 File 处理</h3>\n<p>将 File 对象通过  <code>FileReader</code>  的  <code>readAsDataURL</code>  方法转换为 URL 格式的字符串（base64 编码）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fileObj = document.querySelector(&#x27;#input-img&#x27;).files[0];</span><br><span class=\"line\">let reader = new FileReader();</span><br><span class=\"line\">// 读取文件</span><br><span class=\"line\">reader.readAsDataURL(fileObj);</span><br></pre></td></tr></table></figure>\n<h2 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h2>\n<h3 id=\"步骤二canvas-处理-file-对象\"><a class=\"markdownIt-Anchor\" href=\"#步骤二canvas-处理-file-对象\">#</a> 步骤二：Canvas 处理 File 对象</h3>\n<p>建立一个  <code>Image</code>  对象，一个  <code>canvas</code>  画布，设定自己想要下载的图片尺寸，调用  <code>drawImage</code>  方法在 canvas 中绘制上传的图片</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let image = new Image(); //新建一个img标签</span><br><span class=\"line\">image.src = e.target.result;</span><br><span class=\"line\">let canvas = document.createElement(&#x27;canvas&#x27;);</span><br><span class=\"line\">let context = canvas.getContext(&#x27;2d&#x27;);</span><br><span class=\"line\">context.drawImage(image, 0, 0);</span><br></pre></td></tr></table></figure>\n<h3 id=\"步骤三api-解析drawimage\"><a class=\"markdownIt-Anchor\" href=\"#步骤三api-解析drawimage\">#</a> 步骤三：Api 解析：drawImage</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure>\n<p>**img:** 就是图片对象，可以是页面上获取的 DOM 对象，也可以是虚拟 DOM 中的图片对象。</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1598786576273-20cc4996-634f-4a19-8fb8-68262d4313b0.webp\" alt=\"\"></p>\n<p><strong>（1）dx、dy、dWidth、dHeight：</strong></p>\n<p>表示在  <code>canvas</code>  画布上规划出一片区域用来放置图片， <code>dx, dy</code>  为绘图位置在 Canvas 元素的 X 轴、Y 轴坐标， <code>dWidth, dHeight</code>  指在 Canvas 元素上绘制图像的宽度和高度（如果不说明， 在绘制时图片的宽度和高度不会缩放）。</p>\n<p><strong>（2）sx、sy、swidth、sheight:</strong></p>\n<p>这 4 个参数是用来裁剪源图片的，表示图片在  <code>canvas</code>  画布上显示的大小和位置。 <code>sx, sy</code>  表示在源图片上裁剪位置的 X 轴、Y 轴坐标，然后以  <code>swidth, sheight</code>  尺寸来选择一个区域范围，裁剪出来的图片作为最终在 Canvas 上显示的图片内容（  <code>swidth, sheight</code>  不说明的情况下，整个矩形（裁剪）从坐标的  <code>sx</code>  和  <code>sy</code>  开始，到图片的右下角结束）。</p>\n<p>以下为图片绘制的实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">context.drawImage(image, 0, 0, 100, 100);</span><br><span class=\"line\">context.drawImage(image, 300, 300, 200, 200);</span><br><span class=\"line\">context.drawImage(image, 0, 100, 150, 150, 300, 0, 150, 150);</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/gaoyuanio/imgs/img/1598786576278-66f315b0-3c36-45b3-825d-c8f3171672e1.webp\" alt=\"\"></p>\n<p>Api 中奇怪之处在于，sx、sy、swidth、sheight 为选填参数，但位置在 dx、dy、dWidth、dHeight 之前。</p>\n<h3 id=\"步骤四canvas-输出图片\"><a class=\"markdownIt-Anchor\" href=\"#步骤四canvas-输出图片\">#</a> 步骤四：Canvas 输出图片</h3>\n<p>调用  <code>canvas</code>  的  <code>toDataURL</code>  方法可以输出 base64 格式的图片。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.toDataURL(`image/$&#123;type&#125;`);</span><br></pre></td></tr></table></figure>\n<h3 id=\"步骤五api-解析todataurl\"><a class=\"markdownIt-Anchor\" href=\"#步骤五api-解析todataurl\">#</a> 步骤五：Api 解析：toDataURL</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canvas.toDataURL(type, encoderOptions);</span><br></pre></td></tr></table></figure>\n<p>**type （可选）：** 图片格式，默认为 image/png。</p>\n<p>**encoderOptions （可选）：** 在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。</p>\n<p><strong>a 标签的下载</strong>：调用  <code>&lt;a&gt;</code>  标签的  <code>download</code>  属性，即可完成图片的下载。</p>\n<h3 id=\"步骤六api-解析download\"><a class=\"markdownIt-Anchor\" href=\"#步骤六api-解析download\">#</a> 步骤六：Api 解析：download</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// href 下载必填</span><br><span class=\"line\">&lt;a download=&quot;filename&quot; href=&quot;href&quot;&gt; 下载 &lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>**filename：** 选填，规定作为文件名来使用的文本。</p>\n<p>**href：** 文件的下载地址。</p>\n<h3 id=\"步骤七非主流浏览器下载处理\"><a class=\"markdownIt-Anchor\" href=\"#步骤七非主流浏览器下载处理\">#</a> 步骤七：非主流浏览器下载处理</h3>\n<p>这一步可以解决 Chroma 、 Firefox 和 Safari（自测支持） 浏览器的下载功能，因为 IE 等浏览器不支持  <code>download</code>  属性，所以需要进行其他方式的下载，也就有了代码中的后续内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// base64 图片转 blob 后下载</span><br><span class=\"line\">downloadImg() &#123;</span><br><span class=\"line\">  let parts = this.compressImg.split(&#x27;;base64,&#x27;);</span><br><span class=\"line\">  let contentType = parts[0].split(&#x27;:&#x27;)[1];</span><br><span class=\"line\">  let raw = window.atob(parts[1]);</span><br><span class=\"line\">  let rawLength = raw.length;</span><br><span class=\"line\">  let uInt8Array = new Uint8Array(rawLength);</span><br><span class=\"line\">  for(let i = 0; i &lt; rawLength; ++i) &#123;</span><br><span class=\"line\">    uInt8Array[i] = raw.charCodeAt(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const blob = new Blob([uInt8Array], &#123;type: contentType&#125;);</span><br><span class=\"line\">  this.compressImg = URL.createObjectURL(blob);</span><br><span class=\"line\">  if (window.navigator.msSaveOrOpenBlob) &#123;</span><br><span class=\"line\">    // 兼容 ie 的下载方式</span><br><span class=\"line\">    window.navigator.msSaveOrOpenBlob(blob, this.fileName);</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    const a = document.createElement(&#x27;a&#x27;);</span><br><span class=\"line\">    a.href = this.compressImg;</span><br><span class=\"line\">    a.setAttribute(&#x27;download&#x27;, this.fileName);</span><br><span class=\"line\">    a.click();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>将之前  <code>canvas</code>  生成的 base64 数据拆分后，通过  <code>atob</code>  方法解码</li>\n<li>将解码后的数据转换成 Uint8Array 格式的无符号整形数组</li>\n<li>转换后的数组来生成一个 Blob 数据对象，通过  <code>URL.createObjectURL(blob)</code>  来生成一个临时的 DOM 对象</li>\n<li>之后 IE 类浏览器可以调用  <code>window.navigator.msSaveOrOpenBlob</code>  方法来执行下载，其他浏览器也可以继续通过  <code>&lt;a&gt;</code>  标签的  <code>download</code>  属性来进行下载</li>\n</ul>\n<h3 id=\"步骤八api-解析atob\"><a class=\"markdownIt-Anchor\" href=\"#步骤八api-解析atob\">#</a> 步骤八：Api 解析：atob</h3>\n<p>base-64 解码使用方法是 atob ()。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.atob(encodedStr)</span><br></pre></td></tr></table></figure>\n<p>**encodedStr：** 必需，是一个通过 btoa () 方法编码的字符串，btoa () 是 base64 编码的使用方法。</p>\n<h3 id=\"步骤九api-解析uint8array\"><a class=\"markdownIt-Anchor\" href=\"#步骤九api-解析uint8array\">#</a> 步骤九：Api 解析：Uint8Array</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Uint8Array(length)</span><br></pre></td></tr></table></figure>\n<p>**length：** 创建初始化为 0 的，包含 length 个元素的无符号整型数组。</p>\n<h3 id=\"步骤十api-解析blob\"><a class=\"markdownIt-Anchor\" href=\"#步骤十api-解析blob\">#</a> 步骤十：Api 解析：Blob</h3>\n<p><code>Blob</code>  对象表示一个不可变、原始数据的类文件对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 构造函数允许通过其它对象创建 Blob 对象</span><br><span class=\"line\">new Blob([obj],&#123;type:createType&#125;)</span><br></pre></td></tr></table></figure>\n<p>**obj：** 字符串内容</p>\n<p>**createType：** 要构造的类型，兼容性 IE 10 以上</p>\n<h3 id=\"步骤十一api-解析createobjecturl\"><a class=\"markdownIt-Anchor\" href=\"#步骤十一api-解析createobjecturl\">#</a> 步骤十一：Api 解析：createObjectURL</h3>\n<p>静态方法会创建一个 DOMString。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objectURL = URL.createObjectURL(object);</span><br></pre></td></tr></table></figure>\n<p>**object：** 用于创建 URL 的 File 对象、Blob 对象或者 MediaSource 对象。</p>\n<h3 id=\"步骤十二api-解析windownavigator\"><a class=\"markdownIt-Anchor\" href=\"#步骤十二api-解析windownavigator\">#</a> 步骤十二：Api 解析：window.navigator</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 官方已不建议使用的文件下载方式，仅针对 ie 且兼容性 10 以上</span><br><span class=\"line\">// msSaveBlob 仅提供下载</span><br><span class=\"line\">// msSaveOrOpenBlob 支持下载和打开</span><br><span class=\"line\">window.navigator.msSaveOrOpenBlob(blob, fileName);</span><br></pre></td></tr></table></figure>\n<p>**blob：** 要下载的 blob 对象</p>\n<p>**fileName：** 下载后命名的文件名称。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>本方法仅针对图片压缩介绍了一些思路，简单的使用场景可能如下介绍，当然也会引申出来更多的使用场景，这些还有待大家一起挖掘。</p>\n<ul>\n<li>上传存储图片如果需要对文件大小格式有要求的，可以统一压缩处理图片</li>\n<li>前台页面想要编辑图片，可以在 Canvas 处理图片的时候，加一些其他逻辑，例如添加文字，剪裁，拼图等等操作</li>\n</ul>\n<p>tip：因部分接口有 IE 兼容性问题，IE 浏览器方面，仅能支持 IE 10 以上版本进行下载。</p>\n",
            "tags": [
                "javascript"
            ]
        }
    ]
}